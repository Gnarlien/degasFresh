 $Id: ce9b35405ba56e4a33b223bec4a84d4467f8e5c0 $
\Title{collide}


@* The routines to process various reactions.

\ID{$Id: ce9b35405ba56e4a33b223bec4a84d4467f8e5c0 $}

@m FILE 'collide.web'

@m RR 1
@m NEU_DIAG_CX 0

@I macros.hweb
@I particle.hweb
@I problem.hweb
@I random.hweb
@I background.hweb
@I geomint.hweb
@I vector.hweb
@I zone.hweb
@I species.hweb
@I string.hweb
@I reaction.hweb
@I reactiondata.hweb
@I location.hweb
@I xsection.hweb
@I output.hweb
@I materials.hweb
@I flight.hweb

@ The main program.

@a
      @<Functions and Subroutines@>

@ Pick a reaction to process.
@<Functions...@>=
      subroutine pick_reaction(pr_test_dummy(test),
     $     pr_reaction_dummy(ts_reac),rate,independent_parameters,
     $     nprod,sp_dummy(prod),vc_dummy(v_prod),
     $     w_prod,scoring_data,rn_dummy(x))

      implicit_none_f77
      rc_common                                         // Common
      pr_common
      implicit_none_f90

      pr_test_decl(test)                                // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      integer nprod                                     // Output
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])
      real w_prod[rc_product_max],scoring_data[scoring_data_max]
      rn_decl(x)                                        // Input/output

      pr_reaction_decl(pr_reac)                         // Local  

      pr_reac=pr_ts_rc(test,ts_reac) 
/* 
   Split up into different reaction types. Note that for now types |dissoc|
   and |dissoc_rec| use the same processing routine; the distinction between
   the two currently exists because different logic is required during the
   ``set products'' phase of |problemsetup|.
*/
      if (rc_reaction_type(pr_reaction(pr_reac)) == 'chargex') then
         call chargex(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'elastic') then
         call elastic(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'bgk_elastic') then
         call bgk_elastic(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'dissoc') then
         call dissoc(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'dissoc_rec') then
         call dissoc(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'dissoc_cramd') then
         call dissoc_cramd(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'ionize') then
         call ionize(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'excitation') then
         call excite(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'deexcitation') then
         call excite(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'ion_conv') then
         call ion_conv(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))
      else
         assert('Unsupported reaction type' == ' ')
      end if

      return
      end

@ Process a charge exchange reaction.

@<Functions...@>=
      subroutine chargex(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_dummy(prod),vc_dummy(v_prod),w_prod,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common                                        // Common
      rc_common
      rd_common
      sp_common
      implicit_none_f90

      rd_decls
      rn_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      integer nprod                                    // Output
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])
      real w_prod[rc_product_max],scoring_data[scoring_data_max]
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)
      pr_test_decl(test_i)
      integer i,i_cx,i_sigv_max,jdep_cx,count,psp_i
      vc_decl(v_test)
      vc_decl(v_back)
      vc_decl(vb_flow)
      vc_decl(vt_plasma_frame)
      vc_decl(vb_therm)
      vc_decl(vrel)
      vc_decl(v_i)
      real v_thermal,ran,sgvmax,cxsec,cx_v,m_i
      logical init

      external eval_data                              // External
      real eval_data

      save init,i_sigv_max,i_cx
      data init/.true./

      if (init) then
         i_sigv_max=string_lookup('sigv_max',pr_var0_list,pr_var0_num)
         i_cx=string_lookup('cross_section',pr_var0_list,pr_var0_num)
         assert(i_sigv_max > 0 && i_cx > 0)
         init=.false.
      end if

      pr_reac=pr_ts_rc(test,ts_reac)  // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)
      count=0

      sgvmax=zero
      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_sigv_max) then
            sgvmax=eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_cx) then
            jdep_cx=i
         end if
      end do

/*
   Transform to frame moving with the local background flow velocity
*/
      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
         vb_flow[i]=independent_parameters[xs_var_v_flow_1+i-1]
      end do
      vc_difference(v_test,vb_flow,vt_plasma_frame)

loop: continue
      count++
 /* Pick a background particle */
      v_thermal=sqrt(independent_parameters[xs_var_sp_temperature])
      call random_gauss(vb_therm,3,rn_args(x))
      do i=1,3
         vb_therm[i]*=v_thermal
      end do

/*
  Now evaluate velocity {\em relative} to this particular particle
  (we need to transform to the frame moving at |vb_flow| ahead of
  time since the average of |vb_therm| is 0.).
*/
      vc_difference(vt_plasma_frame,vb_therm,vrel)

/*
  And re-evaluate the |independent_parameters| associated with the
  relative test energy.
*/
      independent_parameters[xs_var_energy]
     $     =half*independent_parameters[xs_var_m_test]*vc_abs2(vrel)
      independent_parameters[xs_var_sp_energy]=half*vc_abs2(vrel)

      cxsec=eval_data(rd_data_args(reaction_handling,[pr_reac][jdep_cx]),
     $    independent_parameters,rn_args(x))
      cx_v=cxsec*vc_abs(vrel)

@#if 0
      assert(cx_v<=sgvmax)    // Can disable rejection with |sgvmax| = 0.
@#endif

      rn_next(ran,x)

      if (cx_v < ran*sgvmax) goto loop
/*
   This was previously inside the ``test'' section of the velocity
   setting code.  But, it wasn't getting executed for the case 
   in which there are no test products.  
*/
      vc_add(vb_therm,vb_flow,v_back)
/*
   Make use here of the assumptions regarding ordering of species that
   are made in problemsetup's |check_problem| and in |set_prod_chargex|.
   Namely, that the first (second) reagent is a background (test) species
   and that an electron is transferred from the second to the first.
   In this way, the velocity of the first (second) product is just that
   of the background (test) reagent.
*/
      assert(pr_num_arrangements(test,ts_reac) == 1)
      assert(nprod == 2)   // Checked in |set_prod_chargex|
      do i=1,2
         prod[i]=pr_ts_prod(test,ts_reac,1,i)
         w_prod[i]=one
         if (i == 1) then
            vc_copy(v_back,v_prod[i])
         else
            vc_copy(v_test,v_prod[i])
         end if
      end do
/*
   Collision scoring 
*/
      do i=1,2
         if (i == 1) then
            m_i=sp_m(pr_background(back))
            psp_i=pr_problem_sp_back(back)
            vc_copy(v_back,v_i)
         else if (i == 2) then
            m_i=sp_m(pr_test(test))
            psp_i=pr_problem_sp_test(test)
            vc_copy(v_test,v_i)
         end if
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        -m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        -m_i*v_i[1]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        -m_i*v_i[2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        -m_i*v_i[3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        -half*m_i*vc_abs2(v_i)*rate
      end do
/*
   Because of the way neutral-neutral reactions are specified (with 
   neutral species in both background and test lists), getting test
   and background products correct in other reactions requires looking
   for test species first.
*/
      do i=1,nprod
         test_i=pr_test_lookup(prod[i])
         if (test_i != 0) then
            m_i=sp_m(pr_test(test_i))
            psp_i=pr_problem_sp_test(test_i)
         else
            back_i=pr_background_lookup(prod[i])
            assert(back_i != 0)
            m_i=sp_m(pr_background(back_i))
            psp_i=pr_problem_sp_back(back_i)
         end if
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        m_i*v_prod[i][1]*rate 
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        m_i*v_prod[i][2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        m_i*v_prod[i][3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        half*m_i*vc_abs2(v_prod[i])*rate
      end do

      return
      end

@ Process an elastic collision. Arguments are the same as for |chargex|.

@<Functions...@>=
      subroutine elastic(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_dummy(prod),vc_dummy(v_prod),w_prod,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common                                        // Common
      rc_common
      rd_common
      sp_common
      implicit_none_f90

      rd_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      integer nprod                                    // Output
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])
      real w_prod[rc_product_max],scoring_data[scoring_data_max]
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)
      pr_test_decl(test_i)
      integer i,rm_theta_prob,theta_count,coll_count,psp_i,
     $        i_sigv_max,i_angle_min,i_cx,i_csang,jdep_cx
      vc_decl(v_test)
      vc_decl(v_back)
      vc_decl(vb_flow)
      vc_decl(vt_plasma_frame)
      vc_decl(vb_therm)
      vc_decl(vrel)
      vc_decl(v_i)
      real v_thermal,sigvmax,cxsec,cx_v,m_i,angle,angle_min,ran
      logical init

      external eval_data                               // External
      real eval_data
      rn_decls

      save init,i_sigv_max,i_angle_min,i_cx,i_csang
      data init/.true./

      if (init) then
         i_sigv_max=string_lookup('sigv_max',pr_var0_list,pr_var0_num)
         i_angle_min=string_lookup('angle_min',pr_var0_list,pr_var0_num)
         i_cx=string_lookup('cross_section',pr_var0_list,pr_var0_num)
         i_csang=string_lookup('scattering_angle',pr_var0_list,pr_var0_num)
         assert(i_sigv_max > 0 && i_angle_min > 0 && i_cx > 0 && i_csang > 0)
         init=.false.
      end if

      pr_reac=pr_ts_rc(test,ts_reac)  // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)

      sigvmax=zero
      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_sigv_max) then
            sigvmax=eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_angle_min) then
            angle_min=eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_cx) then
            jdep_cx=i
         else if  (reaction_handling_var0[pr_reac][i] == i_csang) then
            rm_theta_prob=i
         end if
      end do

/*     
      Transform to frame moving with the local background flow velocity
*/

      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
         vb_flow[i]=independent_parameters[xs_var_v_flow_1+i-1]
      end do
      vc_difference(v_test,vb_flow,vt_plasma_frame)

loop: continue
/*
  Pick a background particle
*/
      v_thermal=sqrt(independent_parameters[xs_var_sp_temperature])
      call random_gauss(vb_therm,3,rn_args(x))
      do i=1,3
         vb_therm[i]*=v_thermal
      end do

/*
   Evaluate velocity {\em relative} to this particle
*/
      vc_difference(vt_plasma_frame,vb_therm,vrel)

/*
  And re-evaluate the |independent_parameters| associated with the
  relative test energy.
*/
      independent_parameters[xs_var_energy]
     $     =half*independent_parameters[xs_var_m_test]*vc_abs2(vrel)
      independent_parameters[xs_var_sp_energy]=half*vc_abs2(vrel)

      cxsec=eval_data(rd_data_args(reaction_handling,[pr_reac][jdep_cx]),
     $    independent_parameters,rn_args(x))
      cx_v=cxsec*vc_abs(vrel)

/*
    May want to turn off this |assert| (as in |chargex|) so that 
    rejection can be disabled by setting |sigvmax| = 0.
*/
@#if 0
      assert(cx_v<=sigvmax)
@#endif
      rn_next(ran,x)

@#if 0
      if(cx_v < ran*sigvmax) goto loop
@#endif
/*
   Temporary hack until we can install a better rejection technique.
*/
      if(cx_v <= sigvmax && cx_v < ran*sigvmax) goto loop
/*
  Interpolate the scattering angle:
*/
      angle=eval_data(rd_data_args(reaction_handling,[pr_reac][rm_theta_prob]),
     $ independent_parameters,rn_args(x))

/*
      The scattering angle data may be set up to ensure that simple
      interpolation yields exactly |angle_min| at the correct maximum
      probability, $p_{\rm max}$ (which will not in general coincide with
      a probability bin value). Doing so entails setting the scattering
      angle for the next higher probability data bin value less than
      |angle_min|.
*/

      if (angle < angle_min) angle=angle_min       

/*
      Do the scattering:
*/

      call product_velocities(angle,independent_parameters,
     &     vc_args(vt_plasma_frame),vc_args(vb_therm),vc_args(vrel),
     &     vc_args(v_prod[1]),rn_args(x))

/*
   Just assign the products directly. 
*/

      assert(pr_num_arrangements(test,ts_reac) == 1) 

      do i=1,nprod
         prod[i]=pr_ts_prod(test,ts_reac,1,i)
         w_prod[i]=one
         vc_add(v_prod[i],vb_flow,v_prod[i])
      end do
      
      vc_add(vb_therm,vb_flow,v_back)

/*
   Collision scoring - only background sources expected here.
*/
      do i=1,2
         if (i == 1) then
            m_i=sp_m(pr_background(back))
            psp_i=pr_problem_sp_back(back)
            vc_copy(v_back,v_i)
         else if (i == 2) then
            m_i=sp_m(pr_test(test))
            psp_i=pr_problem_sp_test(test)
            vc_copy(v_test,v_i)
         end if
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        -m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        -m_i*v_i[1]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        -m_i*v_i[2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        -m_i*v_i[3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        -half*m_i*vc_abs2(v_i)*rate
      end do
/*
   Because of the way neutral-neutral reactions are specified (with 
   neutral species in both background and test lists), getting test
   and background products correct in other reactions requires looking
   for test species first.
*/
      do i=1,nprod
         test_i=pr_test_lookup(prod[i])
         if (test_i != 0) then
            m_i=sp_m(pr_test(test_i))
            psp_i=pr_problem_sp_test(test_i)
         else
            back_i=pr_background_lookup(prod[i])
            assert(back_i != 0)
            m_i=sp_m(pr_background(back_i))
            psp_i=pr_problem_sp_back(back_i)
         end if
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        m_i*v_prod[i][1]*rate 
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        m_i*v_prod[i][2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        m_i*v_prod[i][3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        half*m_i*vc_abs2(v_prod[i])*rate
      end do

      return
      end

@ Process an n-n collision. Arguments are the same as for |chargex|.

/*    A concise representations of the equations used is presented in
      Morse, T.F., "Kinetic Model Equations for a Gas Mixture", The Physics of Fluids,
      1964, 7(12): pgs. 2012-2013.   */

@<Functions...@>=
      subroutine bgk_elastic(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_dummy(prod),vc_dummy(v_prod),w_prod,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common                                        // Common
      rc_common
      rd_common
      sp_common
      bk_common
      zn_common
      implicit_none_f90

      rd_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)

      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])
      real w_prod[rc_product_max],scoring_data[scoring_data_max]
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)

      vc_decl(v_test)
      vc_decl(v_back)
      vc_decl(vb_flow)
      vc_decl(vbt_flow)
      vc_decl(v_diff)
      vc_decl(v_ave)
      vc_decl(vt_plasma_frame)
      vc_decl(vb_therm)
      vc_decl(vrel)
      vc_decl(v_i)

      integer i,nprod,back_test,psp_i

      real v_thermal,m_i,rate
      real independent_parameters[xs_max_indep_params],ran[1]
      real m_total,m_coef,temp_test,temp_back,temp_ave

      pr_reac=pr_ts_rc(test,ts_reac)  // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)

      if (pr_test(test) == pr_background(back)) then
/*
    Like-species collision 
*/
         do i=1,3
            vb_flow[i]=independent_parameters[xs_var_v_flow_1+i-1]
         end do
         v_thermal=sqrt(independent_parameters[xs_var_sp_temperature])
      else
/*    
   Unlike-species: select thermal velocity from average distribution   
*/
         m_total = sp_m(pr_test(test)) + sp_m(pr_background(back))
         m_coef = two*sp_m(pr_test(test))*sp_m(pr_background(back))/m_total**2
         back_test = pr_background_lookup(pr_test(test))
         do i=1,3
            vb_flow[i] = independent_parameters[xs_var_v_flow_1+i-1]
            vbt_flow[i] = independent_parameters[xs_var_v_flowb_1+i-1]
       
            v_ave[i] = (sp_m(pr_background(back_test))*vbt_flow[i]
     $           + sp_m(pr_background(back))*vb_flow[i])/m_total
         end do
         vc_difference(vb_flow,vbt_flow,v_diff)
         vc_copy(v_ave,vb_flow)      // To match like-species expression

         temp_test = bk_temp(back_test,int(independent_parameters[xs_var_zone]))
         temp_back = bk_temp(back,int(independent_parameters[xs_var_zone]))
         temp_ave = temp_test 
     $        +m_coef*((temp_back-temp_test)
     $        +sp_m(pr_background(back))*vc_abs2(v_diff)/const(6.))
         v_thermal = sqrt( temp_ave / sp_m(pr_test(test)) )
      endif
/*    
   Select Background Thermal Velocity   
*/
      do i=1,3
         rn_gauss_next(ran,x)
         vb_therm[i]=v_thermal*ran[1]
      end do
/*    
   End of Neutral Selection - set products and do scoring 
*/
      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
      end do
      m_i=sp_m(pr_test(test))
      psp_i=pr_problem_sp_test(test)
      vc_copy(v_test,v_i)
/*
   Do scoring. Currently scoring only the test species. Background
   species may follow later. Explicitly no mass exchange.
*/
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $     -m_i*v_i[1]*rate
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $     -m_i*v_i[2]*rate
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $     -m_i*v_i[3]*rate
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $     -half*m_i*vc_abs2(v_i)*rate

/*
   Set products
*/
      assert(pr_num_arrangements(test,ts_reac) == 1) 
      do i=1,nprod
         prod[i]=pr_ts_prod(test,ts_reac,1,i)
         if ( i == 1 ) then
            w_prod[i] = zero
            vc_set(v_prod[i],zero,zero,zero)
         else if ( i == 2 ) then
            w_prod[i] = one
            vc_add(vb_therm,vb_flow,v_prod[i])
         endif
      end do

      vc_copy(v_prod[2],v_i)
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $     m_i*v_i[1]*rate
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $     m_i*v_i[2]*rate
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $     m_i*v_i[3]*rate
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $     half*m_i*vc_abs2(v_i)*rate
      
      return
      end

@ Process a dissociation. Arguments are the same as for |chargex|.

@<Functions...@>=
      subroutine dissoc(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_dummy(prod),vc_dummy(v_prod),w_prod,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common                                        // Common
      rc_common
      sp_common
      rd_common

      implicit_none_f90

      rd_decls
      rn_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      integer nprod                                    // Output
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])
      real w_prod[rc_product_max],scoring_data[scoring_data_max]
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)
      pr_test_decl(test_i)
      rc_decl(reac)
      integer i,i_ediss,i_elediss,num_heavy_products,j_arr,psp_i,
     $        num_lines,i_e_rate,i_gen_rate
      integer product_index[2],lines[pr_max_lines],e_rates[pr_max_lines]
      vc_decl(v_test)
      vc_decl(v_iso)
      vc_decl(v_emitter)
      real sum,ran,ediss,elediss,v_diss1,v_diss2,m_i
      real mass[2]
      logical init,first_line
      character*tl_tag_length line

      external eval_data                               // External
      real eval_data
      save init,i_ediss,i_elediss,num_lines,lines,e_rates,i_gen_rate
      data init/.true./

      if (init) then
         i_ediss=string_lookup('dissociation_energy',pr_var0_list,pr_var0_num)
         i_elediss=string_lookup('background_energy_loss_rate',
     $        pr_var0_list,pr_var0_num)
         assert(i_ediss > 0 && i_elediss > 0)
         num_lines=0
         do i=1,pr_var0_num
            if (pr_var0_list[i]SP(1:10) == 'wavelength') then
               num_lines++
               lines[num_lines]=i
               line=pr_var0_list[i]SP(11:)
               i_e_rate=string_lookup('emission_rate'\/line,
     $              pr_var0_list,pr_var0_num)
               assert(i_e_rate > 0)
               e_rates[num_lines]=i_e_rate
            end if
         end do
         if (num_lines > 0) then
/* 
   A non-zero |i_gen_rate| will indicate that the same rate is intended to
   be used for all wavelengths present (see subroutine |ionize|).
*/
            i_gen_rate=string_lookup('emission_rate',pr_var0_list,pr_var0_num)
         end if
         init=.false.
      end if
      
      pr_reac=pr_ts_rc(test,ts_reac)   // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)
/*
   Randomly select from the various product arrangements available for this
   test particle-reaction combination. The array |pr_prod_mult| provides the
   probability for each.
*/
      sum=zero
      rn_next(ran,x)
      do i=1,pr_num_arrangements(test,ts_reac)
         sum=sum+pr_prod_mult(test,ts_reac,i)
         if (sum >= ran) then
            j_arr=i
            goto break
         end if
      end do

break:continue

/*
   Get an isotropic unit vector to use in setting the product velocities.
*/
      rn_iso_next(v_iso,x)

      num_heavy_products=0
      do i=1,nprod
         prod[i]=pr_ts_prod(test,ts_reac,j_arr,i)
         if (sp_sy(prod[i]) != 'e') then
            num_heavy_products++
            mass[num_heavy_products]=sp_m(prod[i])
            product_index[num_heavy_products]=i
         end if
      end do
/*
   Need to set the emitter mass so wavelength can be evaluated.
*/      
      reac=pr_reaction(pr_reac)
      if (rc_emitter(reac) != 0) then
         if (rc_emitter(reac) > 0) then
            independent_parameters[xs_var_m_emitter]=sp_m(prod[rc_emitter(reac)])
/* Don't really recall which reagent is which. Should be able to tell
   test from a back just with |sp_generic|.
*/
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_test(test))) then
            independent_parameters[xs_var_m_emitter]=sp_m(pr_test(test))
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_background(back))) then
            assert('background velocity not set' == ' ')
         end if
      end if

      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_ediss) then
            ediss=eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_elediss) then
            elediss=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] != pr_var_unknown) then
            scoring_data[reaction_handling_var0[pr_reac][i]]
     $           =eval_data(rd_data_args(reaction_handling,
     $           [pr_reac][i]),independent_parameters,rn_args(x))
         end if
      end do
/*
   Transfer emission rate data from generic slot |i_gen_rate| to wavelength-
   specific slot |e_rates[i]| corresponding to non-zero wavelength. Note
   the density factor, as is done for the ionization rate above.  For
   the explicitly labeled lines, just need to add density factor.

   See comment in subroutine |ionize| regarding generic and explicit
   wavelengths.
*/
      if (num_lines > 0) then
         first_line=.true.
         do i=1,num_lines
            if ((i_gen_rate > 0) && first_line) then
               if (scoring_data[lines[i]] > zero) then
                  assert(scoring_data[e_rates[i]] == zero)
                  assert(rc_emitter(reac) != 0)
                  scoring_data[e_rates[i]]=scoring_data[i_gen_rate]
     $                 *independent_parameters[xs_var_density]
                  first_line=.false.
               end if
            else
               if (scoring_data[lines[i]] > zero) then
                  scoring_data[e_rates[i]]*=independent_parameters[xs_var_density]
               end if
            end if
         end do
      end if
/*
   Set speeds of products so as to conserve momentum. This routine is 
   equipped to deal with only two heavy products.
*/
      assert(num_heavy_products == 2)
      v_diss1=sqrt(const(4.0)*ediss*(mass[2]/mass[1])/(mass[1]+mass[2]))
      v_diss2=-v_diss1*mass[1]/mass[2]

/*
   Set product velocities by transforming back into the lab frame (from the
   test particle frame). Set weight fractions.
*/
      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
      end do

      do i=1,nprod

         if (product_index[1] == i) then
            vc_xvt(v_test,v_iso,v_diss1,v_prod[i])
@#if RR
/* Note: could add a check of generic species here as well. */
            if (pr_test_lookup(prod[i]) > 0 && prod[i]==prod[product_index[2]]) then
               w_prod[i]=two
            else
               w_prod[i]=one
            end if
@#else
            w_prod[i]=one
@#endif
         else if (product_index[2] == i) then
            vc_xvt(v_test,v_iso,v_diss2,v_prod[i])
@#if RR
            if (pr_test_lookup(prod[i]) > 0 && prod[i]==prod[product_index[1]]) then
               w_prod[i]=zero
            else
               w_prod[i]=one
            end if
@#else
            w_prod[i]=one
@#endif
         else
            vc_set(v_prod[i],zero,zero,zero)
            w_prod[i]=zero
         end if
      end do
/*
   Now set emitter velocity.
*/
      if (rc_emitter(reac) != 0) then
         if (rc_emitter(reac) > 0) then
            vc_copy(v_prod[rc_emitter(reac)],v_emitter)
/* Don't really recall which reagent is which. Should be able to tell
   test from a back just with |sp_generic|.
*/
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_test(test))) then
            vc_copy(v_test,v_emitter)
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_background(back))) then
            assert('background velocity not set' == ' ')
         end if
         scoring_data[pr_var_emitter_v_vector]=v_emitter[1]
         scoring_data[pr_var_emitter_v_2]=v_emitter[2]
         scoring_data[pr_var_emitter_v_3]=v_emitter[3]
      end if

/*
   Collision scoring. Will be adding some H-alpha detection and scoring.
   Note: assume background is an electron so that no reagent background
   momentum is lost.
*/
      psp_i=pr_problem_sp_back(back)
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $  -sp_m(pr_background(back))*rate
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=-elediss

      psp_i=pr_problem_sp_test(test)
      m_i=sp_m(pr_test(test))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        -m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        -m_i*v_test[1]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        -m_i*v_test[2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        -m_i*v_test[3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        -half*m_i*vc_abs2(v_test)*rate
/*
   Use the weight factors here so that the Russian roulette result is
   accounted for in the scoring.
*/
      do i=1,nprod
         test_i=pr_test_lookup(prod[i])
         if (test_i != 0) then
            m_i=sp_m(pr_test(test_i))*w_prod[i]
            psp_i=pr_problem_sp_test(test_i)
         else
            back_i=pr_background_lookup(prod[i])
            assert(back_i != 0)
            m_i=sp_m(pr_background(back_i))
            psp_i=pr_problem_sp_back(back_i)
         end if
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        m_i*v_prod[i][1]*rate 
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        m_i*v_prod[i][2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        m_i*v_prod[i][3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        half*m_i*vc_abs2(v_prod[i])*rate
      end do

      return
      end

@ Process a dissociation for CRAMD. Arguments are the same as for |chargex|.

@<Functions...@>=
      subroutine dissoc_cramd(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_dummy(prod),vc_dummy(v_prod),w_prod,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common                                        // Common
      rc_common
      sp_common
      rd_common

      implicit_none_f90

      rd_decls
      rn_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      integer nprod                                    // Output
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])
      real w_prod[rc_product_max],scoring_data[scoring_data_max]
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)
      integer i,i_eloss,i_iloss,i_hfrac,num_heavy_products,j_arr
      integer product_index[2]
      vc_decl(v_test)
      vc_decl(v_iso)
      real sum,ran,eloss,iloss,hfrac,ediss,v_diss1,v_diss2,m_i
      real mass[2]
      logical init

      external eval_data                               // External
      real eval_data
      save init,i_eloss,i_iloss,i_hfrac
      data init/.true./

      if (init) then
         i_eloss=string_lookup('background_energy_loss_rate',pr_var0_list,
     $        pr_var0_num)
         i_iloss=string_lookup('proton_energy_loss_rate',pr_var0_list,
     $        pr_var0_num)
         i_hfrac=string_lookup('H_fraction',pr_var0_list,pr_var0_num)
         assert(i_eloss > 0 && i_iloss > 0 && i_hfrac > 0) 
         init=.false.
      end if
      
      pr_reac=pr_ts_rc(test,ts_reac)   // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)

/*
   Randomly select from the various product arrangements available for this
   test particle-reaction combination. The array |pr_prod_mult| provides the
   probability for each.
*/
      sum=zero
      rn_next(ran,x)
      do i=1,pr_num_arrangements(test,ts_reac)
         sum=sum+pr_prod_mult(test,ts_reac,i)
         if (sum >= ran) then
            j_arr=i
            goto break
         end if
      end do

break:continue

/*
   Get an isotropic unit vector to use in setting the product velocities.
*/
      rn_iso_next(v_iso,x)

      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_eloss) then
            eloss=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_iloss) then

/*
   The multiplier here should really be the ion density. The existing
   CRAMD data assume equal electron and ion densities anyway, so do the
   convenient thing here. If that condition is relaxed, should factor the
   density ratio into the externally computed value of |iloss|; this would
   keep its usage consistent with the present definition of the dissociation
   reaction.
*/
            iloss=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_hfrac) then
            hfrac=eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         end if
      end do

      num_heavy_products=0
      do i=1,nprod
         prod[i]=pr_ts_prod(test,ts_reac,j_arr,i)
         if (sp_sy(prod[i]) != 'e') then
            num_heavy_products++
            mass[num_heavy_products]=sp_m(prod[i])
            product_index[num_heavy_products]=i
            if (sp_z(prod[i]) == 0) then
               w_prod[i]=two*hfrac
            else
               assert(sp_z(prod[i]) > 0)
               w_prod[i]=two*(one-hfrac)
            end if
         else
            w_prod[i]=zero
         end if
      end do
      
/* 
   For the time being, the actual dissocation energy is hardwired at 3 eV.
   Doing better will require significant improvements to CRAMD.
*/
      ediss=const(3.)*electron_charge    
/*
   Set speeds of products so as to conserve momentum. This routine is 
   equipped to deal with only two heavy products.
*/
      assert(num_heavy_products == 2)
      v_diss1=sqrt(const(4.0)*ediss*(mass[2]/mass[1])/(mass[1]+mass[2]))
      v_diss2=-v_diss1*mass[1]/mass[2]

/*
   Set product velocities by transforming back into the lab frame (from the
   test particle frame). Set weight fractions.
*/
      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
      end do
      do i=1,nprod
         if (product_index[1] == i) then
            vc_xvt(v_test,v_iso,v_diss1,v_prod[i])
         else if (product_index[2] == i) then
            vc_xvt(v_test,v_iso,v_diss2,v_prod[i])
         else
            vc_set(v_prod[i],zero,zero,zero)
         end if
      end do

/*
   Collision scoring. This isn't done yet. There remain the MAR and 
   H-alpha data to implement. Scores of test species are not done
   (assuming that CRAMD is deprecated). Commented out as a result.
*/
@#if 0
      scoring_data[pr_var_back_index(pr_var_mass_change,back)]+=
     $  -sp_m(pr_background(back))*rate
      scoring_data[pr_var_back_index(pr_var_energy_change,back)]+=-eloss
      do i=1,nprod
         back_i=pr_background_lookup(prod[i])
         if (back_i != 0) then
            m_i=sp_m(pr_background(back_i))
            if (sp_sy(prod[i]) == 'e') then
               scoring_data[pr_var_back_index(pr_var_mass_change,back_i)]+=
     $              m_i*(const(3.)-two*hfrac)*rate
            else
               scoring_data[pr_var_back_index(pr_var_mass_change,back_i)]+=
     $              m_i*two*(one-hfrac)*rate
               scoring_data[pr_var_back_index(pr_var_momentum_change_vector,back_i)]+=
     $              m_i*v_prod[i][1]*two*(one-hfrac)*rate
               scoring_data[pr_var_back_index(pr_var_momentum_change_2,back_i)]+=
     $              m_i*v_prod[i][2]*two*(one-hfrac)*rate
               scoring_data[pr_var_back_index(pr_var_momentum_change_3,back_i)]+=
     $              m_i*v_prod[i][3]*two*(one-hfrac)*rate
               scoring_data[pr_var_back_index(pr_var_energy_change,back_i)]+=
     $              half*m_i*vc_abs2(v_prod[i])*two*(one-hfrac)*rate-iloss
            end if
         end if
      end do
@#endif

      return
      end

@ Process an ionization. Arguments are the same as for |chargex|. This
routine is required for ionizations which are not treated by the method
of suppressed absorption.

@<Functions...@>=
      subroutine ionize(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_dummy(prod),vc_dummy(v_prod),w_prod,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common
      rc_common
      sp_common
      rd_common

      implicit_none_f90

      rd_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      integer nprod                                    // Output
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])
      real w_prod[rc_product_max],scoring_data[scoring_data_max]
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)
      pr_test_decl(test_i)
      rc_decl(reac)
      integer i,i_eioniz,num_lines,i_e_rate,i_gen_rate,psp_i
      integer lines[pr_max_lines],e_rates[pr_max_lines]
      real eioniz,m_i
      vc_decl(v_test)
      vc_decl(v_emitter)
      character*tl_tag_length line
      logical init,first_line

      external eval_data,species_add_check             // External
      real eval_data
      logical species_add_check
      save init,i_eioniz,num_lines,lines,e_rates,i_gen_rate
      data init/.true./

      if (init) then
         i_eioniz=string_lookup('background_energy_loss_rate',pr_var0_list,
     $        pr_var0_num)
         num_lines=0
         do i=1,pr_var0_num
            if (pr_var0_list[i]SP(1:10) == 'wavelength') then
               num_lines++
               lines[num_lines]=i
               line=pr_var0_list[i]SP(11:)
               i_e_rate=string_lookup('emission_rate'\/line,
     $              pr_var0_list,pr_var0_num)
               assert(i_e_rate > 0)
               e_rates[num_lines]=i_e_rate
            end if
         end do
         if (num_lines > 0) then
            i_gen_rate=string_lookup('emission_rate',pr_var0_list,pr_var0_num)
/*
   Take this out for now so we can handle multiple lines per reaction
   (with properly labeled emission rates).
*/
@#if 0
            assert(i_gen_rate > 0)
@#endif
         end if
         init=.false.
      end if
      
      pr_reac=pr_ts_rc(test,ts_reac)   // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)
      assert(pr_num_arrangements(test,ts_reac) == 1)

/*
   Trying this approach here; may want to propagate into the other
   scoring routines: loop through the ``handling'' dependent variables.
   Grab everything which is explicitly needed for this routine to work.
   Dump everything else into |scoring_data| along with its name. This
   will allow: 
   \begin{enumerate}
     \item This code to not keep track of which emission lines (if
           any at all) are present in the data.
     \item Any data which are special to a particular reaction of this
           type to be scored simply by setting |tally_dep_var| to the
           same label. {\em This code would not require modification.}
   \end{enumerate}

   The logic used here to set product velocities is specific for electron
   impact ionization.  Need something more complex for ion impact ionization
   that can account for energy losses due to excitation and ionization by the
   background population, but also conserve energy.
*/
      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
      end do
      do i=1,nprod
         prod[i]=pr_ts_prod(test,ts_reac,1,i)
         if (sp_sy(prod[i]) != 'e') then
            vc_copy(v_test,v_prod[i])
            w_prod[i]=one
         else
            vc_set(v_prod[i],zero,zero,zero)
            w_prod[i]=zero
         end if
      end do

      reac=pr_reaction(pr_reac)
      if (rc_emitter(reac) != 0) then
         if (rc_emitter(reac) > 0) then
            vc_copy(v_prod[rc_emitter(reac)],v_emitter)
            independent_parameters[xs_var_m_emitter]=sp_m(prod[rc_emitter(reac)])
/* Don't really recall which reagent is which. Should be able to tell
   test from a back just with |sp_generic|.
*/
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_test(test))) then
            vc_copy(v_test,v_emitter)
            independent_parameters[xs_var_m_emitter]=sp_m(pr_test(test))
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_background(back))) then
            assert('background velocity not set' == ' ')
         end if
         scoring_data[pr_var_emitter_v_vector]=v_emitter[1]
         scoring_data[pr_var_emitter_v_2]=v_emitter[2]
         scoring_data[pr_var_emitter_v_3]=v_emitter[3]
      end if

      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_eioniz) then
            eioniz=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] != pr_var_unknown) then
            scoring_data[reaction_handling_var0[pr_reac][i]]
     $           =eval_data(rd_data_args(reaction_handling,
     $           [pr_reac][i]),independent_parameters,rn_args(x))
         end if
      end do
/*
   ``In general'' the emission rate and wavelength variables should both
   have the name of the line appended to the variable names. For the case
   of greatest interest, this would entail carrying around 3 sets of 
   (usually) identical data - one for each hydrogen isotope. This
   is a compromise: since we assume only one emitter, we can give it a
   generic name without confusion. Below we look for the {\em first} nonzero 
   wavelength and upon finding it reset the emission rate variable to 
   have the corresponding line name.  

   This sort of detail is only needed when computing spectra.  For more
   typical applications, a single, isotope-independent line will suffice.
   These can be used in addition to the generic line(s), but their 
   wavelengths must come after those of the generic line(s) in the
   input file.

   If we had multiple lines per emitter (e.g., we were scoring H$_{\alpha}$, 
   H$_{\beta}$, etc. all with isotope-specific wavelengths), we would 
   need an array of ``generic'' rates and lines.  In this case, would
   likely associate each generic line with an index, e.g., 
   |emission_rate_gen1|, |emission_rate_gen2|, etc.  Then, the first
   of these would be associated with the first non-zero wavelength,
   the second with the second non-zero wavelength, etc.  Again, any
   explicit, isotope independent lines, would then come after these.

   Transfer emission rate data from generic slot |i_gen_rate| to wavelength-
   specific slot |e_rates[i]| corresponding to non-zero wavelength. Note
   the density factor, as is done for the ionization rate above.  For
   the explicitly labeled lines, just need to add density factor.
*/
      if (num_lines > 0) then
         first_line=.true.
         do i=1,num_lines
            if ((i_gen_rate > 0) && first_line) then
               if ((scoring_data[lines[i]] > zero) 
     $               && (scoring_data[i_gen_rate] > zero)) then
                  assert(scoring_data[e_rates[i]] == zero)
                  assert(rc_emitter(reac) != 0)
                  scoring_data[e_rates[i]]=scoring_data[i_gen_rate]
     $                 *independent_parameters[xs_var_density]
                  first_line=.false.
               end if
            else
               if (scoring_data[lines[i]] > zero) then
                  scoring_data[e_rates[i]]*=independent_parameters[xs_var_density]
               end if
            end if
         end do
      end if
/*
   Collision scoring of coupling scores
*/
      psp_i=pr_problem_sp_back(back)
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $  -sp_m(pr_background(back))*rate
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=-eioniz

      psp_i=pr_problem_sp_test(test)
      m_i=sp_m(pr_test(test))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        -m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        -m_i*v_test[1]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        -m_i*v_test[2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        -m_i*v_test[3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        -half*m_i*vc_abs2(v_test)*rate

      do i=1,nprod
         prod[i]=pr_ts_prod(test,ts_reac,1,i)
         test_i=pr_test_lookup(prod[i])
         if (test_i != 0) then
            psp_i=pr_problem_sp_test(test_i)
         else
            back_i=pr_background_lookup(prod[i])
            assert(back_i != 0)
            psp_i=pr_problem_sp_back(back_i)
         end if
@#if !NEU_DIAG_CX
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        sp_m(prod[i])*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        sp_m(prod[i])*v_prod[i][1]*rate 
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        sp_m(prod[i])*v_prod[i][2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        sp_m(prod[i])*v_prod[i][3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        half*sp_m(prod[i])*vc_abs2(v_prod[i])*rate
@#endif
      end do
            
/*
  Verify that second product (plus an electron, the third product) corresponds
  to the test species, as should have been checked in problemsetup and is 
  assumed above.

  This check turns out to be inordinately time consuming. Comment out for
  now. This is the same check which is used in |set_prod_ionize|
  during problemsetup.
*/
@#if 0
      assert(species_add_check(2,sp_args(prod[2]),1,sp_args(pr_test(test))))
@#endif
      return
      end

@ Process an excitation or deexcitation. Arguments are the same as 
for |chargex|.

@<Functions...@>=
      subroutine excite(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_dummy(prod),vc_dummy(v_prod),w_prod,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common
      rc_common
      sp_common
      rd_common

      implicit_none_f90

      rd_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      integer nprod                                    // Output
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])
      real w_prod[rc_product_max],scoring_data[scoring_data_max]
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)
      pr_test_decl(test_i)
      rc_decl(reac)
      integer i,i_eloss,i_esrc,num_lines,i_e_rate,i_gen_rate,psp_i
      integer lines[pr_max_lines],e_rates[pr_max_lines]
      real eloss,esrc,m_i
      vc_decl(v_test)
      vc_decl(v_emitter)
      character*tl_tag_length line
      logical init,first_line

      external eval_data,species_add_check             // External
      real eval_data
      logical species_add_check
      save init,i_eloss,i_esrc,num_lines,lines,e_rates,i_gen_rate
      data init/.true./

      if (init) then
         i_eloss=string_lookup('background_energy_loss_rate',pr_var0_list,
     $        pr_var0_num)
         i_esrc=string_lookup('background_energy_source_rate',pr_var0_list,
     $        pr_var0_num)
         num_lines=0
         do i=1,pr_var0_num
            if (pr_var0_list[i]SP(1:10) == 'wavelength') then
               num_lines++
               lines[num_lines]=i
               line=pr_var0_list[i]SP(11:)
               i_e_rate=string_lookup('emission_rate'\/line,
     $              pr_var0_list,pr_var0_num)
               assert(i_e_rate > 0)
               e_rates[num_lines]=i_e_rate
            end if
         end do
         if (num_lines > 0) then
/* 
   A non-zero |i_gen_rate| will indicate that the same rate is intended to
   be used for all wavelengths present (see subroutine |ionize|).
*/
            i_gen_rate=string_lookup('emission_rate',pr_var0_list,pr_var0_num)
         end if
         init=.false.
      end if
      
      pr_reac=pr_ts_rc(test,ts_reac)   // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)
      assert(pr_num_arrangements(test,ts_reac) == 1)
/*
   Trying this approach here; may want to propagate into the other
   scoring routines: loop through the ``handling'' dependent variables.
   Grab everything which is explicitly needed for this routine to work.
   Dump everything else into |scoring_data| along with its name. This
   will allow: 
   \begin{enumerate}
     \item This code to not keep track of which emission lines (if
           any at all) are present in the data.
     \item Any data which are special to a particular reaction of this
           type to be scored simply by setting |tally_dep_var| to the
           same label. {\em This code would not require modification.}
   \end{enumerate}
*/
      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
      end do
      do i=1,nprod
         prod[i]=pr_ts_prod(test,ts_reac,1,i)
         if (sp_sy(prod[i]) != 'e') then
            vc_copy(v_test,v_prod[i])
            w_prod[i]=one
         else
            vc_set(v_prod[i],zero,zero,zero)
            w_prod[i]=zero
         end if
      end do

      reac=pr_reaction(pr_reac)
      if (rc_emitter(reac) != 0) then
         if (rc_emitter(reac) > 0) then
            vc_copy(v_prod[rc_emitter(reac)],v_emitter)
            independent_parameters[xs_var_m_emitter]=sp_m(prod[rc_emitter(reac)])
/* 
   Do noxt really recall which reagent is which. Should be able to tell
   test from a back just with |sp_generic|.
*/
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_test(test))) then
            vc_copy(v_test,v_emitter)
            independent_parameters[xs_var_m_emitter]=sp_m(pr_test(test))
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_background(back))) then
            assert('background velocity not set' == ' ')
         end if
         scoring_data[pr_var_emitter_v_vector]=v_emitter[1]
         scoring_data[pr_var_emitter_v_2]=v_emitter[2]
         scoring_data[pr_var_emitter_v_3]=v_emitter[3]
      end if

      eloss=zero
      esrc=zero
      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_eloss) then
            eloss=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_esrc) then
            esrc=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] != pr_var_unknown) then
            scoring_data[reaction_handling_var0[pr_reac][i]]
     $           =eval_data(rd_data_args(reaction_handling,
     $           [pr_reac][i]),independent_parameters,rn_args(x))
         end if
      end do
/*
   See comments in subroutine |ionize| regarding computation of the
   emission rate data for isotope dependent wavelengths..

   Transfer emission rate data from generic slot |i_gen_rate| to wavelength-
   specific slot |e_rates[i]| corresponding to non-zero wavelength. Note
   the density factor, as is done for the ionization rate above. For
   the explicitly labeled lines, just need to add density factor.
*/
      if (num_lines > 0) then
         first_line=.true.
         do i=1,num_lines
            if ((i_gen_rate > 0) && first_line) then
               if ((scoring_data[lines[i]] > zero) 
     $               && (scoring_data[i_gen_rate] > zero)) then
                  assert(scoring_data[e_rates[i]] == zero)
                  assert(rc_emitter(reac) != 0)
                  scoring_data[e_rates[i]]=scoring_data[i_gen_rate]
     $                 *independent_parameters[xs_var_density]
                  first_line=.false.
               end if
            else
               if (scoring_data[lines[i]] > zero) then
                  scoring_data[e_rates[i]]*=independent_parameters[xs_var_density]
               end if
            end if
         end do
      end if
/*
   Collision scoring of coupling scores
*/
      psp_i=pr_problem_sp_back(back)
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $  -sp_m(pr_background(back))*rate
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=(esrc-eloss)

      psp_i=pr_problem_sp_test(test)
      m_i=sp_m(pr_test(test))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        -m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        -m_i*v_test[1]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        -m_i*v_test[2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        -m_i*v_test[3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        -half*m_i*vc_abs2(v_test)*rate

      do i=1,nprod
         prod[i]=pr_ts_prod(test,ts_reac,1,i)
         test_i=pr_test_lookup(prod[i])
         if (test_i != 0) then
            psp_i=pr_problem_sp_test(test_i)
         else
            back_i=pr_background_lookup(prod[i])
            assert(back_i != 0)
            psp_i=pr_problem_sp_back(back_i)
         end if
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        sp_m(prod[i])*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        sp_m(prod[i])*v_prod[i][1]*rate 
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        sp_m(prod[i])*v_prod[i][2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        sp_m(prod[i])*v_prod[i][3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        half*sp_m(prod[i])*vc_abs2(v_prod[i])*rate
      end do
            
      return
      end

@ Process an ion conversion reaction.  These reactions are effectively
charge exchange reactions, but the model reaction rate being used is
not built on a single underlying cross section.  Consequently, we cannot
enforce the velocity dependence of the cross section as we would in a 
charge exchange reaction.  Moreover, we cannot compute the higher
moments required for processing with a track length estimator.

@<Functions...@>=
      subroutine ion_conv(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_dummy(prod),vc_dummy(v_prod),w_prod,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common                                        // Common
      rc_common
      rd_common
      sp_common
      implicit_none_f90

      rd_decls
      rn_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      integer nprod                                    // Output
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])
      real w_prod[rc_product_max],scoring_data[scoring_data_max]
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)
      pr_test_decl(test_i)
      integer i,count,psp_i
      vc_decl(v_test)
      vc_decl(v_back)
      vc_decl(vb_flow)
      vc_decl(vt_plasma_frame)
      vc_decl(vb_therm)
      vc_decl(vrel)
      vc_decl(v_i)
      real v_thermal,m_i

      external eval_data                              // External
      real eval_data

      pr_reac=pr_ts_rc(test,ts_reac)  // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)
      count=0
/*
   Transform to frame moving with the local background flow velocity
*/
      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
         vb_flow[i]=independent_parameters[xs_var_v_flow_1+i-1]
      end do
      vc_difference(v_test,vb_flow,vt_plasma_frame)

loop: continue
      count++
 /* Pick a background particle */
      v_thermal=sqrt(independent_parameters[xs_var_sp_temperature])
      call random_gauss(vb_therm,3,rn_args(x))
      do i=1,3
         vb_therm[i]*=v_thermal
      end do
/*
  Now evaluate velocity {\em relative} to this particular particle
  (we need to transform to the frame moving at |vb_flow| ahead of
  time since the average of |vb_therm| is 0.).
*/
      vc_difference(vt_plasma_frame,vb_therm,vrel)
/*
   This was previously inside the ``test'' section of the velocity
   setting code.  But, it was not getting executed for the case 
   in which there are no test products.  
*/
      vc_add(vb_therm,vb_flow,v_back)
/*
   Make use here of the assumptions regarding ordering of species that
   are made in problemsetup''s |check_problem| and in |set_prod_chargex|.
   Namely, that the first (second) reagent is a background (test) species
   and that an electron is transferred from the second to the first.
   In this way, the velocity of the first (second) product is just that
   of the background (test) reagent.
*/
      assert(pr_num_arrangements(test,ts_reac) == 1)
      assert(nprod == 2)   // Checked in |set_prod_chargex|
      do i=1,2
         prod[i]=pr_ts_prod(test,ts_reac,1,i)
         w_prod[i]=one
         if (i == 1) then
            vc_copy(v_back,v_prod[i])
         else
            vc_copy(v_test,v_prod[i])
         end if
      end do
/*
   Collision scoring 
*/
      do i=1,2
         if (i == 1) then
            m_i=sp_m(pr_background(back))
            psp_i=pr_problem_sp_back(back)
            vc_copy(v_back,v_i)
         else if (i == 2) then
            m_i=sp_m(pr_test(test))
            psp_i=pr_problem_sp_test(test)
            vc_copy(v_test,v_i)
         end if
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        -m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        -m_i*v_i[1]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        -m_i*v_i[2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        -m_i*v_i[3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        -half*m_i*vc_abs2(v_i)*rate
      end do
/*
   Because of the way neutral-neutral reactions are specified (with 
   neutral species in both background and test lists), getting test
   and background products correct in other reactions requires looking
   for test species first.
*/
      do i=1,nprod
         test_i=pr_test_lookup(prod[i])
         if (test_i != 0) then
            m_i=sp_m(pr_test(test_i))
            psp_i=pr_problem_sp_test(test_i)
         else
            back_i=pr_background_lookup(prod[i])
            assert(back_i != 0)
            m_i=sp_m(pr_background(back_i))
            psp_i=pr_problem_sp_back(back_i)
         end if
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        m_i*v_prod[i][1]*rate 
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        m_i*v_prod[i][2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        m_i*v_prod[i][3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        half*m_i*vc_abs2(v_prod[i])*rate
      end do

      return
      end

@ Set angles for elastic scattering.

@<Functions...@>=
      subroutine product_velocities(angle,independent_parameters,
     &           vc_dummy(v_test),vc_dummy(v_back),vc_dummy(vrel),
     &           vc_dummy(v_prod),rn_dummy(x))

      implicit_none_f77
      implicit_none_f90

      real angle                                        // Input
      real independent_parameters[xs_max_indep_params]
      vc_decl(v_test)
      vc_decl(v_back)
      vc_decl(vrel)

      vc_decl(v_prod[rc_product_max])                   // Output

      rn_decl(x)                                        // Input/output

      real sin_eps,cos_eps,cos_chi2,sin_chi2,           // Local
     $     m_tot,vrel_sq,vrel_diff,vrel_mag,aps_perp
      real ran,phi
      integer i

      external apse                                     // External
      real apse
      rn_decls

@#if 0
      call rand_angle(sin_eps,cos_eps,rn_args(x))
@#endif
      rn_next(ran,x)
      phi=PI*(two*ran-one)
      sin_eps=sin(phi)
      cos_eps=cos(phi)
      vrel_sq=vc_abs2(vrel)
      vrel_mag=sqrt(vrel_sq)
      cos_chi2=cos(half*angle)
      sin_chi2=sin(half*angle)
      m_tot=one/(independent_parameters[xs_var_m_test]+
     $     independent_parameters[xs_var_m_back])
      vrel_diff=sqrt(one-vrel(1)**2/vrel_sq)
      if (vrel_diff == zero) vrel_diff=const(1.,-15)

      do i=1,3
         aps_perp=apse(i,cos_chi2,vc_args(vrel),vrel_sq,vrel_mag,vrel_diff,
     $              cos_eps,sin_eps)
         v_prod(i,1)=v_back(i)+two*independent_parameters[xs_var_m_test]*
     $                 m_tot*sin_chi2*(vrel(i)*sin_chi2+vrel_mag*aps_perp)
         v_prod(i,2)=v_test(i)-two*independent_parameters[xs_var_m_back]*
     $                 m_tot*sin_chi2*(vrel(i)*sin_chi2+vrel_mag*aps_perp)
         
      end do

      return
      end

@ Determine apse vector for elastic scattering.

@<Functions...@>=
      function apse(i,cos_chi2,vc_dummy(vrel),vrel_sq,vrel_mag,vrel_diff,
     &         cos_eps,sin_eps)
      implicit_none_f77
      implicit_none_f90

      real apse                                         // Function

      integer i                                         // Input
      real cos_chi2,cos_eps,sin_eps,vrel_sq,vrel_mag,vrel_diff
      vc_decl(vrel)

      real coef_a,coef_b                                // Local

      if (i == 1) then
         apse=cos_chi2*vrel_diff*cos_eps
      elseif (i == 2) then
         coef_a=vrel(2)*vrel(1)*cos_eps + vrel(3)*vrel_mag*sin_eps
         coef_b=vrel_sq*vrel_diff
         apse=-cos_chi2*coef_a/coef_b
      else
         coef_a=vrel(3)*vrel(1)*cos_eps - vrel(2)*vrel_mag*sin_eps
         coef_b=vrel_sq*vrel_diff
         apse=-cos_chi2*coef_a/coef_b
      endif

      return
      end

@#if 0
Function to determine random angle  - Removed for simplicity
(probably a little faster to do it the simpler way as well).

<Functions...@>=
      subroutine rand_angle(sin_eps,cos_eps,rn_dummy(x))
      implicit_none_f77
      implicit_none_f90

      rn_decl(x)

      real eps,eps_sq,eta,eta_sq,eps_eta
      real sign,sin_eps,cos_eps
      rn_decls

loop: continue
      rn_next(eps,x)
      rn_next(eta,x)
      eps_sq=eps*eps
      eta_sq=eta*eta
      eps_eta=eps_sq+eta_sq
      if ( eps_eta > one ) goto loop

      cos_eps=(eps_sq-eta_sq)/eps_eta
      sin_eps=two*eps*eta/eps_eta
      rn_next(sign,x)
      if ( sign < half ) sin_eps = -sin_eps

      return
      end
@#endif

@ Pick a reaction to score by track length estimator.

@<Functions...@>=
      subroutine pick_track_reaction(pr_test_dummy(test),
     $     pr_reaction_dummy(ts_reac),rate,independent_parameters,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      rc_common                                         // Common
      pr_common

      implicit_none_f90

      pr_test_decl(test)                                // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      real scoring_data[scoring_data_max]               // Output
      rn_decl(x)                                        // Input/output

      pr_reaction_decl(pr_reac)                         // Local  

      pr_reac=pr_ts_rc(test,ts_reac)  // Index to problem-reaction list

      if (rc_reaction_type(pr_reaction(pr_reac)) == 'chargex') then
         call track_chargex(pr_test_args(test),
     $        pr_reaction_args(ts_reac),rate,independent_parameters,
     $        scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'elastic') then
         call track_elastic(pr_test_args(test),
     $        pr_reaction_args(ts_reac),rate,independent_parameters,
     $        scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'dissoc') then
         call track_dissoc(pr_test_args(test),
     $        pr_reaction_args(ts_reac),rate,independent_parameters,
     $        scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'dissoc_rec') then
         call track_dissoc(pr_test_args(test),
     $        pr_reaction_args(ts_reac),rate,independent_parameters,
     $        scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac))=='dissoc_cramd') then
         call track_dissoc_cramd(pr_test_args(test),
     $        pr_reaction_args(ts_reac),rate,independent_parameters,
     $        scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'ionize') then
         call track_ionize(pr_test_args(test),
     $        pr_reaction_args(ts_reac),rate,independent_parameters,
     $        scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'ionize_suppress') then
         call track_ionize(pr_test_args(test),
     $        pr_reaction_args(ts_reac),rate,independent_parameters,
     $        scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'excitation') then
         call track_excite(pr_test_args(test),
     $        pr_reaction_args(ts_reac),rate,independent_parameters,
     $        scoring_data,rn_args(x))
      else if (rc_reaction_type(pr_reaction(pr_reac)) == 'deexcitation') then
         call track_excite(pr_test_args(test),
     $        pr_reaction_args(ts_reac),rate,independent_parameters,
     $        scoring_data,rn_args(x))
      else
         assert('Unsupported reaction type' == ' ')
      end if

      return
      end

@ Compute scoring data for charge exchange track-length estimator.

@<Functions...@>=
      subroutine track_chargex(pr_test_dummy(test),
     $     pr_reaction_dummy(ts_reac),rate,independent_parameters,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      rc_common                                         // Common
      rd_common
      pr_common
      sp_common

      implicit_none_f90

      rd_decls
      st_decls
      pr_test_decl(test)                                // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      real scoring_data[scoring_data_max]               // Output
      rn_decl(x)                                        // Input/output

      pr_reaction_decl(pr_reac)                         // Local  
      pr_background_decl(back)
      integer i,j,i_0_1,i_0_2,nprod,back_i,test_i,psp_i
      real ni_1up,ni_2up2,up2,up,u_abs,uprime_abs,m_i,e_src,e_eff,
     $     i_term,i_term_org,i_term_lim
      vc_decl(u)
      vc_decl(uprime)
      vc_decl(vb_flow)
      vc_decl(mom_src)
      vc_decl(vr_i)
      logical init

      external eval_data                                // External
      real eval_data
      save init,i_0_1,i_0_2
      data init/.true./

      if (init) then
         i_0_1=string_lookup('I_0_1*up',pr_var0_list,pr_var0_num)
         i_0_2=string_lookup('I_0_2*up^2',pr_var0_list,pr_var0_num)
         assert(i_0_1 > 0 && i_0_2 > 0)
         init=.false.
      end if

      pr_reac=pr_ts_rc(test,ts_reac)  // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)
      ni_1up=real_uninit
      ni_2up2=real_uninit
      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_0_1) then
            ni_1up=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_0_2) then
            ni_2up2=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         end if
      end do
      assert(ni_1up != real_uninit && ni_2up2 != real_uninit)

      do i=1,3
         u[i]=independent_parameters[xs_var_v_test_1+i-1]
         vb_flow[i]=independent_parameters[xs_var_v_flow_1+i-1]
      end do

      up2=two*independent_parameters[xs_var_sp_temperature]
      up=sqrt(up2)
      u_abs=vc_abs(u)
      vc_difference(u,vb_flow,uprime)
      uprime_abs=vc_abs(uprime)
/*
   The combination in |i_term_org| appears in the expressions for both
   the momentum and energy exchanges below.  At small values of |u| (or
   |uprime|), the |ni_1up| is supposed to scale inversely with |u| and
   the two terms of |i_term_org| largely cancel.
   However, |u| can be arbitarily small here.  In particular, it can be
   smaller than the smallest value provided for in the data table.  In that
   case, the $1/|u|$ scaling will not arise and the expected cancellation 
   will not occur.  Moreover, apart from a small range of |u| just below the
   table limit, |i_term_org| will be evaluated (incorrectly) as negative.
   When this occurs, we replace it with the expected result in the
   $|u| \ll |up|$ limit, |i_term_lim|.  The assertion that ensures this
   limit is valid should not be hit as long the lowest energies in the
   table are well below the smallest expected ion temperatures, i.e., 
   about 1 eV.
*/
      i_term_org=ni_1up/uprime_abs-half*up2*rate/uprime_abs**2
      i_term_lim=two*ni_2up2/(const(3.)*up2)
      if (i_term_org < zero) then
         i_term=i_term_lim
         assert(uprime_abs < half*up)
      else
         i_term=i_term_org
      end if

      do i=1,2
         if (i == 1) then
            m_i=sp_m(pr_background(back))
            psp_i=pr_problem_sp_back(back)
            do j=1,3
@#if 0
               mom_src[j]=rate*u[j]
     $              -(-half*up2*rate/uprime_abs**2+ni_1up/uprime_abs)*uprime[j]
@#else
               mom_src[j]=rate*u[j]-i_term*uprime[j]
@#endif
            end do
            vc_copy(mom_src,vr_i)
@#if 0
            e_src=half*u_abs**2*rate-vc_product(u,uprime)*ni_1up/uprime_abs
     $           +half*(up2*vc_product(u,uprime)*rate/uprime_abs**2+ni_2up2)
@#else
            e_src=half*u_abs**2*rate-vc_product(u,uprime)*i_term+half*ni_2up2
@#endif
            e_eff=e_src
         else if (i == 2) then
            m_i=sp_m(pr_test(test))
            psp_i=pr_problem_sp_test(test)
            vc_scale(rate,u,vr_i)
            e_eff=half*u_abs**2*rate
         end if
@#if NEU_DIAG_CX
         if (i == 2) then
@#endif
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        -m_i*rate
@#if NEU_DIAG_CX
         endif
@#endif
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        -m_i*vr_i[1]
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        -m_i*vr_i[2]
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        -m_i*vr_i[3]
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        -m_i*e_eff
      end do
/*
   Make use here of the assumptions regarding ordering of species that
   are made in problemsetup's |check_problem| and in |set_prod_chargex|.
   Namely, that the first (second) reagent is a background (test) species
   and that an electron is transferred from the second to the first.
   In this way, the velocity of the first (second) product is just that
   of the background (test) reagent.
*/
      assert(nprod == 2)   // Checked in |set_prod_chargex|
      do i=1,2
         if (i == 1) then
            vc_copy(mom_src,vr_i)
            e_eff=e_src
         else
            vc_scale(rate,u,vr_i)
            e_eff=half*u_abs**2*rate
         end if
         test_i=pr_test_lookup(pr_ts_prod(test,ts_reac,1,i))
         if (test_i != 0) then
            m_i=sp_m(pr_test(test_i))
            psp_i=pr_problem_sp_test(test_i)
         else
            back_i=pr_background_lookup(pr_ts_prod(test,ts_reac,1,i))
            assert(back_i != 0)
            m_i=sp_m(pr_background(back_i))
            psp_i=pr_problem_sp_back(back_i)
         end if
         scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        m_i*vr_i[1]
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        m_i*vr_i[2]
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        m_i*vr_i[3]
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        m_i*e_eff
      end do

      return
      end

@ Compute scoring data for elastic scattering track-length estimator.

@<Functions...@>=
      subroutine track_elastic(pr_test_dummy(test),
     $     pr_reaction_dummy(ts_reac),rate,independent_parameters,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      rc_common                                         // Common
      rd_common
      pr_common
      sp_common

      implicit_none_f90

      rd_decls
      st_decls

      pr_test_decl(test)                                // Input         
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      real scoring_data[scoring_data_max]               // Output
      rn_decl(x)                                        // Input/output

      pr_reaction_decl(pr_reac)                         // Local
      pr_background_decl(back)
      integer i,i_1_0,i_1_1,i_1_2,psp_i
      real ni_0,ni_1up,ni_2up2,up2,up,m_test,m_back,mom_src,
     $     uprime_abs,usq,e_src
      vc_decl(u)
      vc_decl(uprime)
      vc_decl(vb_flow)
      logical init

      external eval_data                                // External
      real eval_data
      save init,i_1_0,i_1_1,i_1_2
      data init/.true./
      
      if (init) then
         i_1_0=string_lookup('I_1_0',pr_var0_list,pr_var0_num)
         i_1_1=string_lookup('I_1_1*up',pr_var0_list,pr_var0_num)
         i_1_2=string_lookup('I_1_2*up^2',pr_var0_list,pr_var0_num)
         assert(i_1_0 > 0 && i_1_1 > 0 && i_1_2 > 0)
         init=.false.
      end if

      pr_reac=pr_ts_rc(test,ts_reac)  // Index to problem-reaction list
      back=pr_ts_bk(test,ts_reac)

      ni_0=real_uninit
      ni_1up=real_uninit
      ni_2up2=real_uninit
      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_1_0) then
            ni_0=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_1_1) then
            ni_1up=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_1_2) then
            ni_2up2=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         end if
      end do
      assert(ni_0 != real_uninit && ni_1up != real_uninit 
     $     && ni_2up2 != real_uninit)

      do i=1,3
         u[i]=independent_parameters[xs_var_v_test_1+i-1]
         vb_flow[i]=independent_parameters[xs_var_v_flow_1+i-1]
      end do

      up2=two*independent_parameters[xs_var_sp_temperature]
      up=sqrt(up2)
      usq=vc_product(u,u)
      vc_difference(u,vb_flow,uprime)
      uprime_abs=vc_abs(uprime)
      m_test=independent_parameters[xs_var_m_test]
      m_back=independent_parameters[xs_var_m_back]

      psp_i=pr_problem_sp_back(back)
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=zero // NO CHANGE in species
      mom_src=(m_test*m_back/(m_test+m_back))*(-half*up2*ni_0/uprime_abs**2
     $     +ni_1up/uprime_abs)
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $     mom_src*uprime[1]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $     mom_src*uprime[2]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $     mom_src*uprime[3]
      e_src=(two*m_test*m_back/(m_test+m_back)**2)*(-half*m_back*ni_2up2
     $     +half*(m_test+m_back)*vc_product(u,uprime)
     $     *(ni_1up/uprime_abs-half*up2*ni_0/uprime_abs**2))
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $     e_src

      psp_i=pr_problem_sp_test(test)
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=zero 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $     -mom_src*uprime[1]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $     -mom_src*uprime[2]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $     -mom_src*uprime[3]
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $     -e_src

      // No product terms!

      return
      end

@ Compute scoring data for dissociation track-length estimator.

@<Functions...@>=
      subroutine track_dissoc(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common                                        // Common
      rc_common
      sp_common
      rd_common

      implicit_none_f90

      rd_decls
      rn_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[*]

      real scoring_data[scoring_data_max]              // Output
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)
      pr_test_decl(test_i)
      rc_decl(reac)
      sp_decl(prod[rc_product_max])
      integer i,i_ediss,i_elediss,nprod,num_heavy_products,j_arr,k,psp_i,
     $        num_lines,i_e_rate,i_gen_rate,i_line
      integer product_index[2],lines[pr_max_lines],e_rates[pr_max_lines]
      vc_decl(v_test)
      vc_decl(v_emitter)
      real ediss,elediss,mass_total,m_i,this_line
      real mass[2]
      logical init,first_line
      character*tl_tag_length line

      external eval_data                               // External
      real eval_data
      save init,i_ediss,i_elediss,num_lines,lines,e_rates,i_gen_rate
      data init/.true./

      if (init) then
         i_ediss=string_lookup('dissociation_energy',pr_var0_list,pr_var0_num)
         i_elediss=string_lookup('background_energy_loss_rate',
     $        pr_var0_list,pr_var0_num)
         assert(i_ediss > 0 && i_elediss > 0)
         num_lines=0
         do i=1,pr_var0_num
            if (pr_var0_list[i]SP(1:10) == 'wavelength') then
               num_lines++
               lines[num_lines]=i
               line=pr_var0_list[i]SP(11:)
               i_e_rate=string_lookup('emission_rate'\/line,
     $              pr_var0_list,pr_var0_num)
               assert(i_e_rate > 0)
               e_rates[num_lines]=i_e_rate
            end if
         end do
         if (num_lines > 0) then
/* 
   A non-zero |i_gen_rate| will indicate that the same rate is intended to
   be used for all wavelengths present (see subroutine |ionize|).
*/
            i_gen_rate=string_lookup('emission_rate',pr_var0_list,pr_var0_num)
         end if
         init=.false.
      end if
      
      pr_reac=pr_ts_rc(test,ts_reac)   // Index to problem-reaction list
      back=pr_ts_bk(test,ts_reac)
      nprod=rc_product_num(pr_reaction(pr_reac))
/*
   Search through the list of miscellaneous dependent
   variables to find |ediss|, the dissociation energy, and |elediss|, the
   energy lost by the dissociating agent. 
*/
      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_ediss) then
            ediss=eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_elediss) then
            elediss=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] != pr_var_unknown) then
            scoring_data[reaction_handling_var0[pr_reac][i]]
     $           =eval_data(rd_data_args(reaction_handling,
     $           [pr_reac][i]),independent_parameters,rn_args(x))
         end if
      end do
      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
      end do
/*
   Set emitter velocity. This is done just for completeness. Not likely to be a good
   approximation (since test energy usually much smaller than dissociation energy).
   This just assumes that the two product velocities are equal to the test velocity,
   which they are on the average. There is a corresponding assert below (with setting
   of emitter mass) that verifies that |rc_emitter| points to one of the heavy products.
*/
      reac=pr_reaction(pr_reac)
      if (rc_emitter(reac) != 0) then
         if (rc_emitter(reac) > 0) then
            vc_copy(v_test,v_emitter)
/* Don't really recall which reagent is which. Should be able to tell
   test from a back just with |sp_generic|.
*/
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_test(test))) then
            vc_copy(v_test,v_emitter)
         else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $           == sp_generic(pr_background(back))) then
            assert('background velocity not set' == ' ')
         end if
         scoring_data[pr_var_emitter_v_vector]=v_emitter[1]
         scoring_data[pr_var_emitter_v_2]=v_emitter[2]
         scoring_data[pr_var_emitter_v_3]=v_emitter[3]
      end if
/*
   TLE scoring:
   This may work for MASS ONLY. The product momentum and energy expressions 
   are provisional; they assume that the isotropic component of the 
   dissociated velocities has been averaged out. Note: this may not work at 
   all for a time-dependent case.
*/
      psp_i=pr_problem_sp_back(back)
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $  -sp_m(pr_background(back))*rate
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=-elediss

      psp_i=pr_problem_sp_test(test)
      m_i=sp_m(pr_test(test))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $        -m_i*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $        -m_i*v_test[1]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $        -m_i*v_test[2]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $        -m_i*v_test[3]*rate
         scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $        -half*m_i*vc_abs2(v_test)*rate

      do j_arr=1,pr_num_arrangements(test,ts_reac)
         num_heavy_products=0
         mass_total=zero
         do i=1,nprod
            prod[i]=pr_ts_prod(test,ts_reac,j_arr,i)
            test_i=pr_test_lookup(prod[i])
            if (test_i != 0) then
               psp_i=pr_problem_sp_test(test_i)
            else
               back_i=pr_background_lookup(prod[i])
               assert(back_i != 0)
               psp_i=pr_problem_sp_back(back_i)
            end if
            scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_i)]+=
     $              sp_m(prod[i])*rate*pr_prod_mult(test,ts_reac,j_arr)
            if (sp_sy(prod[i]) != 'e') then
               num_heavy_products++
               mass[num_heavy_products]=sp_m(prod[i])
               mass_total+=sp_m(prod[i])
               product_index[num_heavy_products]=i
            end if
         end do
         assert(num_heavy_products == 2)
/*
   Need to set emitter mass so wavelength can be evaluated.
*/
         if (rc_emitter(reac) != 0) then
            if (rc_emitter(reac) > 0) then
               independent_parameters[xs_var_m_emitter]=sp_m(prod[rc_emitter(reac)])
               assert(sp_sy(prod[rc_emitter(reac)]) != 'e')
/* Don't really recall which reagent is which. Should be able to tell
   test from a back just with |sp_generic|.
*/
            else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $                  == sp_generic(pr_test(test))) then
               independent_parameters[xs_var_m_emitter]=sp_m(pr_test(test))
            else if (sp_generic(rc_reagent(reac,-rc_emitter(reac))) 
     $              == sp_generic(pr_background(back))) then
               assert('background velocity not set' == ' ')
            end if
         end if
/*
   Transfer emission rate data from generic slot |i_gen_rate| to wavelength-
   specific slot |e_rates[i]| corresponding to non-zero wavelength. Note
   the density factor, as is done for the ionization rate above. These lines
   differ from those in subroutine |dissoc| in that the line-specific elements
   of |scoring_data| are incremented rather than set since there may be multiple
   contributions from the various arrangements. 

   See also comments from subroutine |ionize| regarding generic and
   explicit lines.  
*/
         if (num_lines > 0) then
            first_line=.true.
            do i_line=1,num_lines
               do i=1,rd_dep_var_max
                  if (reaction_handling_var0[pr_reac][i] == lines[i_line]) then
                     this_line=eval_data(rd_data_args(reaction_handling,
     $                    [pr_reac][i]),independent_parameters,rn_args(x))
                     if (this_line > zero) then
                        assert(rc_emitter(reac) != 0)
                        if ((i_gen_rate > 0) && first_line) then
                           scoring_data[e_rates[i_line]]+=scoring_data[i_gen_rate]
     $                          *independent_parameters[xs_var_density]
     $                          *pr_prod_mult(test,ts_reac,j_arr)
                           first_line=.false.
                        else
                           if (scoring_data[lines[i_line]] > zero) then
                              scoring_data[e_rates[i_line]]*=(independent_parameters[xs_var_density]
     $                             *pr_prod_mult(test,ts_reac,j_arr))
                           end if
                        end if
                     end if
                  end if
               end do
            end do
         end if

         do k=1,num_heavy_products
            test_i=pr_test_lookup(pr_ts_prod(test,ts_reac,j_arr,product_index[k]))
            if (test_i != 0) then
               psp_i=pr_problem_sp_test(test_i)
            else
               back_i=pr_background_lookup(pr_ts_prod(test,ts_reac,j_arr,product_index[k]))
               assert(back_i != 0)
               psp_i=pr_problem_sp_back(back_i)
            end if
            scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_i)]+=
     $           mass[k]*v_test[1]*rate*pr_prod_mult(test,ts_reac,j_arr)
            scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_i)]+=
     $           mass[k]*v_test[2]*rate*pr_prod_mult(test,ts_reac,j_arr)
            scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_i)]+=
     $           mass[k]*v_test[3]*rate*pr_prod_mult(test,ts_reac,j_arr)
            scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_i)]+=
     $           (half*mass[k]*vc_abs2(v_test)+two*ediss*(one-mass[k]/mass_total))
     $           *rate*pr_prod_mult(test,ts_reac,j_arr)
         end do
      end do

      return
      end

@ Comput scoring data for CRAMD dissociation track-length estimator.

@<Functions...@>=
      subroutine track_dissoc_cramd(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      pr_common                                        // Common
      rc_common
      sp_common
      rd_common

      implicit_none_f90

      rd_decls
      rn_decls
      st_decls
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[*]

      real scoring_data[scoring_data_max]              // Output
      rn_decl(x)                                       // Input/output

      pr_reaction_decl(pr_reac)                        // Local
      pr_background_decl(back)
      pr_background_decl(back_i)
      sp_decl(prod[rc_product_max])
      integer i,i_eloss,i_iloss,i_hfrac,num_heavy_products,j_arr,k,nprod
      integer product_index[2]
      vc_decl(v_test)
      real eloss,iloss,hfrac,ediss,mass_total
      real mass[2]
      logical init

      external eval_data                               // External
      real eval_data
      save init,i_eloss,i_iloss,i_hfrac
      data init/.true./

      if (init) then
         i_eloss=string_lookup('background_energy_loss_rate',pr_var0_list,
     $        pr_var0_num)
         i_iloss=string_lookup('proton_energy_loss_rate',pr_var0_list,
     $        pr_var0_num)
         i_hfrac=string_lookup('H_fraction',pr_var0_list,pr_var0_num)
         assert(i_eloss > 0 && i_iloss > 0 && i_hfrac > 0) 
         init=.false.
      end if
      
      pr_reac=pr_ts_rc(test,ts_reac)   // Index to problem-reaction list
      nprod=rc_product_num(pr_reaction(pr_reac))
      back=pr_ts_bk(test,ts_reac)

/*
   Search through the list of miscellaneous dependent
   variables to find |ediss|, the dissociation energy, and |elediss|, the
   energy lost by the dissociating agent. 
*/
      do i=1,rd_dep_var_max
         if (reaction_handling_var0[pr_reac][i] == i_eloss) then
            eloss=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_iloss) then  // See comment in |dissoc_cramd|
            iloss=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         else if (reaction_handling_var0[pr_reac][i] == i_hfrac) then
            hfrac=eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(x))
         end if
      end do

/* 
   For the time being, the actual dissocation energy is hardwired at 3 eV.
   Doing better will require significant improvements to CRAMD.
*/
      ediss=const(3.)*electron_charge    

/*
   TLE Scoring:
  We cannot pretend to be able to do mixed isotope dissociations anymore. 
  We would need a more complete species breakdown of the particle and 
  energy transfer rates. The same caveats apply to the momentum and
  energy exchanges as in |track_dissoc|. NOT UPDATED TO DO TEST SCORING!!
  Commented out as a result.
*/
      assert(sp_ncomp(pr_test(test)) == 1)
      assert(sp_count(pr_test(test),1) == 2)

@#if 0
      assert(sp_sy(pr_background(back)) == 'e')
      scoring_data[pr_var_back_index(pr_var_mass_change,back)]+=
     $     -sp_m(pr_background(back))*rate
      scoring_data[pr_var_back_index(pr_var_energy_change,back)]+=-eloss
      do i=1,3
         v_test[i]=independent_parameters[xs_var_v_test_1+i-1]
      end do
      do j_arr=1,pr_num_arrangements(test,ts_reac)
         num_heavy_products=0
         mass_total=zero
         do i=1,nprod
            back_i=pr_background_lookup(pr_ts_prod(test,ts_reac,j_arr,i))
            if (back_i != 0) then
               if (sp_sy(prod[i]) == 'e') then
                  scoring_data[pr_var_back_index(pr_var_mass_change,back_i)]+=
     $                 sp_m(pr_background(back_i))
     $                 *rate*(const(3.)-two*hfrac)*pr_prod_mult(test,ts_reac,j_arr)
               else
                  scoring_data[pr_var_back_index(pr_var_mass_change,back_i)]+=
     $                 sp_m(pr_background(back_i))
     $                 *rate*two*(one-hfrac)*pr_prod_mult(test,ts_reac,j_arr)
               end if
            end if
            prod[i]=pr_ts_prod(test,ts_reac,j_arr,i)
            if (sp_sy(prod[i])  != 'e') then
               num_heavy_products++
               mass[num_heavy_products]=sp_m(prod[i])
               mass_total+=sp_m(prod[i])
               product_index[num_heavy_products]=i
            end if
         end do
         assert(num_heavy_products == 2)
         do k=1,num_heavy_products
            back_i=pr_background_lookup(product_index[k])
            if (back_i != 0) then
               scoring_data[pr_var_back_index(pr_var_momentum_change_vector,back_i)]+=
     $              mass[k]*v_test[1]*rate*two*(one-hfrac)
     $              *pr_prod_mult(test,ts_reac,j_arr)
               scoring_data[pr_var_back_index(pr_var_momentum_change_2,back_i)]+=
     $              mass[k]*v_test[2]*rate*two*(one-hfrac)
     $              *pr_prod_mult(test,ts_reac,j_arr)
               scoring_data[pr_var_back_index(pr_var_momentum_change_3,back_i)]+=
     $              mass[k]*v_test[3]*rate*two*(one-hfrac)
     $              *pr_prod_mult(test,ts_reac,j_arr)
               scoring_data[pr_var_back_index(pr_var_energy_change,back_i)]+=
     $              (half*mass[k]*vc_abs2(v_test)
     $              +two*ediss*(one-mass[k]/mass_total))
     $              *rate*two*(one-hfrac)*pr_prod_mult(test,ts_reac,j_arr)
     $              -iloss
            end if
         end do
      end do
@#endif

      return
      end

@ Compute scoring data for ionization track-length estimator.

@<Functions...@>=
      subroutine track_ionize(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      implicit_none_f90
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      real scoring_data[scoring_data_max]              // Output
      rn_decl(x)                                       // Input/output

      integer nprod                                    // Local (dummies)
      real w_prod[rc_product_max]
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])

/*
   The code we need here looks so much like the corresponding reaction
   processing routine that we might as well just call it.
*/
      call ionize(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))

      return
      end

@ Compute scoring data for excitation and deexcitation track-length estimator.

@<Functions...@>=
      subroutine track_excite(pr_test_dummy(test),pr_reaction_dummy(ts_reac),
     $     rate,independent_parameters,
     $     scoring_data,rn_dummy(x))

      implicit_none_f77
      implicit_none_f90
      pr_test_decl(test)                               // Input
      pr_reaction_decl(ts_reac)
      real rate
      real independent_parameters[xs_max_indep_params]

      real scoring_data[scoring_data_max]              // Output
      rn_decl(x)                                       // Input/output

      integer nprod                                    // Local (dummies)
      real w_prod[rc_product_max]
      sp_decl(prod[rc_product_max])
      vc_decl(v_prod[rc_product_max])

/*
   The code we need here looks so much like the corresponding reaction
   processing routine that we might as well just call it.
*/
      call excite(pr_test_args(test),pr_reaction_args(ts_reac),
     $     rate,independent_parameters,
     $     nprod,sp_args(prod),vc_args(v_prod[1]),w_prod,
     $     scoring_data,rn_args(x))

      return
      end

@ Set scoring data for recombinations. Recombination scoring is
actually done at the source point or as a post-processor.

@<Functions...@>=
      subroutine recombination_data(est,fl_dummy(x),scoring_data)

      implicit_none_f77
      pr_common                             // Common
      bk_common
      gi_common
      rc_common
      sp_common
      rd_common
      zn_common
      implicit_none_f90

      rd_decls
      lc_decls
      st_decls

      integer est                           // Input
      fl_decl(x)

      real scoring_data[scoring_data_max]   // Output

      pr_background_decl(back_2)            // Local
      pr_background_decl(back_1)
      pr_reaction_decl(bk_rc_is)
      pr_reaction_decl(pr_reac)
      sp_decl(sptest)
      rc_decl(reac)
      lc_decl(zone_loc)
      vc_decl(vb_flow)
      vc_decl(v_src)
      integer i,i_e_loss,i_e_src,num_lines,i_e_rate,i_gen_rate,psp_1,psp_2,xseg
      integer lines[pr_max_lines],e_rates[pr_max_lines]
      real rate,e_loss,e_e_loss,e_e_src
      real independent_parameters[xs_max_indep_params]
      character*tl_tag_length line
      logical init,first_line

      external eval_data,find_rate          // External
      real eval_data,find_rate
      save init,i_e_loss,i_e_src,num_lines,lines,e_rates,i_gen_rate
      data init/.true./

      @<Memory allocation interface@>
      rn_decls

      if (init) then
         i_e_loss=string_lookup('background_energy_loss_rate',pr_var0_list,
     $        pr_var0_num)
         i_e_src=string_lookup('background_energy_source_rate',pr_var0_list,
     $        pr_var0_num)
         num_lines=0
         do i=1,pr_var0_num
            if (pr_var0_list[i]SP(1:10) == 'wavelength') then
               num_lines++
               lines[num_lines]=i
               line=pr_var0_list[i]SP(11:)
               i_e_rate=string_lookup('emission_rate'\/line,
     $              pr_var0_list,pr_var0_num)
               assert(i_e_rate > 0)
               e_rates[num_lines]=i_e_rate
            end if
         end do
         if (num_lines > 0) then
/* 
   A non-zero |i_gen_rate| will indicate that the same rate is intended to
   be used for all wavelengths present (see subroutine |ionize|).
*/
            i_gen_rate=string_lookup('emission_rate',pr_var0_list,pr_var0_num)
         end if
         init=.false.
      end if

      sptest=pt_sp(fl_current(x))
      bk_rc_is=0
      do i=1,pr_bkrc_num
         if (pr_bkrc_prod(i,1) == sptest) then
            assert(bk_rc_is == 0)
            assert(pr_background_lookup(fl_source_root_sp(x)) == pr_bkrc_rg(i,2))
            bk_rc_is=i
         end if
      end do
      assert(bk_rc_is != 0)
/*
   By convention, the second reagent is the one which will give
   rise to the velocity of the product test particle. The first
   background reagent is taken to be a pure background particle and
   enters here through the data in |independent_parameters|.
*/
      back_1=pr_bkrc_rg(bk_rc_is,1)
      back_2=pr_bkrc_rg(bk_rc_is,2)
      pr_reac=pr_bk_rc(bk_rc_is)
      reac=pr_reaction(pr_reac)
      rate=find_rate(pt_args(fl_current(x)),pr_background_args(back_1),
     $     pr_reaction_args(pr_bk_rc(bk_rc_is)),rn_args(x))
      assert(rate > zero)
      call set_indep_params(pt_args(fl_current(x)),pr_background_args(back_1),
     $     reaction_rate_num_rand[pr_reac],
     $     rn_args(fl_rand(x)),independent_parameters)

/*
   Set data for line emission. For post-processing, compute spectrum
   based on locally Maxwellian distributed ions. If scoring is 
   instead done at the source, take the actual sourced test particle
   velocity. Set the background momentum and energy sinks in an
   analogous way.
*/
      xseg=fl_source_xseg(x)
      if (rc_emitter(reac) != 0) then
         assert(rc_emitter(reac) == 1)
         independent_parameters[xs_var_m_emitter]=sp_m(sptest)
         if (est == tl_est_post_process) then
            assert(xseg == int(independent_parameters[xs_var_zone]))
            vc_copy(zone_center[xseg],lc_x(zone_loc))
            lc_set(zone_loc)
            v_ext_to_int(lc_x(zone_loc),bk_v(back_2,lc_zone(zone_loc)),vb_flow,geometry_symmetry,background_coords)
            scoring_data[pr_var_emitter_vf_Maxwell_vector]=vb_flow[1]
            scoring_data[pr_var_emitter_vf_Maxwell_2]=vb_flow[2]
            scoring_data[pr_var_emitter_vf_Maxwell_3]=vb_flow[3]
            scoring_data[pr_var_emitter_vth_Maxwell]=
     $           sqrt(bk_temp(back_2,lc_zone(zone_loc))
     $           /sp_m(pr_background(back_2)))
            vc_copy(vb_flow,v_src)
            e_loss=const(1.5)*bk_temp(back_2,lc_zone(zone_loc))
     $           +half*sp_m(pr_background(back_2))*vc_abs2(vb_flow)
         else if (est == tl_est_collision) then
            do i=1,3
               v_src[i]=independent_parameters[xs_var_v_test_1+i-1]
            end do
            scoring_data[pr_var_emitter_v_vector]=v_src[1]
            scoring_data[pr_var_emitter_v_2]=v_src[2]
            scoring_data[pr_var_emitter_v_3]=v_src[3]
            e_loss=half*sp_m(pr_background(back_2))*vc_abs2(v_src)
         end if
      end if

      e_e_loss=zero
      e_e_src=zero
      do i=1,rd_dep_var_max

/* 
   Grab background energy loss and source rates (radiation and ``ionization''
   energy).
*/
         if (reaction_handling_var0[pr_reac][i] 
     $        == i_e_loss) then
            e_e_loss=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(fl_rand(x)))
         else if (reaction_handling_var0[pr_reac][i] 
     $           == i_e_src) then
            e_e_src=independent_parameters[xs_var_density]
     $           *eval_data(rd_data_args(reaction_handling,[pr_reac][i]),
     $           independent_parameters,rn_args(fl_rand(x)))

/* 
   Evaluate everything else nontrivial
*/
         else if (reaction_handling_var0[pr_reac][i] != pr_var_unknown) then
            scoring_data[reaction_handling_var0[pr_reac][i]]
     $           =eval_data(rd_data_args(reaction_handling,
     $           [pr_reac][i]),independent_parameters,rn_args(fl_rand(x)))
         end if
      end do

/*
   Transfer emission rate data from generic slot |i_gen_rate| to wavelength-
   specific slot |e_rates[i]| corresponding to non-zero wavelength.

   See comment in subroutine |ionize| regarding generic and explicit
   wavelengths.
*/
      if (num_lines > 0) then
         first_line=.true.
         do i=1,num_lines
            if ((i_gen_rate > 0) && first_line) then
               if ((scoring_data[lines[i]] > zero) 
     $               && (scoring_data[i_gen_rate] > zero)) then
                  assert(scoring_data[e_rates[i]] == zero)
                  assert(rc_emitter(reac) != 0)
/*
   Remove rate factor here. Future data should do this directly in
   the data file.
*/
                  scoring_data[e_rates[i]]=scoring_data[i_gen_rate]
     $                    *independent_parameters[xs_var_density]/rate
                  first_line=.false.
               end if
            else
               if (scoring_data[lines[i]] > zero) then
                  scoring_data[e_rates[i]]*=independent_parameters[xs_var_density]/rate
               end if
            end if
         end do
      end if

/*
   Collision scoring of coupling scores
*/
      psp_1=pr_problem_sp_back(back_1)
      psp_2=pr_problem_sp_back(back_2)
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_1)]+=
     $  -sp_m(pr_background(back_1))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_2)]+=
     $     -sp_m(pr_background(back_2))
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_2)]+=
     $     -sp_m(pr_background(back_2))*v_src[1] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_2)]+=
     $     -sp_m(pr_background(back_2))*v_src[2] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_2)]+=
     $     -sp_m(pr_background(back_2))*v_src[3] 
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_1)]+=
     $     (e_e_src-e_e_loss)/rate
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_2)]+=
     $     -e_loss

      psp_2=pr_problem_sp_test(pt_test(fl_current(x)))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_2)]+=
     $  sp_m(sptest)
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_2)]+=
     $     sp_m(sptest)*v_src[1] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_2)]+=
     $     sp_m(sptest)*v_src[2] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_2)]+=
     $     sp_m(sptest)*v_src[3] 
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_2)]+=
     $     e_loss    // Assuming all goes from back to test.
      
      return
      end

@* INDEX.
