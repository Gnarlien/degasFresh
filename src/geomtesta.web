% $Id: a60fc832e6a2767743541a672e12bdc65c902844 $
\Title{geomtesta}


@* A program for generating a basic set of output suitable for use with
external graphics packages.  This started out as a geometry test
routine, hence the name.  The code reads the primary output
netCDF file as well as the other inputs.  These data are mapped
on to a pixel based mesh, either 2-D or 3-D, that can be easily
processed by most graphics packages (e.g., VisIt or IDL).  The size, location,
and orientation of the pixel based mesh is specified in the input
file |geometry.inp| (the name is hard coded) and is extremely flexible.
For example, the axes of the pixel mesh need not be orthogonal to one
another. 

The original format of the files generated by this routine 
was HDF (more specifically, HDF Version 4).  With this format,
each variable is output
to a separate, appropriately named file. The Silo format is now
available as an alternative.
The lower level implementation of the Silo files is in turn
provided by either PDB or HDF5 drivers,
depending on how the Silo library was compiled.  The 
format to be used is specified by the
|GRAPH_FILE| variable in the |Makefile| or |Makefile.local|
as either |HDF4|, |SILO|, or |SILO_HDF5|.
The Silo
format naturally handles multiple variables in a single file; that
file is just the name of the main output netCDF file with \verb+.silo+ replacing
\verb+.nc+.  The variables that are output are hardcoded below, although
some control is provided by FWEB macros to enable or disable 
particular variables.

The format of the input file is fixed, although comments (with |#|)
are allowed.  
\begin{enumerate} 
  \item The first line contains $(x,y,z)$ coordinates of the
origin of the pixel mesh.  This need not be inside the bounds of the
problem space.  
  \item The second line contains the $(x,y,z)$  
vector  for the first axis of the basic 2-D slice; this need
not be a unit vector.  
If desired, the number of $x$-$y$  pixels can be specified at
the end of this line.  If absent, the default value of 40,000 is used.
  \item The third line has the $(x,y,z)$ unit vector for the second axis.
  \item In the 2-D mode of operation, the fourth line contains just two
real numbers corresponding to lengths of the two vectors given
in the two previous lines.
If, however, the code finds three reals on this line, it will assume the
user wants a stack of 2-D slices in a 3-D file and that this
line contains the $(x,y,z)$ vector for the third axis.  The $z$ 
resolution can be controlled by the specification of a 
fourth {\em real} number on this line, |z_scale|. 
  \item In the 3-D mode of operation, the fifth line contains
three real numbers corresponding to the lengths of the three vectors
given on the previous lines.
\end{enumerate} 
The mesh spacing in the $x$ and $y$
directions is equal (square pixels), determined by dividing the area
of the slice by the total number of pixels. 
For the $z$ direction, this spacing is multiplied by the
|z_scale| factor.  If absent, |z_scale| defaults to 2.0.
Some example input files can be found in the set of example
runs provided with the DEGAS 2 distribution.

External zone based data can also be read in via text files and
will be output in the same manner as the other variables.  The
names of the text files can follow the above data in the |geometry.inp|
file.  Each text file can have keywords ``name'', ``format'' (as
in a Fortran output specification; not used in SILO mode), ``units'' to provide
additional information on the data.  If provided, the name will be
used to name the file and variable.  If not, the name will be
|ext_var_n| where |n| is the number of the file in the list of
external files.  All other lines in the file should be in the
form:
\begin{verbatim}
zone    data
\end{verbatim}
where {\tt zone} is an integer between 1 and |zn_num| (inclusive) and
{\tt data} is the (real) data value.  One way to generate such files
within DEGAS 2 would be to use |outputbrowser| to write out
zone based data (e.g., for a tally unique to the problem at hand)
to a file and then edit the file to these specifications.

Here is an explicit example:
\begin{verbatim}
name neu_ob
units m^-3
        1     8.57659E+14 
        2     6.70615E+14 
        3     7.16331E+14 
        4     6.29992E+14 
        5     5.83773E+14 
\end{verbatim}

This technique can also be used for time dependent data.  If one 
were looping through a sequence of time intervals, data from each
step could be stored in text files of this format.  In SILO mode, 
time dependent data should be stored in separate SILO files, one
per time step.  The convention used here is to append to
the variable ``name'' an integer designation for the time step
preceded by a \$ sign, e.g., \verb+density_$00100+ for the density
at time step 100.  The code will interpret the presence of
the \$ sign as indicating time dependent data and use the 
following integer in naming the SILO file.  In HDF4 mode, all
variables are already in separate files, and the \$ is just
stripped out and used as the file name.  I.e., in this case
the \$ sign is not actually needed.

By the definition of the mesh, mesh point $(i, j, k)$ corresponds to
the physical point $x$ according to:
\begin{equation}
\vec{x} = \vec{x}_{0} + (i + \frac{1}{2}) \Delta_{1} \hat{v}_{1}
 + (j + \frac{1}{2}) \Delta_{2} \hat{v}_{2}
 + (k + \frac{1}{2}) \Delta_{3} \hat{v}_{3},
\end{equation}
where $\vec{x}_{0}$ are the coordinates of the origin, $\hat{v}_{1}$
is the unit vector describing the first axis, $\Delta_{1}$ is the 
mesh spacing along that axis, and so on for the other two axes.

The mesh coordinate axes $(x_{1}, x_{2}, x_{3})$
are computed via:
\begin{equation}
x_{1}(i) = \vec{x}_{0} \cdot \hat{v}_{1} + (i + \frac{1}{2}) \Delta_{1},
\end{equation}
\begin{equation}
x_{2}(j) = \vec{x}_{0} \cdot \hat{v}_{2} + (j + \frac{1}{2}) \Delta_{2},
\end{equation}
and
\begin{equation}
x_{3}(k) = \vec{x}_{0} \cdot \hat{v}_{3} + (k + \frac{1}{2}) \Delta_{3}.
\end{equation}

Eliminating the mesh indices between these two sets of equations provides
the mapping between the mesh and physical coordinates:
\begin{equation}
\vec{x} = \vec{x}_{0} + (x_{1} - \vec{x}_{0} \cdot \hat{v}_{1}) \hat{v}_{1}
+ (x_{2} - \vec{x}_{0} \cdot \hat{v}_{2}) \hat{v}_{2}
+ (x_{3} - \vec{x}_{0} \cdot \hat{v}_{3}) \hat{v}_{3}.
\end{equation}

For the common case in which the three unit vectors specifying
the mesh axes are orthogonal
to each other, 
this mapping simplifies to the obvious form:
\begin{equation}
\vec{x} = x_{1} \hat{v}_{1} + x_{2} \hat{v}_{2} + x_{3} \hat{v}_{3}.
\end{equation}

\ID{$Id: a60fc832e6a2767743541a672e12bdc65c902844 $}

@m FILE 'geomtesta.web'
@I macros.hweb
@I string.hweb
@I geomint.hweb
@I zone.hweb
@I background.hweb
@I problem.hweb
@I species.hweb
@I detector.hweb
@I tally.hweb
@I output.hweb
@I netcdf.hweb
@I sysdep.hweb
@I readfilenames.hweb
@I reaction.hweb
@I materials.hweb
@I random.hweb

@ The main program.

@a
      program geometry_test
      implicit_none_f77
      implicit_none_f90

      call readfilenames
      call degas_init
      call nc_read_output

      call exercise

      stop
      end

      @<Functions and Subroutines@>

@ Exercise the locate function

/*
   Remove characters causing file name problems
*/
@m name_clean(s,sp) sp=s;  
      ind_tmp=index(sp,'(');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='_';
      ind_tmp=index(sp,')');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='_';
      ind_tmp=index(sp,'|');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='_';
      ind_tmp=index(sp,'+');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='p' @;

@<Functions...@>=
      subroutine exercise

      define_dimen(a_ind,0,na-1)
      define_dimen(b_ind,0,nb-1)
      define_dimen(c_ind,0,nc-1)
      define_dimen(pixel_ind,0,na*nb*nc-1)
      define_dimen(ext_file_ind,n_ext_file)

      define_varp(xa,FLOAT,a_ind)
      define_varp(xb,FLOAT,b_ind)
      define_varp(xc,FLOAT,c_ind)
      define_varp(pixel_zones,INT,pixel_ind)
      define_varp(pixel_data,FLOAT,pixel_ind)
      define_varp(zone_data,FLOAT,zone_ind)
      define_varp(ext_filenames,CHAR,filenames_size,ext_file_ind)

      implicit_none_f77
      sp_common
      pr_common
      tl_common
      ou_common
      bk_common
      zn_common
      de_common
      rf_common
      implicit_none_f90
      real x[3],a[3],b[3],c[3],xp[3],vz[3],               // Local
     $     alen,blen,clen,ha_rate,halpha_tot,ha_temp,
     $     density,pressure,max_v,clenp,dx,dz,z_scale,
     $     main_z_scale,zone_frag
      integer i,j,k,zone,test,back,iview,length,p,beg,e,ind_tmp,
     $        na,nb,nc,pixsize,main_pixsize,ifile,n_ext_file,
     $        open_stat,inum,ifrag
      integer index_parameters[tl_index_max]
      external extract_output_datum
      real extract_output_datum
      character*4 ivlab
      character*1 ind_sy[3]
      character*3 iflab
      character*3 vtag,auth
      character*tl_tag_length vname
      character*sp_sy_len clean_sy
      character*LINELEN line,ext_var_name,ext_var_units,ext_var_format
      data ind_sy /'1','2','3'/

      declare_varp(xa)
      declare_varp(xb)
      declare_varp(xc)
      declare_varp(pixel_zones)
      declare_varp(pixel_data)
      declare_varp(zone_data)
      declare_varp(ext_filenames)
      
      @<Memory allocation interface@>
      st_decls
      tl_decls
      vc_decls
      zn_decls
@#if SILO
      include 'silo.inc'
      integer dbfile,dbfile_td,ret,itxt
      logical write_mesh,dbfile_td_open
      character*FILELEN mesh_name,silo_file,ext_silo_file
      common /silo_common/ dbfile,dbfile_td,write_mesh,mesh_name
      e=index(filenames_array[outputfile],'.nc')
      assert(e > 0)
      silo_file=filenames_array[outputfile]SP(:e)\/'silo'
      ret=dbcreate(trim(silo_file),string_length(silo_file),
     $     DB_CLOBBER,DB_LOCAL,DB_F77NULL,0,silo_format,dbfile)
      assert((ret != -1) && (dbfile != -1))
      dbfile_td_open=.false.
@#endif      
      open(unit=diskin,file='geometry.inp',status='old',form='formatted')
/*
   Switched these from free format reads to tokens.  To maintain backward
   compatibility, have made the switch without adding keywords.  As a
   consequence, the format becomes inflexible.  The expected contents of
   the file are now:

   First line contains $(x,y,z)$ coordinates of an origin.
*/
      assert(read_string(diskin,line,length))
      assert(length<=len(line))
      length=parse_string(line(:length))
      p=0
      assert(next_token(line,beg,e,p))
      x[1]=read_real(line(beg:e))
      assert(next_token(line,beg,e,p))
      x[2]=read_real(line(beg:e))
      assert(next_token(line,beg,e,p))
      x[3]=read_real(line(beg:e))
/*
   Second line contains the $(x,y,z)$ unit vector for the first
   axis of the basic 2-D slice.  If desired, the number of $x$-$y$
   pixels can be specified after the $x$ unit vector.  If absent,
   the default value of 40,000 is used.
*/
      assert(read_string(diskin,line,length))
      assert(length<=len(line))
      length=parse_string(line(:length))
      p=0
      assert(next_token(line,beg,e,p))
      a[1]=read_real(line(beg:e))
      assert(next_token(line,beg,e,p))
      a[2]=read_real(line(beg:e))
      assert(next_token(line,beg,e,p))
      a[3]=read_real(line(beg:e))
      if (next_token(line,beg,e,p)) then
         main_pixsize=read_integer(line(beg:e))
         assert(main_pixsize > 0)
      else
         main_pixsize=40000
      end if
/*
   The third line has the $(x,y,z)$ unit vector for the second axis.
*/
      assert(read_string(diskin,line,length))
      assert(length<=len(line))
      length=parse_string(line(:length))
      p=0
      assert(next_token(line,beg,e,p))
      b[1]=read_real(line(beg:e))
      assert(next_token(line,beg,e,p))
      b[2]=read_real(line(beg:e))
      assert(next_token(line,beg,e,p))
      b[3]=read_real(line(beg:e))
/*
   In the 2-D mode of operation, the fourth line contains just two
   real numbers corresponding to lengths of the two vectors given
   in the two previous lines.
*/
      assert(read_string(diskin,line,length))
      assert(length<=len(line))
      length=parse_string(line(:length))
      p=0
      assert(next_token(line,beg,e,p))
      alen=read_real(line(beg:e))
      assert(next_token(line,beg,e,p))
      blen=read_real(line(beg:e))
      clen=zero
/*
   If, however, the code finds three reals on this line, it will assume the
   user wants a stack of 2-D slices in a 3-D file.  As above, the $z$ 
   resolution can be controlled, if desired by the specification of a 
   fourth real number on this line.  The mesh spacing in the $x$ and $y$
   directions is equal; we multiply that by this |z_scale| factor to get
   the spacing in the $z$ direction.  If absent, it defaults to 2.0.

   Whether or not |z_scale| is present, the fourth line contains the 
   unit vector for the third direction.  
*/
      main_z_scale=two
      if (next_token(line,beg,e,p)) then
         c[1]=alen
         c[2]=blen
         c[3]=read_real(line(beg:e))
         if (next_token(line,beg,e,p)) then
            main_z_scale=read_real(line(beg:e))
            assert(main_z_scale > zero)
         end if
/*
   The fifth line has the length of the three vectors in the 3-D case.
*/
         assert(read_string(diskin,line,length))
         assert(length<=len(line))
         length=parse_string(line(:length))
         p=0
         assert(next_token(line,beg,e,p))
         alen=read_real(line(beg:e))
         assert(next_token(line,beg,e,p))
         blen=read_real(line(beg:e))
         assert(next_token(line,beg,e,p))
         clen=read_real(line(beg:e))
      end if
/*
   Check the end of the file for additional (external) zone based
   data in text files.
*/
      n_ext_file=0
      var_alloc(ext_filenames)
loop: continue
      if (read_string(diskin,line,length)) then
         assert(length<=len(line))
         length=parse_string(line(:length))
         p=0
         assert(next_token(line,beg,e,p))
         n_ext_file++
         var_realloca(ext_filenames)
         ext_filenames[n_ext_file]=line(beg:e)
         go to loop
      end if
      close(unit=diskin)
      var_reallocb(ext_filenames)

      var_alloc(zone_data)
/*
   High resolution 2-D plot(s)
*/
      pixsize=6400000
      clenp=zero
      z_scale=zero   // Not used
      call get_pixel_mesh(alen,blen,clenp,pixsize,z_scale,
     $     na,nb,nc,dx,dz)
      
      var_alloc(xa)
      var_alloc(xb)
      var_alloc(xc)
      var_alloc(pixel_zones)
      var_alloc(pixel_data)
/* 
   Plot the slice midway along the third direction.
*/
      if (clen > zero) then
         vc_unit(c,vz)
         vc_xvt(x,vz,half*clen,xp)
      else
         vc_copy(x,xp)
      end if
      call set_pixel_zones(xp,a,b,c,na,nb,nc,dx,dz,xa,xb,xc,pixel_zones)
@#if SILO
      write_mesh=.true.
      mesh_name='HighRes2d'
@#endif
/*
   This is just Charles'' original ``zone function''.  I believe the
   purpose was to use (most of) an 8-bit palette to color the
   zones with a minimum chance of color matching between adjacent
   zones (i.e., suspect that $97 / 252$ is related to the golden
   mean).
*/
      do i=1,zn_num
         zone_data[i]=areal(3+mod(97*i,255-3))
      end do
      call write_hdf('geomtesta.hdf',zone_data,
     $     'zone function',' ','E11.3',
     $     na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

      var_free(xa)
      var_free(xb)
      var_free(xc)
      var_free(pixel_zones)
      var_free(pixel_data)
/*
   Low resolution, 2- or 3-D plots (as specified on input)
*/
      pixsize=main_pixsize
      z_scale=main_z_scale
      call get_pixel_mesh(alen,blen,clen,pixsize,z_scale,
     $     na,nb,nc,dx,dz)

      var_alloc(xa)
      var_alloc(xb)
      var_alloc(xc)
      var_alloc(pixel_zones)
      var_alloc(pixel_data)

      call set_pixel_zones(x,a,b,c,na,nb,nc,dx,dz,xa,xb,xc,pixel_zones)
@#if SILO
      write_mesh=.true.
      mesh_name='LowRes2d'
@#endif
      do i=1,zn_num
         zone_data[i]=areal(i)
      end do
      call write_hdf('zones.hdf',zone_data,'zone number',' ','E11.3',
     $     na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

      do i=1,zn_num
         zone_data[i]=zn_volume(i)
      end do
      call write_hdf('volume.hdf',zone_data,'zone_volume','m**3','E11.3',
     $     na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

      do i=1,zn_num
         zone_data[i]=areal(zn_type(i))
      end do
      call write_hdf('zone_type.hdf',zone_data,'zone type',' ','E11.3',
     $     na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

@#if 1
      do i=1,zn_num
         if (zn_type(i) == zn_plasma) then
            zone_data[i]=bk_n(1,i)                  // BACKGROUND DENSITY
         else
            zone_data[i]=zero
         end if
      end do
      call write_hdf('bk_n1.hdf',zone_data,'electron density','m**-3','E11.3',
     $     na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

      do i=1,zn_num
         if (zn_type(i) == zn_plasma) then
            zone_data[i]=bk_n(2,i)                  // BACKGROUND DENSITY
         else
            zone_data[i]=zero
         end if
      end do
      call write_hdf('bk_n2.hdf',zone_data,'ion density','m**-3','E11.3',
     $     na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

      do i=1,zn_num
         if (zn_type(i) == zn_plasma) then         // BACKGROUND TEMPERATURE
            zone_data[i]=bk_temp(1,i)/electron_charge
         else
            zone_data[i]=zero
         end if
      end do
      call write_hdf('bk_t1.hdf',zone_data,'electron temperature','eV','E11.3',
     $     na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

      do i=1,zn_num
         if (zn_type(i) == zn_plasma) then         // BACKGROUND TEMPERATURE
            zone_data[i]=bk_temp(2,i)/electron_charge
         else
            zone_data[i]=zero
         end if
      end do
      call write_hdf('bk_t2.hdf',zone_data,'ion temperature','eV','E11.3',
     $     na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

      do j=1,3
         max_v=zero
         do i=1,zn_num
            if (zn_type(i) == zn_plasma) then         // ION VELOCITY
               zone_data[i]=bk_v(2,i)[j]
               max_v=max(max_v,abs(zone_data[i]))
            else
               zone_data[i]=zero
            end if
         end do
         if (max_v > zero) then
            call write_hdf('bk_v'\/ind_sy[j]\/'.hdf',zone_data,
     $           'ion velocity '\/ind_sy[j],'m/s','E11.3',
     $           na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         end if
      end do
@#endif
@#if 0                      // Plots of |de_zone_frags|
      do j=1,4
         if (j==1) then
            iview=1
            ivlab='1'
         else if (j==2) then
            iview=4
            ivlab='4'
         else if (j==3) then
            iview=6
            ivlab='6'
         else
            iview=9
            ivlab='9'
         end if
         do i=1,zn_num
            if (zn_type(i) == zn_plasma || zn_type(i) == zn_vacuum
     $           && ((i >= de_zone_frags_min_zn[iview])
     $           && (i <= de_zone_frags_max_zn[iview]))) then
               assert(de_zone_frags_num[iview] > 0)
               zone_frag=zero
               do inum=1,de_zone_frags_num[iview]
                  ifrag=de_zone_frags_start[iview] + (inum-1)
                  if (i == de_zone_frags_zones[ifrag]) then
                     zone_frag=de_zone_frags[ifrag]
                     go to break
                  end if
               end do
break:        continue  
              zone_data[i]=zone_frag
            else
               zone_data[i]=zero
            end if
         end do
         call write_hdf('zn_frag_'\/trim(ivlab)\/'.hdf',zone_data,
     $        'zone frag view '\/trim(ivlab),' ','E11.3',na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      end do
@#endif
@#if 1
      assert(output_old_file == TRUE)
      do j=2,pr_test_num
         index_parameters[tl_index_test]=j
         ha_temp=zero
         do i=1,zn_num
            if (zn_type(i) == zn_plasma || zn_type(i) == zn_vacuum) then
               index_parameters[tl_index_zone]=i
               density=extract_output_datum(index_parameters,1,
     $              out_post_all,o_mean,'neutral density')
               zone_data[i]=density           // NEUTRAL DENSITY
               ha_temp+=density*zn_volume(i)
            else
               zone_data[i]=zero
            end if
         end do
         name_clean(sp_sy(pr_test(j)),clean_sy)
         call write_hdf('sp'\/trim(clean_sy)\/'den.hdf',zone_data,
     $        'sp'\/trim(clean_sy)\/' density','m**-3','E11.3',
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

         do i=1,zn_num
            if (zn_type(i) == zn_plasma || zn_type(i) == zn_vacuum) then
               index_parameters[tl_index_zone]=i
               density=extract_output_datum(index_parameters,1,
     $              output_all,o_var,'neutral density')
               zone_data[i]=density           // NEUTRAL DENSITY REL. STD. DEV.
            else
               zone_data[i]=zero
            end if
         end do

         call write_hdf('sp'\/trim(clean_sy)\/'den_rsd.hdf',zone_data,
     $        'sp'\/trim(clean_sy)\/' density rsd',' ','E11.3',
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

         if (tl_check(string_lookup('neutral velocity vector',tally_name,tl_num))) then
            vname='neutral velocity vector'
            vtag='vel'
         else 
            assert(tl_check(string_lookup('neutral flux vector',tally_name,tl_num)))
            vname='neutral flux vector'
            vtag='flx'
         end if
         do i=1,3                                     // Component
            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma || zn_type(zone) == zn_vacuum) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,i,
     $                 out_post_all,o_mean,trim(vname))
                  zone_data[zone]=ha_rate
               else
                  zone_data[zone]=zero
               end if
            end do
            call write_hdf(
     $           'sp'\/trim(clean_sy)\/vtag\/ind_sy[i]\/'.hdf',
     $           zone_data,trim(clean_sy)\/vtag\/ind_sy[i],
     $           'm/s','E11.3',na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         end do

         if (string_lookup('neutral pressure',tally_name,tl_num) > 0) then
            do i=1,zn_num
               if (zn_type(i) == zn_plasma || zn_type(i) == zn_vacuum) then
                  index_parameters[tl_index_zone]=i
                  pressure=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,'neutral pressure')
                  zone_data[i]=pressure/const(1.3332,-1)  // NEUTRAL PRESSURE
               else
                  zone_data[i]=zero
               end if
            end do
            call write_hdf('sp'\/trim(clean_sy)\/'prs.hdf',zone_data,
     $           'sp'\/trim(clean_sy)\/' pressure','mTorr','E11.3',
     $           na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         end if

      end do
@#endif
@#if 0
/*
   This is provisional. Could just test for the presence of the tally
   and leave this in here permanently.
*/
      j=2                                // Usually the atom species
      index_parameters[tl_index_test]=j
      do k=1,so_type_num+pr_reaction_num+pr_pmi_num
         index_parameters[tl_index_test_author]=k
         ha_temp=zero
         do i=1,zn_num
            if (zn_type(i) == zn_plasma || zn_type(i) == zn_vacuum) then
               index_parameters[tl_index_zone]=i
               density=extract_output_datum(index_parameters,1,
     $              out_post_all,o_mean,'neutral density by author')
               zone_data[i]=density               // NEUTRAL DENSITY BY AUTHOR
               ha_temp+=density*zn_volume(i)
            else
               zone_data[i]=zero
            end if
         end do
         if (ha_temp > zero) then
            write(auth,'(a1,i2.2)') 'a',k
            call write_hdf(
     $           'sp'\/trim(sp_sy(pr_test(j)))\/'den_'\/auth\/'.hdf',zone_data,
     $           'sp'\/trim(sp_sy(pr_test(j)))\/' density '\/auth,'m**-3',
     $           'E11.3',na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         end if
      end do

@#endif
@#if 1
      @<Neutral H-alpha@>
@#endif
@#if 1
      @<Neutral Lyman-alpha@>
@#endif
@#if 1
      @<Neutral Balmer-beta@>
@#endif
@#if 1
      do i=1,zn_num
         zone_data[i]=zero
      end do

      do test=1,pr_test_num
         if (((sp_sy(pr_test(test)) == 'He')          // NEUTRAL He 5877 line
     $        && string_lookup('He 5877 emission rate',tally_name,tl_num) > 0)) then
            ha_temp=zero
            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'He 5877 emission rate')
     $                 /(const(2.109566)*electron_charge)
                  zone_data[zone]+=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
@#if 0
               else if (zn_type(zone) == zn_solid) then  // Can plot solid
                  zone_data[zone]=-one                    // regions 
@#endif
               else
                  zone_data[zone]=zero
               end if
            end do
         end if
      end do

      halpha_tot=zero
      do zone=1,zn_num
         halpha_tot+=zone_data[zone]*zn_volume(zone)
      end do

      if (halpha_tot > zero) then
         call write_hdf('he_5877.hdf',zone_data,
     $        'He_5877_rate','photons / (m**3 s)','E11.3',
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      end if
@#endif
@#if 1

      if ((pr_reaction_num > 0) 
     $     && (string_lookup('ion source rate',tally_name,tl_num) > 0)) then
         do back=1,pr_background_num
            name_clean(sp_sy(pr_background(back)),clean_sy)
            if (trim(clean_sy) != 'e') then     // ION SOURCE RATE
               index_parameters[tl_index_problem_sp]=pr_problem_sp_back(back)
               ha_temp=zero
               do zone=1,zn_num
                  if (zn_type(zone) == zn_plasma) then
                     index_parameters[tl_index_zone]=zone
                     ha_rate=extract_output_datum(index_parameters,1,
     $                    out_post_all,o_mean,'ion source rate')
                     zone_data[zone]=ha_rate/zn_volume(zone)
                     ha_temp+=ha_rate
                  else
                     zone_data[zone]=zero
                  end if
               end do
               call write_hdf(trim(clean_sy)\/'ionizeV.hdf',
     $              zone_data,trim(clean_sy)\/'_Ion_Source_rate',
     $              'm**-3 s**-1','E11.3',
     $              na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

               do zone=1,zn_num
                  if (zn_type(zone) == zn_plasma) then
                     index_parameters[tl_index_zone]=zone
                     ha_rate=extract_output_datum(index_parameters,1,
     $                    output_all,o_var,'ion source rate')
                     zone_data[zone]=ha_rate
                  else
                     zone_data[zone]=zero
                  end if
               end do
               call write_hdf(trim(clean_sy)\/'ionize_rsd.hdf',
     $              zone_data,trim(clean_sy)\/'_Ion Source rate rsd',
     $              ' ','E11.3',na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

            end if
         end do

         do back=1,pr_background_num
            name_clean(sp_sy(pr_background(back)),clean_sy)
            if (trim(clean_sy) != 'e') then     // MOM. SOURCE RATE
               index_parameters[tl_index_problem_sp]=pr_problem_sp_back(back)
               do i=1,3                                     // Component
                  ha_temp=zero
                  do zone=1,zn_num
                     if (zn_type(zone) == zn_plasma) then
                        index_parameters[tl_index_zone]=zone
                        ha_rate=extract_output_datum(index_parameters,i,
     $                       out_post_all,o_mean,'ion momentum source vector')
                        zone_data[zone]=ha_rate
                        ha_temp+=ha_rate
                     else
                        zone_data[zone]=zero
                     end if
                  end do
                  call write_hdf(
     $                 trim(clean_sy)\/'mom'\/ind_sy[i]\/'.hdf',
     $                 zone_data,
     $                 trim(clean_sy)\/'_Mom '\/ind_sy[i]\/'_Source_rate',
     $                 'N','E11.3',
     $                 na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
               end do

               do i=1,3                                     // Component
                  do zone=1,zn_num
                     if (zn_type(zone) == zn_plasma) then
                        index_parameters[tl_index_zone]=zone
                        ha_rate=extract_output_datum(index_parameters,i,
     $                       output_all,o_var,'ion momentum source vector')
                        zone_data[zone]=ha_rate
                     else
                        zone_data[zone]=zero
                     end if
                  end do
                  call write_hdf(
     $                 trim(clean_sy)\/'mom'\/ind_sy[i]\/'_rsd.hdf',
     $                 zone_data,
     $                 trim(clean_sy)\/'_Mom '\/ind_sy[i]\/'_Source_rate_rsd',
     $                 'N','E11.3',
     $                 na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
               end do
            end if
         end do

         do back=1,pr_background_num                  // ENERGY SOURCE RATE
            name_clean(sp_sy(pr_background(back)),clean_sy)
            index_parameters[tl_index_problem_sp]=pr_problem_sp_back(back)
            ha_temp=zero
            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,'ion energy source')
                  zone_data[zone]=ha_rate
                  ha_temp+=ha_rate
               else
                  zone_data[zone]=zero
               end if
            end do
            call write_hdf(trim(clean_sy)\/'energy.hdf',
     $           zone_data,trim(clean_sy)\/'_Energy_Source_rate',
     $           'W','E11.3',
     $           na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 output_all,o_var,'ion energy source')
                  zone_data[zone]=ha_rate
               else
                  zone_data[zone]=zero
               end if
            end do
            call write_hdf(trim(clean_sy)\/'energy_rsd.hdf',
     $           zone_data,trim(clean_sy)\/'_Energy_Source_rate_rsd',
     $           'W','E11.3',
     $           na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         end do

      end if
/*
  Read in and plot external zone-based data.
*/
      if (n_ext_file > 0) then
         do ifile=1,n_ext_file
            do zone=1,zn_num
               zone_data[zone]=zero
            end do
            open(unit=diskin,file=ext_filenames[ifile],
     $           status='old',form='formatted',iostat=open_stat)
            if (open_stat == 0) then
               assert(ifile < 1000)
               write(iflab,'(i3.3)') ifile
               ext_var_name='ext_var'\/iflab
               ext_var_units=' '
               ext_var_format='E11.3'
loop2: continue
               if (read_string(diskin,line,length)) then
                  assert(length<=len(line))
                  length=parse_string(line(:length))
                  p=0
                  assert(next_token(line,beg,e,p))
                  if (line(beg:e) == 'name') then
                     assert(next_token(line,beg,e,p))
                     ext_var_name=line(beg:e)
                  else if (line(beg:e) == 'units') then
                     assert(next_token(line,beg,e,p))
                     ext_var_units=line(beg:e)
                  else if (line(beg:e) == 'format') then
                     assert(next_token(line,beg,e,p))
                     ext_var_format=line(beg:e)
                  else
                     zone=read_int_soft_fail(line(beg:e))
                     if (zn_check(zone)) then
                        assert(next_token(line,beg,e,p))
                        zone_data[zone]=read_real(line(beg:e))
                     else
                        write(stderr,*) 'Improper zone number ',zone,
     $                       ' in external file ',ext_filenames[n_ext_file]
                     end if
                  end if
                  go to loop2
               end if
               close(unit=diskin)
               i=index(ext_var_name,'$')
@#if SILO
               if (i > 0) then
                  if (dbfile_td_open) then
                     ret=dbclose(dbfile_td)
                     dbfile_td_open=.false.   // Not sure if I need this
                     assert(ret != -1)
                  end if
                  itxt=index(ext_filenames[ifile],'.txt')
                  ext_silo_file=ext_filenames[ifile]SP(:itxt)\/'silo'
                  ret=dbcreate(trim(ext_silo_file),string_length(ext_silo_file),
     $                 DB_CLOBBER,DB_LOCAL,DB_F77NULL,0,silo_format,dbfile_td)
                  assert((ret != -1) && (dbfile_td != -1))
                  dbfile_td_open=.true.
                  write_mesh=.true.
                  mesh_name='LowRes2d'
               end if
@#else
               if (i > 0) then
                  ext_var_name=ext_var_name(:i-1)\/ext_var_name(i+1:)
               end if
@#endif
               call write_hdf(trim(ext_var_name)\/'.hdf',zone_data,
     $              trim(ext_var_name),trim(ext_var_units),
     $              trim(ext_var_format),
     $              na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
            else
               write (stderr,*) 'Cannot open external file ',
     $              ext_filenames[n_ext_file],', error number ',open_stat
            end if
         end do
      end if
/*
   Plot EIRENE data if the appropriate files are present.  Since we've
   only worked with 2-D EIRENE files (in benchmark exercises), skip if 
   the current pixel mesh is 3-D.
*/
      if (clen == zero) then
         call plot_eirene_data(zone_data,na,nb,nc,xa,xb,xc,
     $        pixel_zones,pixel_data)
      end if

@#endif
      var_free(xa)
      var_free(xb)
      var_free(xc)
      var_free(pixel_zones)
      var_free(pixel_data)
      var_free(zone_data)
      var_free(ext_filenames)
@#if SILO
      ret=dbclose(dbfile)
      assert(ret != -1)
      if (dbfile_td_open) then
         ret=dbclose(dbfile_td)
         assert(ret != -1)
      end if
@#endif
      return
      end

@ Neutral H-alpha data.  |FWEAVE| began complaining about ``too many      
texts'' (as had happened previously in |definegeometry2d.web|).  To
that end, have split out some of the emission line plots into 
separate sections, especially since more of these may be added.

@<Neutral H-alpha@>=      
      do i=1,zn_num
         zone_data[i]=zero
      end do

      do test=1,pr_test_num
         if (((sp_sy(pr_test(test)) == 'H')                  // NEUTRAL H-ALPHA
     $        || (sp_sy(pr_test(test)) == 'D')
     $        || (sp_sy(pr_test(test)) == 'T'))
     $        && string_lookup(trim(sp_sy(pr_test(test)))\/'alpha emission rate',tally_name,tl_num) > 0) then
            ha_temp=zero
            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 trim(sp_sy(pr_test(test)))\/'alpha emission rate')
     $                 /(const(1.8881944)*electron_charge)
                  zone_data[zone]+=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
@#if 0
               else if (zn_type(zone) == zn_solid) then  // Can plot solid
                  zone_data[zone]=-one                    // regions 
@#endif
               else
                  zone_data[zone]=zero
               end if
            end do
         end if
      end do

      halpha_tot=zero
      do zone=1,zn_num
         halpha_tot+=zone_data[zone]*zn_volume(zone)
      end do

      if (halpha_tot > zero) then
         call write_hdf('halpha.hdf',zone_data,
     $        'H_alpha_rate','photons / (m**3 s)','E11.3',
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      end if

      do i=1,zn_num
         zone_data[i]=zero
      end do

      do test=1,pr_test_num
         if (string_lookup('Dalpha emission rate by species',tally_name,tl_num) > 0) then
            name_clean(sp_sy(pr_test(test)),clean_sy)
            ha_temp=zero
            index_parameters[tl_index_test]=test
            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'Dalpha emission rate by species')
     $                 /(const(1.8881944)*electron_charge)
                  zone_data[zone]=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
               else
                  zone_data[zone]=zero
               end if
            end do
         end if
         halpha_tot=zero
         do zone=1,zn_num
            halpha_tot+=zone_data[zone]*zn_volume(zone)
         end do

         if (halpha_tot > zero) then
            call write_hdf('halpha'\/trim(clean_sy)\/'.hdf',zone_data,
     $        'H_alpha_rate_'\/trim(clean_sy),'photons / (m**3 s)','E11.3',
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         end if
      end do

@ Neutral H Lyman-alpha data.  See comments for ``Neutral H-alpha'' section.

@<Neutral Lyman-alpha@>=
      do i=1,zn_num
         zone_data[i]=zero
      end do

      do test=1,pr_test_num
         if (((sp_sy(pr_test(test)) == 'H')                  // NEUTRAL H LYMAN-ALPHA
     $        || (sp_sy(pr_test(test)) == 'D')
     $        || (sp_sy(pr_test(test)) == 'T'))
     $        && string_lookup('Lyman-alpha emission rate',tally_name,tl_num) > 0) then
            ha_temp=zero
            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'Lyman-alpha emission rate')
     $                 /(const(10.196)*electron_charge)
                  zone_data[zone]+=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
@#if 0
               else if (zn_type(zone) == zn_solid) then  // Can plot solid
                  zone_data[zone]=-one                    // regions 
@#endif
               else
                  zone_data[zone]=zero
               end if
            end do
         end if
      end do

      halpha_tot=zero
      do zone=1,zn_num
         halpha_tot+=zone_data[zone]*zn_volume(zone)
      end do

      if (halpha_tot > zero) then
         call write_hdf('lyman_alpha.hdf',zone_data,
     $        'Lyman_alpha_rate','photons / (m**3 s)','E11.3',
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      end if

      do i=1,zn_num
         zone_data[i]=zero
      end do

      do test=1,pr_test_num
         if (string_lookup('Lyman-alpha emission rate by species',tally_name,tl_num) > 0) then
            name_clean(sp_sy(pr_test(test)),clean_sy)
            ha_temp=zero
            index_parameters[tl_index_test]=test
            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'Lyman-alpha emission rate by species')
     $                 /(const(10.196)*electron_charge)
                  zone_data[zone]=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
               else
                  zone_data[zone]=zero
               end if
            end do
         end if
         halpha_tot=zero
         do zone=1,zn_num
            halpha_tot+=zone_data[zone]*zn_volume(zone)
         end do

         if (halpha_tot > zero) then
            call write_hdf('lyman_alpha'\/trim(clean_sy)\/'.hdf',zone_data,
     $        'Lyman_alpha_rate_'\/trim(clean_sy),'photons / (m**3 s)','E11.3',
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         end if
      end do

@ Neutral H Balmer-beta data.  See comments for ``Neutral H-alpha'' section.

@<Neutral Balmer-beta@>=
      do i=1,zn_num
         zone_data[i]=zero
      end do

      do test=1,pr_test_num
         if (((sp_sy(pr_test(test)) == 'H')                  // NEUTRAL H BALMER BETA
     $        || (sp_sy(pr_test(test)) == 'D')
     $        || (sp_sy(pr_test(test)) == 'T'))
     $        && string_lookup('D beta emission rate',tally_name,tl_num) > 0) then
            ha_temp=zero
            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'D beta emission rate')
     $                 /(const(2.549)*electron_charge)
                  zone_data[zone]+=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
@#if 0
               else if (zn_type(zone) == zn_solid) then  // Can plot solid
                  zone_data[zone]=-one                    // regions 
@#endif
               else
                  zone_data[zone]=zero
               end if
            end do
         end if
      end do

      halpha_tot=zero
      do zone=1,zn_num
         halpha_tot+=zone_data[zone]*zn_volume(zone)
      end do

      if (halpha_tot > zero) then
         call write_hdf('balmer_beta.hdf',zone_data,
     $        'Balmer_beta_rate','photons / (m**3 s)','E11.3',
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      end if

      do i=1,zn_num
         zone_data[i]=zero
      end do

      do test=1,pr_test_num
         if (string_lookup('D beta emission rate by species',tally_name,tl_num) > 0) then
            name_clean(sp_sy(pr_test(test)),clean_sy)
            ha_temp=zero
            index_parameters[tl_index_test]=test
            do zone=1,zn_num
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'D beta emission rate by species')
     $                 /(const(2.549)*electron_charge)
                  zone_data[zone]=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
               else
                  zone_data[zone]=zero
               end if
            end do
         end if
         halpha_tot=zero
         do zone=1,zn_num
            halpha_tot+=zone_data[zone]*zn_volume(zone)
         end do

         if (halpha_tot > zero) then
            call write_hdf('balmer_beta'\/trim(clean_sy)\/'.hdf',zone_data,
     $        'Balmer_beta_rate_'\/trim(clean_sy),'photons / (m**3 s)','E11.3',
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         end if
      end do

@ Read and plot EIRENE output files. To facilitate the benchmarking process,
have set up this routine to read the |fort.32| and |fort.44| files output
by EIRENE and then to put the data into the same HDF file format as
used by the rest of |geomtesta|.  Have passed down the pixel mesh and
storage arrays so their creation doesn't need to be repeated.

@<Functions...@>=

      subroutine plot_eirene_data(zone_data,na,nb,nc,xa,xb,xc,
     $                            pixel_zones,pixel_data)

      implicit_none_f77
      zn_common
      implicit_none_f90
                                           
      integer na,nb,nc                                  // Input
      integer pixel_zones[0:na*nb*nc-1]
      real zone_data[zn_num],xa[0:na-1],xb[0:nb-1],
     $     xc[0:nc-1],pixel_data[0:na*nb*nc-1]
      integer nx,ny,natmi,nmoli,nioni,nfl               // Local

      @<Memory allocation interface@>
      
      open(unit=diskin,file='eirene44.out',status='old',form='formatted',err=eof)
      read(diskin,'(i4,2x,i4)') nx,ny

      read(diskin,'(i4,2x,i4,2x,i4)') natmi,nmoli,nioni
      nfl=1    // No way to determine this from the files?

      call plot_eirene_continued(nx,ny,natmi,nmoli,nioni,nfl,
     $     diskin,zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

eof:  continue

      return
      end

@ Continue set up for reading and plotting of EIRENE data. Need to
start a new subroutine here so that the pointer arrays can be
properly dimensioned.

@<Functions...@>=

      subroutine plot_eirene_continued(nx,ny,natmi,nmoli,nioni,nfl,
     $                                 unit_num,zone_data,na,nb,nc,
     $                                 xa,xb,xc,pixel_zones,pixel_data)

      define_dimen(ix_ind,nx)
      define_dimen(iy_ind,ny)
      define_dimen(atm_ind,natmi)
      define_dimen(mol_ind,nmoli)
      define_dimen(ion_ind,nioni)
      define_dimen(fl_ind,nfl)

      define_varp(ix_iy_zone,INT,ix_ind,iy_ind)
      define_varp(atm_name,CHAR,species_symbol_string,atm_ind)
      define_varp(mol_name,CHAR,species_symbol_string,mol_ind)
      define_varp(ion_name,CHAR,species_symbol_string,ion_ind)
      define_varp(fl_name,CHAR,species_symbol_string,fl_ind)

      implicit_none_f77
      zn_common                                        // Common
      so_common
      implicit_none_f90

      integer nx,ny,natmi,nmoli,nioni,nfl,unit_num,    // Input
     $        na,nb,nc
      integer pixel_zones[0:na*nb*nc-1]
      real zone_data[zn_num],xa[0:na-1],xb[0:nb-1],
     $     xc[0:nc-1],pixel_data[0:na*nb*nc-1]
                                         
      integer i,length,zone,ix,iy,nstra               // Local
      real multiplier
      character*sp_sy_len stra_name          // Same length as other strings
      character*80 line

      declare_varp(ix_iy_zone)
      declare_varp(atm_name)
      declare_varp(mol_name)
      declare_varp(ion_name)
      declare_varp(fl_name)
      
      @<Memory allocation interface@>
      st_decls
      
      var_alloc(ix_iy_zone)

      do zone=1,zn_num
          if ((1 <= zn_index(zone,1) && zn_index(zone,1) <= nx)
     $        && (1 <= zn_index(zone,2) && zn_index(zone,2) <= ny)) then
             ix_iy_zone[zn_index(zone,1),zn_index(zone,2)]=zone
          end if
       end do
       do iy=1,ny
          do ix=1,nx
             assert(ix_iy_zone[ix,iy] > 0)
          end do
       end do

      var_alloc(atm_name)
      var_alloc(mol_name)
      var_alloc(ion_name)

      do i=1,natmi
         read(unit_num,*) atm_name[i]
      end do
      do i=1,nmoli
         read(unit_num,*) mol_name[i]
      end do
      do i=1,nioni
         read(unit_num,*) ion_name[i]
      end do

/*
  This list should correspond with that in EIRENE's subroutine |wneutral|.
*/
      call eirene_file_to_hdf(unit_num,nx,ny,natmi,ix_iy_zone,
     $   one,'eir_den_',atm_name,'density','m**-3','E11.3',
     $   zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      call eirene_file_to_hdf(unit_num,nx,ny,natmi,ix_iy_zone,
     $   one/electron_charge,'eir_temp_',atm_name,'temperature','eV','E11.3',
     $   zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      call eirene_file_to_hdf(unit_num,nx,ny,nmoli,ix_iy_zone,
     $   one,'eir_den_',mol_name,'density','m**-3','E11.3',
     $   zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      call eirene_file_to_hdf(unit_num,nx,ny,nmoli,ix_iy_zone,
     $   one/electron_charge,'eir_temp_',mol_name,'temperature','eV','E11.3',
     $   zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      call eirene_file_to_hdf(unit_num,nx,ny,nioni,ix_iy_zone,
     $   one,'eir_den_',ion_name,'density','m**-3','E11.3',
     $   zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      call eirene_file_to_hdf(unit_num,nx,ny,nioni,ix_iy_zone,
     $   one/electron_charge,'eir_temp_',ion_name,'temperature','eV','E11.3',
     $   zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

      close(unit=unit_num)

      open(unit=unit_num,file='eirene32.out',status='old',form='formatted')

      nstra=0
      var_alloc(fl_name)
      do i=1,nfl
         write(fl_name[i],'(a1,i2.2)') 'f',i
      end do

loop: continue
      if (read_string(unit_num,line,length)) then 
         nstra++
         write(stra_name,'(a1,i2.2)') 's',nstra
/*
   EIRENE leaves plate sources per unit flux; others are already scaled.
   See subroutine |infcop|.
*/
         if (so_type(nstra) == so_recomb) then
            multiplier=one/electron_charge
         else
            multiplier=so_tot_curr(nstra)
         end if   
/*
  This list should correspond to the one in EIRENE's |infcop|.
*/
         call eirene_file_to_hdf(unit_num,nx,ny,nfl,ix_iy_zone,
     $        multiplier,'eir_sni_'\/trim(stra_name),fl_name,
     $        'Ion source rate '\/trim(stra_name),'s**-1','E11.3',
     $        zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         call eirene_file_to_hdf(unit_num,nx,ny,nfl,ix_iy_zone,
     $        multiplier,'eir_smo_'\/trim(stra_name),fl_name,
     $        'Momentum source rate '\/trim(stra_name),'N','E11.3',
     $        zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         call eirene_file_to_hdf(unit_num,nx,ny,1,ix_iy_zone,
     $        multiplier,'eir_see_'\/trim(stra_name),'tot',
     $        'Electron energy source rate '\/trim(stra_name),'W','E11.3',
     $        zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         call eirene_file_to_hdf(unit_num,nx,ny,1,ix_iy_zone,
     $        multiplier,'eir_sei_'\/trim(stra_name),'tot',
     $        'Ion energy source rate '\/trim(stra_name),'W','E11.3',
     $        zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
         go to loop
      end if

      close(unit=unit_num)

      var_free(ix_iy_zone)
      var_free(atm_name)
      var_free(mol_name)
      var_free(ion_name)
      var_free(fl_name)

      assert(nstra == so_grps)  // Assuming strata $\leftrightarrow$ groups!

      return
      end

@ Read a section of an EIRENE output file and dump the contents to an HDF file.
The ``read'' section should look a great deal like EIRENE's subroutine |neutr|.

@<Functions...@>=

      subroutine eirene_file_to_hdf(unit_num,nx,ny,nf,ix_iy_zone,
     $           multiplier,cfilrt,cfilext,clabel,cunits,cformt,
     $           zone_data,na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)

      implicit_none_f77
      zn_common                                             // Common
      implicit_none_f90

      integer unit_num,nx,ny,nf,na,nb,nc                    // Input
      integer ix_iy_zone[nx,ny],pixel_zones[0:na*nb*nc-1]
      real multiplier
      real zone_data[zn_num],xa[0:na-1],xb[0:nb-1],xc[0:nc-1],
     $     pixel_data[0:na*nb*nc-1]
      character*(*) cfilrt,clabel,cunits,cformt
      character*(*) cfilext[nf]
      character*sp_sy_len clean_sy
      integer lim,i,j,ix,iy,zone,ind_tmp                     // Local

      @<Memory allocation interface@>
      st_decls
      
      do zone=1,zn_num
         zone_data[zone]=zero
      end do

      lim=(nx/5)*5-4
      do i=1,nf
         do iy=1,ny
            do ix=1,lim,5
               read(unit_num,'(5(e16.8))') SP 
     $              (zone_data[ix_iy_zone[ix-1+j,iy]],j=1,5)
            end do
            if (lim+4 != nx) then
               read(unit_num,'(5(e16.8))') SP 
     $              (zone_data[ix_iy_zone[ix,iy]],ix=lim+5,nx)
            end if
         end do

         if (multiplier != one) then
            do zone=1,zn_num
               zone_data[zone]*=multiplier
            end do
         end if

         name_clean(cfilext[i],clean_sy)
         call write_hdf(cfilrt\/trim(clean_sy)\/'.hdf',zone_data,
     $        trim(cfilext[i])\/' '\/clabel,cunits,cformt,
     $        na,nb,nc,xa,xb,xc,pixel_zones,pixel_data)
      end do

      return
      end

@* INDEX.
