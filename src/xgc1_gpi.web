% $Id: e5e9389b099a793fae389f49bf791ea53ba2eec9 $
\Title{xgc1_gpi}

% $Log: $

@* Plasma setup routine for the XGC1 GPI synthetic diagnostic.

Although designed explicitly to work with XGC1 data that have already
been processed by a Python routine, the procedures used here to interpolate data
along a field line may be of interest for other applications.

This routine is called by 
{\tt defineback}. The easiest way to compile it into {\tt defineback} is to
copy it to a file named {\tt usr2dplasma.web}:
\begin{verbatim}
cd $HOME/degas2/src
cp xgc1_gpi.web usr2dplasma.web
touch usr2dplasma.web
cd ../SUN
gmake defineback
\end{verbatim}

For additional details, see the documentation at the top of {\tt defineback}.

\ID{$Id: e5e9389b099a793fae389f49bf791ea53ba2eec9 $}

@m FILE 'xgc1_gpi.web'

@I macros.hweb
@I sysdep.hweb
@I netcdf.hweb
@I zone.hweb
@I species.hweb
@I string.hweb
@I background.hweb
@I location.hweb
@I geomint.hweb
@I xgc1interp.hweb

@ The unnamed module.

@a
      @<Functions and Subroutines@>

@ Interpolate three-dimensional plasma densities, temperatures,
and velocities from XGC1 data files for a synthetic GPI
diagnostic. This file is designed to work with geometry and
plasma data files generated by Python scripts that read the XGC1
output files.  The input string must contain, in order:
\begin{description}
  \item[|plasma_file_list|] File listing the XGC1 data files and the 
associated toroidal angles.

  \item[|efit_file|] ``GEQDSK'' format EFIT file used in the XGC1 run.

  \item[|xgc1int_nc_file|] Name of the netCDF file used for 
storing the field line following interpolation data for use
in time dependent calculations.  If not present, the file
will be written once the data have been generated.
\end{description}

The format of |plasma_file_list| is assumed to be:
\begin{enumerate}
  \item The first line contains (only) |num_files|, the number of XGC1 data files.  
For convenience, the maximum number is specified by the parameter 
|max_param|.  If this is zero, an axisymmetric plasma will be set up using the 
axisymmetric data file.
  \item Name of the axisymmetric data file.  Since this is used to provide
data around the edges of the mesh that do not intersect the XGC1 planes,
it must be included.
  \item A sequence of |num_files| (when $> 1$) lines each containing the toroidal
angle (in degrees, relative to the gas source, centered at $\phi = 0$) and the
name of the XGC1 data file.
\end{enumerate}

@m open_file(aunit,aname)    open(unit=aunit,file=trim(aname),status='old',form='formatted',iostat=open_stat);
         assert(open_stat == 0) @;

@m max_param 11         // Number of plasma parameters in each'

@<Functions...@>=
      subroutine get_n_t(nt_string)

      define_dimen(param_ind,max_param)
      define_dimen(tri_ind,num_tri)

      define_varp(xgc_params,FLOAT,xi_file_ind,param_ind,tri_ind)
      define_varp(triangles,INT,zone_ind)
      define_varp(triangles_xgc,INT,zone_ind)

      implicit_none_f77
      zn_common                                                 // Common
      xi_common
      implicit_none_f90

      @<Memory allocation interface@>

      character*LINELEN nt_string                               // Input

      integer p,b,e,length,diskin3,open_stat,num_files,
     $        ifile,num_tri,max_tri,i,zone,last_xgc_zone,
     $        num_iy,iy

      real density

      character*LINELEN line
      character*FILELEN plasma_file_list,efit_file,xgc1int_nc_file
      character*FILELEN file_names[0:xi_max_files]

      declare_varp(xgc_params)
      declare_varp(triangles)
      declare_varp(triangles_xgc)

      st_decls
      zn_decls

      p=0
      assert(next_token(nt_string,b,e,p))
      plasma_file_list=nt_string(b:e)
      assert(next_token(nt_string,b,e,p))
      efit_file=nt_string(b:e)
      assert(next_token(nt_string,b,e,p))
      xgc1int_nc_file=nt_string(b:e)

      diskin3=diskin+2
      open_file(diskin3,plasma_file_list)
      assert(read_string(diskin3,line,length))
      assert(length<=len(line))
      length=parse_string(line(:length))
      p=0
      assert(next_token(line,b,e,p))
      num_files=read_integer(line(b:e))
      assert(num_files >= 0)
/*
   Will use the last entry in the |file_names|
   array for the axisymmetric data, but read first
   for neatness.
*/
      assert(read_string(diskin3,line,length))
      assert(length<=len(line))
      length=parse_string(line(:length))
      p=0
      assert(next_token(line,b,e,p))
      file_names[num_files]=line(b:e)
/* 
   Note that the file index starts at zero since
   we will be using it as an interpolation index.
*/
      if (num_files > 1) then
         do ifile = 0,num_files-1
            assert(ifile < xi_max_files)  // Last slot used for averages
            assert(read_string(diskin3,line,length))
            assert(length<=len(line))
            length=parse_string(line(:length))
            p=0
            assert(next_token(line,b,e,p))
            xi_phis[ifile]=read_real(line(b:e))*(PI/const(1.8,2))
/*
   Convention for toroidal angles is that used in
   the |definegeometry2d| input file: the manifold
   is centered about a toroidal angle of zero.
   If needed, subtract $2 \pi$ so that the angles
   are continuous through the origin.  Note that
   the XGC1 data are collected onto each toroidal
   plane, represented by the input $\phi$ value.
*/
            if (xi_phis[ifile] > PI) xi_phis[ifile]=xi_phis[ifile]-two*PI
            assert(next_token(line,b,e,p))
            file_names[ifile]=line(b:e)
         end do
         close(unit=diskin3)
      end if
/*
   Previously used the zone indices to 
   get the number of triangles, but the
   more general approach does not go through
   a Sonnet format file.  Instead, just read
   all the way through the axisymmetric file
   and count the number of lines.

   The more general approach also loses track of the
   connection between triangle and zone number.  To
   compensate, the ``zone'' column of the plasma
   files is now actually the zone number (of the
   |iy| = 0 zone); the entry in the file is the
   triangle number.  This relationship is now stored
   in |triangles|.

   We also need to distinguish between triangles
   that are in the XGC1 mesh and those that are
   not.  The former are identified by having non-zero
   values in the second column of the file (should be
   electron density) and are identified by non-zero
   values of |triangles_xgc|.  Use the axisymmetric
   data (last file) for this purpose since the 3-D
   data files have non-zero minima.
*/
      num_tri=0
      max_tri=1000000
      last_xgc_zone=0
      num_iy=zone_index_max[zi_iy]
      open_file(diskin3,file_names[num_files])
      var_alloc(triangles)
      var_alloc(triangles_xgc)
      do zone=1,zn_num
         triangles[zone]=zero
         triangles_xgc[zone]=zero
      end do
      do i=1,max_tri
         if (! read_string(diskin3,line,length)) then
            goto eof
         else
            assert(length<=len(line))
            length=parse_string(line(:length))
            p=0
            assert(next_token(line,b,e,p))
            zone=read_int_soft_fail(line(b:e))
            if (zone != int_undef) then 
               assert(zn_check(zone))
               num_tri++
               triangles[zone]=num_tri
               assert(next_token(line,b,e,p))
               density=read_real(line(b:e))
               if (density > zero) then
                  triangles_xgc[zone]=num_tri
                  last_xgc_zone=zone
                  assert(zn_index(zone,zi_iy) == 0)
                  do iy=1,num_iy
                     triangles_xgc[zone+iy]=num_tri
                  end do
               end if
            end if
         end if
      end do
eof:  continue
      assert(num_tri > 0)
      assert(num_tri < max_tri)
      close(unit=diskin3)  // Do not think it needs to be rewound

      var_alloc(xgc_params)

      call get_n_t_a(file_names,num_files,xgc_params,num_tri,
     $               efit_file,xgc1int_nc_file,triangles,
     $               triangles_xgc,last_xgc_zone)

      var_free(xgc_params)
      var_free(triangles)
      var_free(triangles_xgc)
      var_free(xi_r_interp)
      var_free(xi_z_interp)
      var_free(xi_l_interp)
      var_free(xi_weight_interp)
      var_free(xi_file_interp)
      var_free(xi_tri_interp)

      return
      end

@ Extension of the above routine required to push
actual access of the pointer arrays to a subroutine
so their indices are handled correctlly.  After finding
some pre-existing bugs in testing, not sure that this
is completely necessary; retaining just in case.

@m max_iy 100          // Could dynamically allocate
@m lambda const(1.,-2)    // Fall-off length outside XGC1 mesh

@m n_phi_steps 40
@m rk_order 2

@m format_max LINELEN     // |format_code| is parsed from a line

// Reserve first 9 values for background indices
@m form_undefined 0
@m form_zone 10
@m form_density 11
@m form_temperature 12
@m form_velocity_1 13
@m form_velocity_2 14
@m form_velocity_3 15

@m data_loop #:0
@m kolumn_loop #:0    // ``column\_loop'' treated as a comment

@<Functions...@>=
      subroutine get_n_t_a(file_names,num_files,xgc_params,num_tri,
     $                     efit_file,xgc1int_nc_file,triangles,
     $                     triangles_xgc,last_xgc_zone)

      implicit_none_f77
      zn_common                                                 // Common
      bk_common
      gi_common
      xi_common
      implicit_none_f90

      integer num_files,num_tri,last_xgc_zone                   // Input
      integer triangles[zn_num],triangles_xgc[zn_num]

      real xgc_params[num_tri][max_param][0:xi_max_files]

      character*FILELEN efit_file,xgc1int_nc_file
      character*FILELEN file_names[0:xi_max_files]

      integer p,b,e,length,diskin3,open_stat,ifile,             // Local
     $        count,first_count,line_num,col_num,
     $        sub_count,zone,num_cols,ref_ptr,num_iy,tri,
     $        iy,icol,back,file_zone,zone2,close_zone,
     $        ifile2,close_tri,close_zone0,
     $        ipm,iphi,this_tri,tri_org,tri_minus,
     $        tri_plus,file_minus,file_plus,
     $        fileid
      integer format_code[format_max]

      real this_param,delta_min,delta,exp_factor,sum,psilim,
     $     r,z,phi_org,phi_dest,l_org,delta_phi,l_dest,
     $     min_temp,min_dens

      real phi_iy[0:max_iy],file_index[0:max_iy]

      character*LINELEN line,plasma_format
      character*FILELEN bfield_file
      character*21 rz_int_filename

      vc_decl(vec_delta)
      vc_decl(b_vec)
      vc_decl(b_hat)
      vc_decl(v_ext)
      vc_decl(x_org)
      vc_decl(x_dest)
      lc_decl(xx)

      external find_index,interpolate1                          // External
      real find_index,interpolate1

      st_decls
      nc_decls
      vc_decls
      zn_decls
      lc_decls
      @<Memory allocation interface@>
      xi_ncdecl

      diskin3=diskin+2
/*
   Axisymmetric data goes into the last slot.
*/
      do ifile = 0,num_files
         open_file(diskin3,file_names[ifile])
/*
   The format of these files is intended to follow
   defineback''s default ``tabular'' format. Hence,
   this routine will make extensive use of the code
   in |def2dplasma.web|.  But, at this stage, just
   reading in and parsing the label format, then 
   reading in the data from each file.
*/
         assert(read_string(diskin3,line,length))
         assert(length<=len(line))
         length=parse_string(line(:length))
         p=0
         assert(next_token(line,b,e,p))
/*
   First line of the file must be a format string
*/
         plasma_format=line(:length)
         call parse_format(plasma_format,bk_num,format_code,count)
/*
   At least for the way we will be using this input file format, each column,
   apart from the zone column, will have both a parameter label and a species
   identifier.  Use this fact to convert |count| to the expected number
   of parameters.
*/ 
         assert((count > 0) && (max_param >= 1+(count-1)/2))
         if (ifile == 0) then
            first_count=count
         else
            assert(count == first_count)
         end if
         line_num=0
 
data_loop: continue
         if (! read_string(diskin3,line,length)) goto eof
         line_num++
         col_num=0
         sub_count=0
         assert(length<=len(line))
         length=parse_string(line(:length))
         p=0

kolumn_loop: continue
         if (next_token(line,b,e,p)) then
            col_num++
            sub_count++
/*
   This is the only entry processed at this point.  
   We have already used the zone number to relate it
   to triangle number.  Just verify that connection here.
   Note again that this is just the |iy| = 0 zone number.
*/
            if (format_code[sub_count] == form_zone) then
               zone=read_integer(line(b:e))
               assert(triangles[zone] == line_num)
            else
/*
   This accounts for the species identifier in each of
   the other format entries.
*/
               sub_count++
            end if
            xgc_params[line_num][col_num][ifile]=read_real(line(b:e))
            goto kolumn_loop
         else
            if ((ifile == 0) && (line_num == 1)) then
               num_cols=col_num
            else
               assert(col_num == num_cols)
            end if
            goto data_loop
         end if

eof: continue
         assert(line_num == num_tri)
         close(unit=diskin3)
      end do
/*
   Read in EFIT file and set up interpolations.
*/
      call init_psi_interp(efit_file) 
/*
   At this point, all of the data from all of the files have
   been read in.

   Next need to set the toroidal angles
   used in the geometry.  Infer these from the first
   |num_iy| zone centers.  Have set up |zone_index_max[zi_iy]|
   expressly for this purpose.
*/
      assert(zn_type(1) == zn_plasma)
      ref_ptr=zn_index(1,zi_ptr)
 /*
   Originally thought that the |iy| index needed to begin at
   zero to facilitate interpolation.  This turns out to not be
   the case (file index starts at zero instead).  However, doing
   so makes it easier to connect with the external specification of
   toroidal angles and |zn_index| (|iy| = 0 corresponds to 
   zone between toroidal planes 0 and 1).
*/
      num_iy=zone_index_max[zi_iy]
      do zone=1,num_iy+1
         iy=zone-1
         assert(zn_index(zone,zi_ptr) == ref_ptr)
         phi_iy[iy]=atan2(zone_center[zone][2],zone_center[zone][1])
         if (phi_iy[iy] > PI) phi_iy[iy]=phi_iy[iy]-two*PI // as above
         if (num_files > 0) file_index[iy]
     $                     =find_index(phi_iy[iy],xi_phis,num_files)  // real
      end do

      if (num_files > 0) then
         call ncpopt(0)   // Squelches error messages
         fileid=ncopen(xgc1int_nc_file,NC_NOWRITE,nc_stat)
         if (nc_stat != 0) then
            @<Interpolate Along Field@>
         else
            call ncpopt(NC_VERBOSE+NC_FATAL)
            xi_ncread(fileid)
            call ncclose(fileid,nc_stat)
         end if
      else
         @<Axisymmetric Interpolation@>
      end if
/*
   While the |get_n_t| routines enforce minimum values for
   the plasma parameters, have found that the field line interpolation
   can still yield negative values.  The minimum density and temperature
   are the same as in the |get_n_t| routines.
*/
      min_temp=one
      min_dens=const(1.,15)
      do zone=1,zn_num
         if (zn_type(zone) == zn_plasma) then
            tri=triangles_xgc[zone]
            iy=zn_index(zone,zi_iy)
            sub_count=0
            do icol=1,num_cols
               if (tri > 0) then

                  tri_minus=xi_tri_interp[zone][xi_pm_minus]
                  assert((tri_minus > 0) && (tri_minus <= num_tri))
                  tri_plus=xi_tri_interp[zone][xi_pm_plus]
                  assert((tri_plus > 0) && (tri_plus <= num_tri))
                  file_minus=xi_file_interp[zone][xi_pm_minus]
                  assert((file_minus >= 0) && (file_minus <= num_files))
                  file_plus=xi_file_interp[zone][xi_pm_plus]
                  assert((file_plus >= 0) && (file_plus <= num_files))
/*
   For the NSTX case, have greater variation along a flux surface than
   toroidally.  To preserve the former during the interpolation process,
   need to interpolate the difference between the local and axisymmetric
   (i.e., the |num_files| entry) values, then add the axisymmetric
   value back in.
*/
@#if 0
                  this_param=xi_weight_interp[zone][xi_pm_minus]
     $                 *xgc_params[tri_minus][icol][file_minus]
     $                 +xi_weight_interp[zone][xi_pm_plus]
     $                 *xgc_params[tri_plus][icol][file_plus]
@#else
                  this_param=xgc_params[tri][icol][num_files]
     $                          + xi_weight_interp[zone][xi_pm_minus]
     $                             *(xgc_params[tri_minus][icol][file_minus]
     $                                - xgc_params[tri_minus][icol][num_files])
     $                          + xi_weight_interp[zone][xi_pm_plus]
     $                             *(xgc_params[tri_plus][icol][file_plus]
     $                                - xgc_params[tri_plus][icol][num_files])
@#endif



               else
/*
   For zones outside the XGC1 triangle mesh, use an exponential
   fall-off length to extrapolate the plasma parameters.
   Do this from the closest zone in the XGC1 triangle mesh.
   Searching for this can be time consuming, so make use of the
   fact that not only will this be the same zone for all columns
   of data after the first, but that we can determine the closest
   zone for subsequent |iy| by adding |iy| to |close_zone|.  Also,
   use |last_xgc_zone| to keep track of the last zone in the XGC1
   to remove the others from the |zone2| loop.  Doing this means that
   we do not need to test for |zn_plasma| and we can use a loop 
   increment of |num_iy|+1 (add 1 because |iy| starts at 0)  and 
   avoid testing $|iy| > 0$ zones.
*/
                  if (icol == 1) then
                     if (zn_index(zone,zi_iy) == 0) then
                        delta_min=geom_infinity
                        close_zone=int_uninit
                        do zone2=1,last_xgc_zone,(num_iy+1)
                           assert(zn_type(zone2) == zn_plasma)
                           assert(zn_index(zone2,zi_iy) == 0)
                           if (triangles_xgc[zone2] > 0) then
                              vc_difference(zone_center[zone],zone_center[zone2],
     $                             vec_delta)
                              delta=vc_abs(vec_delta)
                              if (delta < delta_min) then
                                 delta_min=delta
                                 close_zone=zone2
                              end if
                           end if
                        end do
                        close_zone0=close_zone
                     else
                        close_zone=close_zone0+zn_index(zone,zi_iy)
                     end if
                     assert(delta_min > zero && delta_min < geom_infinity)
                     assert(zn_check(close_zone))
                     close_tri=triangles_xgc[close_zone]
                     exp_factor=exp(-delta_min/lambda)
                  end if
                  this_param=xgc_params[close_tri][icol][num_files]  // Axisymmetric value
                  this_param*=exp_factor
               end if
               sub_count++
               if ((format_code[sub_count] == form_zone) && (tri > 0))then
                  file_zone=int(xgc_params[tri][icol][0])
                  assert(file_zone == zn_index(zone,zi_ptr))
               else if (format_code[sub_count] == form_density) then
                  sub_count++
                  back=format_code[sub_count]
                  assert(bk_check(back))
                  bk_n(back,zone)=max(this_param,min_dens)
               else if (format_code[sub_count] == form_temperature) then
                  sub_count++
                  back=format_code[sub_count]
                  assert(bk_check(back))
                  bk_temp(back,zone)=max(this_param,min_temp)*electron_charge
                  assert(bk_temp(back,zone) > zero)
               else if (format_code[sub_count] == form_velocity_1) then
                  sub_count++
                  back=format_code[sub_count]
                  assert(bk_check(back))
/*
   This holds the parallel velocity (for ions).  Compute other
   components from it.
*/
                  r=sqrt(zone_center[zone][1]**2+zone_center[zone][2]**2)
                  z=zone_center[zone][3]
                  call bvec_interp(r,z,vc_args(b_vec))
                  vc_unit(b_vec,b_hat)
                  vc_scale(this_param,b_hat,v_ext)
                  v_ext_to_int(zone_center[zone],v_ext,bk_v(back,zone),
     $                 geometry_symmetry,background_coords)
               else if (format_code[sub_count] == form_velocity_2) then
                  assert(' These files should have only one v' == ' ')
               else if (format_code[sub_count] == form_velocity_3) then
                  assert(' These files should have only one v' == ' ')
               end if    // format code
            end do       // columns
            assert(sub_count == count)
         end if            // |zn_type|
      end do               // Over |zone|

      return
      end

@ Interpolate along field lines.

@<Interpolate Along Field@>=

      var_alloc(xi_r_interp)
      var_alloc(xi_z_interp)
      var_alloc(xi_l_interp)
      var_alloc(xi_weight_interp)
      var_alloc(xi_file_interp)
      var_alloc(xi_tri_interp)

      do zone=1,zn_num
         if ((zn_type(zone) == zn_plasma) && (triangles_xgc[zone] > 0)) then
            iy=zn_index(zone,zi_iy)
            phi_org=phi_iy[iy]
            tri_org=triangles_xgc[zone]
/*
   This loop follows the field line first towards
   smaller toroidal angle and then in the other direction.

   Use here the properties of the interpolation
   index originally used for interpolation in toroidal
   angle to determine the toroidal angles of the
   XGC1 planes on the minus and plus sides of this 
   zone center.
*/
            do ipm=xi_pm_minus,xi_pm_plus
               xi_file_interp[zone][ipm]=num_files // Axisymmetric
               xi_tri_interp[zone][ipm]=tri_org
               if (ipm == xi_pm_minus) then        // Integrate in $-\phi$ direction
                  if (file_index[iy] > zero) then
                     phi_dest=xi_phis[int(file_index[iy])]
                     xi_file_interp[zone][ipm]=int(file_index[iy])
                  else
                     phi_dest=phi_org
                  end if
               else
                  if (file_index[iy] < areal(num_files-1)) then
                     phi_dest=xi_phis[int(file_index[iy]+1)]
                     xi_file_interp[zone][ipm]=int(file_index[iy]+1)
                  else
                     phi_dest=phi_org
                  end if
               end if
               if (phi_dest != phi_org) then
                  l_org=zero
                  delta_phi=(phi_dest-phi_org)/areal(n_phi_steps)
                  vc_copy(zone_center[zone],x_org)
                  do iphi=1,n_phi_steps
                     call follow_field(rk_order,vc_args(x_org),l_org,delta_phi,
     $                    vc_args(x_dest),l_dest)
                     l_org=l_dest
                     vc_copy(x_dest,x_org)
                  end do
/*
   The $R$ and $Z$ values were originally set up for
   testing, but suspect that they will be useful again
   at some later time.
*/
                  xi_r_interp[zone][ipm]=sqrt(x_dest[1]**2+x_dest[2]**2)
                  xi_z_interp[zone][ipm]=x_dest[3]
                  xi_l_interp[zone][ipm]=abs(l_dest)
                  vc_copy(x_dest,lc_x(xx))
                  lc_set(xx)
                  if (lc_cell(xx) > 0) then
                     this_tri=triangles_xgc[lc_zone(xx)]
                     if ((this_tri > 0) && (this_tri <= num_tri)) then 
                        xi_tri_interp[zone][ipm]=this_tri
                     else
                        xi_tri_interp[zone][ipm]=tri_org    // In a solid zone, etc.
                        xi_file_interp[zone][ipm]=num_files  
                     end if
                  else
                     xi_tri_interp[zone][ipm]=tri_org
/*
   This was set to a non-trivial value above, but is now useless
   since the location is outside the mesh.
*/
                     xi_file_interp[zone][ipm]=num_files  
                  end if
               else
                  xi_r_interp[zone][ipm]=sqrt(zone_center[zone][1]**2+zone_center[zone][2]**2)
                  xi_z_interp[zone][ipm]=zone_center[zone][3]
                  xi_l_interp[zone][ipm]=zero
                  xi_tri_interp[zone][ipm]=tri_org
               end if    // On |phi_dest|
            end do       // On plus and minus

            if ((xi_tri_interp[zone][xi_pm_minus] != tri_org)
     &          && (xi_tri_interp[zone][xi_pm_plus] != tri_org)) then
               xi_weight_interp[zone][xi_pm_minus]=xi_l_interp[zone][xi_pm_plus]
     $              /(xi_l_interp[zone][xi_pm_minus]+xi_l_interp[zone][xi_pm_plus])
            else if (xi_tri_interp[zone][xi_pm_minus] != tri_org) then
               xi_weight_interp[zone][xi_pm_minus]=one
            else 
/*
  This is the value needed for |xi_pm_plus| having a triangle,
  but use for case with neither having a triangle also
  since that will be using axisymmetric data.
*/
               xi_weight_interp[zone][xi_pm_minus]=zero
            end if
            xi_weight_interp[zone][xi_pm_plus]=one-xi_weight_interp[zone][xi_pm_minus]

         end if          // On |zn_type|
      end do             // Over zones
/*
   Write netCDF file.
*/
      fileid = nccreate(xgc1int_nc_file,NC_CLOBBER,nc_stat)
      xi_ncdef(fileid)
      call ncendef(fileid,nc_stat)
      xi_ncwrite(fileid)
      call ncclose(fileid,nc_stat)
      write(stdout,*) 'XGC1 interpolation netCDF file ',trim(xgc1int_nc_file),
     $                ' written'


@ Axisymmetric interpolation.  These are trivial settings of the
arrays used for field line interpolation.

@<Axisymmetric Interpolation@>=
      
      var_alloc(xi_r_interp)
      var_alloc(xi_z_interp)
      var_alloc(xi_l_interp)
      var_alloc(xi_weight_interp)
      var_alloc(xi_file_interp)
      var_alloc(xi_tri_interp)

      do zone=1,zn_num
         if ((zn_type(zone) == zn_plasma) && (triangles_xgc[zone] > 0)) then
            tri_org=triangles_xgc[zone]
            do ipm=xi_pm_minus,xi_pm_plus
               xi_file_interp[zone][ipm]=0
               xi_tri_interp[zone][ipm]=tri_org
            end do
            xi_weight_interp[zone][xi_pm_minus]=zero
            xi_weight_interp[zone][xi_pm_plus]=one
         end if
      end do

@* INDEX.


