% $Id: edfe0f23088a0534f955ff648dc38d86d095fdae $
\Title{pmiwrite}

@n/

@* Introduction.

\ID{$Id: edfe0f23088a0534f955ff648dc38d86d095fdae $}

Reads in text files containing plasma-material interaction data used
in the original DEGAS code and writes them out as NETCDF files. Of course,
the data available here are limited to that in the original files. For
the simpler data contained in the |refl.dat|, there are many combinations
of projectile and material. The data in |marl.dat|, however, apply to only
the three hydrogenic isotopes and helium incident on iron. The physical
process considered in both files is reflection.

Note that as written the file |refl.dat| does not include any angular
dependence. Partly as a demonstration of the flexibility of the data
format and partly as an effort to prevent the data from being too
trivial, we have incorporated a simple angular dependence for the reflection
coefficient as proposed by Ruzic:
\begin{equation}
R_{N}(E,\theta) = R_{N}(E,0) \left[ 1 + 0.5 \sin(\theta \pi / 180) \right],
\end{equation}
where $\theta$ is in degrees. An upper limit to $R_{N}$ of 0.9 is enforced.

@m FILE 'pmiwrite.web'

@I macros.hweb
@I pmiformat.hweb
@I readfilenames.hweb
@I element.hweb
@I netcdf.hweb
@I sysdep.hweb
@I string.hweb

@ The unnamed module.

@a
      program pmiwrite
      implicit_none_f77
      implicit_none_f90
      character*LINELEN tag,data_tag,v_type,version
      character*FILELEN filein
      tag='t -> c'
      version='V. 1.1, T reflection on C data from refl.dat with Ruzic lrflct1=2 angle dep.'
      call pmi_write_degas_refl(tag,version)
// Comment out most of the calls to keep things clean 
@#if 0
      tag='h -> c'
      version='V. 1.1, H reflection on C data from refl.dat with Ruzic lrflct1=2 angle dep.'
      call pmi_write_degas_refl(tag,version)
      tag='d -> c'
      version='V. 1.1, D reflection on C data from refl.dat with Ruzic lrflct1=2 angle dep.'
      call pmi_write_degas_refl(tag,version)
      tag='h -> mo'
      version='V. 1.1, H reflection on Mo data from refl.dat with Ruzic lrflct1=2 angle dep.'
      call pmi_write_degas_refl(tag,version)
      tag='d -> mo'
      version='V. 1.1, D reflection on Mo data from refl.dat with Ruzic lrflct1=2 angle dep.'
      call pmi_write_degas_refl(tag,version)
@#endif
      tag='he -> fe'
      version='V. 1.1, He reflection on Fe, marlowe data from marl.dat'
      call pmi_write_degas_marl(tag,version)
@#if 0
      tag='d -> fe'
      version='V. 1.1, H reflection on Fe, marlowe data from marl.dat'
      call pmi_write_degas_marl(tag,version)

      tag='h -> fe'
      version='V. 1.1, H reflection on Fe, marlowe data from marl.dat'
      call pmi_write_degas_marl(tag,version)
@#endif
      tag='mirror'
      version='V. 1.2, generic data for unit yield, specular reflection of any species on a mirror'
      call pmi_write_mirror(tag,version)
//      Try doing these manually... 
@#if 0
      tag='hdesorbc'
      v_type='cosine'
      call pmi_write_misc(tag,const(-1.0),v_type)
      tag='h2desorbc'
      v_type='cosine'
      call pmi_write_misc(tag,const(-1.0),v_type)
@#endif
      call readfilenames
      call nc_read_elements     // Needed to rescale TRIM data
      tag='D -> Mo'             // Capitalize to match element symbols
      data_tag='D -> Fe'
      version='V. 1.1. D reflection on Mo, trim data scaled from D on Fe'
      call pmi_write_trim(tag,data_tag,version)

      tag='He -> C'
      data_tag=tag
      version='V. 1.0. He reflection on C, trim data'
      call pmi_write_trim(tag,data_tag,version)
@#if 0
      tag='He -> Fe'
      data_tag=tag
      version='V. 1.0. He reflection on Fe, trim data'
      call pmi_write_trim(tag,data_tag,version)

      tag='He -> Mo'
      data_tag='He -> Fe'
      version='V. 1.0. He reflection on Mo, trim data scaled from He on Fe'
      call pmi_write_trim(tag,data_tag,version)

      tag='D -> Fe'        
      data_tag='D -> Fe'
      version='V. 1.1. D reflection on Fe, trim data'
      call pmi_write_trim(tag,data_tag,version)

      tag='H -> Fe'        
      data_tag='H -> Fe'
      version='V. 1.1. D reflection on Fe, trim data'
      call pmi_write_trim(tag,data_tag,version)
@#endif
      tag='D -> Li'
@#if 0
/*
    Started off with this approach, but decided that the scaling did not
    work very well at all.  This file could still be used for D on Be.
*/
      data_tag='D -> Be'
      version='V. 1.1. D reflection on Li, trim data scaled from D on Be'
      filein='../data/D_on_Be.txt'
      call pmi_write_trim2(tag,data_tag,version,filein)
@#else
/*
   Instead use VFTRIM data from Ruzic.  This came from an Excel spreadsheet,
   hence, the name of the routine.  The ``2'' refers to the fact that this
   is the second of these files; asked to have the energy range extended
   downward from 10 to 1 eV.
*/
      data_tag=tag
      version='V. 1.1. D reflection on Li, VFTRIM data from Ruzic'
      filein='../data/D_on_Li_Reflect2.txt'
      call pmi_write_xls_vftrim(tag,data_tag,version,filein)

      tag='H -> Li'
      data_tag='D -> Li'
      version='V. 1.1. H reflection on Li, VFTRIM data from Ruzic'
      filein='../data/D_on_Li_Reflect2.txt'
      call pmi_write_xls_vftrim(tag,data_tag,version,filein)

@#endif

      stop
      end
      
      @<Functions and subroutines@>
      
@ Reads data from DEGAS refl.dat file for a particular projectile - surface
combination. An angular dependence is added to the reflection coefficient.

@<Functions...@>=
      subroutine pmi_write_degas_refl(tag,version)
      implicit_none_f77
      pf_common                                      // Common
      implicit_none_f90
      character*LINELEN tag,version
      integer i,j,k,l,m,n,fileid,b,e,p,bin,ein,bm,em // Local
      real delta,theta_in,delta2
      character*LINELEN full_tag,description
      character*FILELEN filein,fileout
      logical fit,cosspec,cosine
      external rn_ruzic_fit                          // External
      real rn_ruzic_fit
      nc_decls
      pf_decls
      pf_ncdecl
      @<Memory allocation interface@>
      st_decls 

      fit=.true.
/* The following two must be the opposite of each other! */
      cosspec=.false.
      cosine=.true.

      description = 'Data for Plasma-Material Interactions in degas 2'
      pf_version = version

/* Parse tag into name */      
      p=0
      assert( next_token(tag,bin,ein,p) )
      assert( next_token(tag,b,e,p) )
      assert( tag(b:e) == '->' )
      assert( next_token(tag,bm,em,p) )
      pf_name=tag(bin:ein) \/ 'refl' \/ tag(bm:em)

/* 
   Set up everything for first dependent variable
*/
      pf_num_dep_var=1
      pf_var[0,1]='reflection_coef'
      pf_rank[1]=1
      
      pf_units[0,1]=' '
      pf_mult[0,1]=one

      pf_var[1,1]='energy_in'
      pf_tab_index[1,1]=48

      if (!fit) then
         pf_eval_name[1]='table'
         pf_spacing[0,1]='linear'
         pf_units[1,1]='eV'
         pf_mult[1,1]=electron_charge
         pf_spacing[1,1]='log'
         pf_min[1,1]=one
         delta=const(10.0)**const(0.1)
         pf_max[1,1]=pf_min[1,1]*delta**(pf_tab_index[1,1]-1)
      else
         pf_eval_name[1]='refl_ruzic'
         pf_spacing[0,1]='unknown'
         pf_units[1,1]=' '
         pf_mult[1,1]=zero
         pf_spacing[1,1]='unknown'
         pf_min[1,1]=zero
         pf_max[1,1]=zero
      end if

/*
   Assign default values to everything else
*/
      do i=pf_rank[1]+1,pf_table_rank_max
         pf_tab_index[i,1]=1
         pf_var[i,1]='unknown'
         pf_spacing[i,1]='unknown'
         pf_units[i,1]='unknown'
         pf_mult[i,1]=zero
         pf_min[i,1]=zero
         pf_max[i,1]=zero
      end do

      do j=pf_num_dep_var+1,pf_dep_var_max
         pf_rank[j]=1
         pf_eval_name[j]='unknown'
         pf_var[0,j]='unknown'
         pf_spacing[0,j]='unknown'
         pf_units[0,j]='unknown'
         pf_mult[0,j]=zero
         do i=1,pf_table_rank_max
            pf_tab_index[i,j]=1
            pf_var[i,j]='unknown'
            pf_spacing[i,j]='unknown'
            pf_units[i,j]='unknown'
            pf_mult[i,j]=zero
            pf_min[i,j]=zero
            pf_max[i,j]=zero
         end do
      end do

/*
   Allocate space for |pf_data_table| and then call subroutine to
   read in data for first dependent variable.
*/
      pf_ragged_alloc(pf_data,pf_tab_index)
   
      filein='../data/refl.dat'
      full_tag=' rn:  ' \/ tag 
      call pf_file_read(filein,full_tag,1)

/*
   Now add angular dependence to the first dependent variable. Since
   these data are not in any file (incorporated here via function
   |rn_ruzic_fit|), we cannot use the (general) |pf_file_read| routine
   to fill the table. In fact, since |pf_file_read| uses the present 
   dimensions of |pf_data_table|, we must set up everything for 
   the angular dependence, as well as for the second dependent
   variable, {\em after} we read in the reflection coefficient
   data.
*/
      pf_rank[1]=2
      pf_var[2,1]='polar_angle_in'
      pf_min[2,1]=zero
      if (!fit) then
         pf_tab_index[2,1]=5
         pf_units[2,1]='degrees'
         pf_mult[2,1]=PI/const(180.0)    
         pf_spacing[2,1]='linear'
         delta=const(20.0)
         pf_max[2,1]=const(80.0)  
      else
         pf_tab_index[2,1]=1
         pf_units[2,1]=' '
         pf_mult[2,1]=zero
         pf_spacing[2,1]='unknown'
         pf_max[2,1]=zero
      end if
/*
   Second dependent variable
*/
      pf_num_dep_var=2
      pf_var[0,2]='energy_out'
      pf_rank[2]=1
      pf_tab_index[1,2]=48
      pf_eval_name[2]='table'
      pf_units[0,2]='eV'
      pf_mult[0,2]=electron_charge
      pf_spacing[0,2]='linear'
      pf_var[1,2]='energy_in'
      pf_units[1,2]='eV'
      pf_mult[1,2]=electron_charge
      pf_spacing[1,2]='log'
      pf_min[1,2]=one
      delta2=const(10.0)**const(0.1)
      pf_max[1,2]=pf_min[1,2]*delta2**(pf_tab_index[1,2]-1)

/*
   Third dependent variable (fit)
*/
      if (cosspec) then
         pf_num_dep_var=3
         pf_var[0,3]='velocity_vector'
         pf_units[0,3]=' '
         pf_rank[3]=1
         pf_tab_index[1,3]=1
         pf_eval_name[3]='cosspec'
         pf_mult[0,3]=one
         pf_var[1,3]='polar_angle_in'
         pf_units[1,3]=' '
      end if
      if (cosine) then
         pf_num_dep_var=3
         pf_var[0,3]='velocity_vector'
         pf_units[0,3]=' '
         pf_rank[3]=0
         pf_eval_name[3]='cosine'
      end if

/*
   Can now reallocate |pf_data_table| \ldots
*/
      pf_ragged_realloc(pf_data,pf_tab_index)

/*
   Add the angular dependence to the reflection coefficient \ldots
*/
      if (!fit) then
         do j=1,pf_tab_index[2,1]-1
            do i=0,pf_tab_index[1,1]-1
               theta_in=pf_min[2,1]+j*delta
               pf_data_table(i,j,0,0,0,1)=rn_ruzic_fit(pf_data_table(i,0,0,0,0,1),theta_in)  
            end do
         end do  
      end if

/*
   And read in the data for the second dependent variable
*/
      full_tag=' er:  ' \/ tag
      call pf_file_read(filein,full_tag,2)

/*
   Set fit coefficient for the third dependent variable
*/
      if (cosspec) then
         pf_data_table(0,0,0,0,0,3)=1.7
      else
         pf_data_table(0,0,0,0,0,3)=real_undef
      end if

      do n=pf_num_dep_var+1,pf_dep_var_max
         do m=0,pf_tab_index[5,n]-1
            do l=0,pf_tab_index[4,n]-1
               do k=0,pf_tab_index[3,n]-1
                  do j=0,pf_tab_index[2,n]-1
                     do i=0,pf_tab_index[1,n]-1
                        pf_data_table(i,j,k,l,m,n)=real_unused
                     end do
                  end do
               end do
            end do
         end do
      end do

/*
   Write netCDF file and close everything up
*/

      fileout='./'\/trim(pf_name)\/'.nc'
      fileid = nccreate(fileout,NC_CLOBBER,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'description',NC_CHAR,
     $     string_length(description),
     $     description,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'data_version',NC_CHAR,
     $     string_length(pf_version),
     $     pf_version,nc_stat)
      
      pf_ncdef(fileid)
      call ncendef(fileid,nc_stat)
      pf_ncwrite(fileid)

      var_free(pf_data_tab)

      call ncclose(fileid,nc_stat)

      return
      end

@ Read in the data from a file.

@<Functions...@>=
      subroutine pf_file_read(filename,tag,dep_var)
      implicit_none_f77
      pf_common                  // Common
      implicit_none_f90
      character*(*) filename,tag // Input
      integer dep_var
      integer i,j,k,l,m          // Local
      character*LINELEN line
      pf_decls
      
      open(unit=diskin,file=filename,status='old',form='formatted')
      if (tag != ' ')then
loop:    continue
         read(diskin,'(a)') line
         if (line != tag) goto loop
      end if

/*
   With ragged array for |pf_data_table|, this looks very natural
*/
      read(diskin,*) SP ((((( pf_data_table(i,j,k,l,m,dep_var),i=0,pf_tab_index[1,dep_var]-1), j=0,pf_tab_index[2,dep_var]-1), k=0,pf_tab_index[3,dep_var]-1), l=0,pf_tab_index[4,dep_var]-1), m=0,pf_tab_index[5,dep_var]-1)

      close(unit=diskin)
      return
      end

@ Read data from DEGAS file marl.dat. The only projectiles considered
are the three isotopes of hydrogen and helium; the only surface is iron.

@m num_energies 7

@<Functions...@>=
      subroutine pmi_write_degas_marl(tag,version)
      implicit_none_f77
      pf_common                                                // Common
      implicit_none_f90
      pf_decls
      character*LINELEN tag,version
      integer i,j,fileid,b,e,p,bin,ein,bm,em,jspecies,k,l,m,n  // Local
      character*LINELEN description,line
      character*FILELEN filein,fileout
      real old_energies[0:num_energies-1],new_energies[0:num_energies-1],
     $     old_values[0:num_energies-1],new_values[0:num_energies-1]
      real delta
      external find_index                                      // External
      real find_index            

      nc_decls
      pf_ncdecl
      @<Memory allocation interface@>
      st_decls 

      description = 'Data for Plasma-Material Interactions in degas 2'
      pf_version = version

/* Parse tag into name */      
      p=0
      assert( next_token(tag,bin,ein,p) )
      assert( next_token(tag,b,e,p) )
      assert( tag(b:e) == '->' )
      assert( next_token(tag,bm,em,p) )
      assert( tag(bm:em) == 'fe' )                 // Only Fe data in file
      pf_name=tag(bin:ein) \/ 'refl' \/ tag(bm:em)

      if (tag(bin:ein) == 'h') then
         jspecies=1
      else if (tag(bin:ein) == 'd') then
         jspecies=2
      else if (tag(bin:ein) == 't') then
         jspecies=3
      else if (tag(bin:ein) == 'he') then
         jspecies=4
      else
         assert('Unsupport projectile species' == ' ')
      end if

      pf_num_dep_var=4

/*
   First dependent variable: reflection coefficient(incident angle, energy)
*/
      pf_var[0,1]='reflection_coef'
      pf_eval_name[1]='table'
      pf_rank[1]=2
      pf_units[0,1]=' '
      pf_mult[0,1]=one
      pf_spacing[0,1]='linear'

/*
   Second dependent variable: quantiles for outgoing energy
*/
      pf_var[0,2]='sqrt_energy_out'
      pf_eval_name[2]='table'
      pf_rank[2]=3
      pf_units[0,2]='eV^0.5'
      pf_mult[0,2]=sqrt(electron_charge)
      pf_spacing[0,2]='log'

/*
   Third dependent variable: quantiles for cosine of outgoing polar angle
*/
      pf_var[0,3]='cos_polar_angle_out'
      pf_eval_name[3]='table'
      pf_rank[3]=4
      pf_units[0,3]=' '
      pf_mult[0,3]=one
      pf_spacing[0,3]='linear'

/*
   Fourth dependent variable: quantiles for cosine of outgoing azimuthal angle
*/
      pf_var[0,4]='cos_azi_angle_out'
      pf_eval_name[4]='table'
      pf_rank[4]=5
      pf_units[0,4]=' '
      pf_mult[0,4]=one
      pf_spacing[0,4]='linear'

/*
   All dependent variables are functions of the incident energy and polar
   angle. However, these are sensibly the {\em last} of the independent 
   variables in the subscript list. Hence, the somewhat confused indexing
   below. The ``random number'' independent variables (below) will come
   first in the subscript list.
*/
      do j=1,pf_num_dep_var
         pf_var[j,j]='polar_angle_in'
         pf_tab_index[j,j]=5
         pf_units[j,j]='degrees'
         pf_mult[j,j]=PI/const(180.0)
         pf_spacing[j,j]='linear'
         pf_min[j,j]=zero
         pf_max[j,j]=const(80.0)

         pf_var[j+1,j]='energy_in'
         pf_tab_index[j+1,j]=7
         pf_units[j+1,j]='eV'
         pf_mult[j+1,j]=electron_charge
         pf_spacing[j+1,j]='log'
         pf_min[j+1,j]=one
         pf_max[j+1,j]=const(1.,3)
      end do

/*
   The ``outgoing'' variables are chosen from quantiles formed from the
   calculated distributions. Hence, the independent variable in this case
   is a random number which will be used to interpolate a value from those
   provided here. These distributions are correlated. Hence, the first
   random number is used to sample from all three, etc.
*/
      pf_var[1,2]='1st_random_number'
      
      pf_var[1,3]='2nd_random_number'
      pf_var[2,3]='1st_random_number'

      pf_var[1,4]='3rd_random_number'
      pf_var[2,4]='2nd_random_number'
      pf_var[3,4]='1st_random_number'

      do j=2,pf_num_dep_var
         do i=1,pf_rank[j]-2
            pf_tab_index[i,j]=5
            pf_units[i,j]=' '
            pf_mult[i,j]=one
            pf_spacing[i,j]='linear'
            pf_min[i,j]=const(0.1)
            pf_max[i,j]=const(0.9)
         end do
      end do

      do j=1,pf_num_dep_var
         if (pf_rank[j] < pf_table_rank_max) then
            do i=pf_rank[j]+1,pf_table_rank_max
               pf_tab_index[i,j]=1
               pf_var[i,j]='unknown'
               pf_spacing[i,j]='unknown'
               pf_units[i,j]='unknown'
               pf_mult[i,j]=zero
               pf_min[i,j]=zero
               pf_max[i,j]=zero
            end do
         end if
      end do

      do j=pf_num_dep_var+1,pf_dep_var_max
         pf_rank[j]=1
         pf_eval_name[j]='unknown'
         pf_var[0,j]='unknown'
         pf_spacing[0,j]='unknown'
         pf_units[0,j]='unknown'
         pf_mult[0,j]=zero
         do i=1,pf_table_rank_max
            pf_tab_index[i,j]=1
            pf_var[i,j]='unknown'
            pf_spacing[i,j]='unknown'
            pf_units[i,j]='unknown'
            pf_mult[i,j]=zero
            pf_min[i,j]=zero
            pf_max[i,j]=zero
         end do
      end do

      pf_ragged_alloc(pf_data,pf_tab_index)

      filein='../data/marl.dat'
      open(unit=diskin,file=filein,status='old',form='formatted')

/*
   The file |marl.dat| unfortunately has no literal tags in it. The
   only way to navigate about is by counting lines. This first loop
   skips over the required number of lines to reach the desired projectile.
*/
      if (jspecies > 1) then
         do j=1,1260*(jspecies-1)
            read(diskin,'(a)') line
         end do
      end if

/*
   Read the data. The ordering of the data is nonstandard in that there is
   an implied loop over dependent variables inside the two loops over incoming
   energy and angle. Hence, we use here specialized read statements.
*/
      do j=0,pf_tab_index[2,1]-1
         do i=0,pf_tab_index[1,1]-1
            read(diskin,*) pf_data_table(i,j,0,0,0,1)
            read(diskin,*) SP (pf_data_table(k,i,j,0,0,2),
     &                     k=0,pf_tab_index[1,2]-1)
            read(diskin,*) SP ((pf_data_table(k,l,i,j,0,3),
     &                     k=0,pf_tab_index[1,3]-1),
     &                     l=0,pf_tab_index[2,3]-1)
            read(diskin,*) SP (((pf_data_table(k,l,m,i,j,4),
     &                     k=0,pf_tab_index[1,4]-1),
     &                     l=0,pf_tab_index[2,4]-1),
     &                     m=0,pf_tab_index[3,4]-1)
         end do
      end do

/*
  Interpolate energy index onto uniform (log spaced) grid.
*/

      old_energies[0]=one
      old_energies[1]=const(25.)
      old_energies[2]=const(50.)
      old_energies[3]=const(100.)
      old_energies[4]=const(200.)
      old_energies[5]=const(500.)
      old_energies[6]=const(1.,3)

      assert(pf_tab_index[2,1] <= num_energies)   // Dimension of arrays
      delta=half*log(const(1.,1))
      do j=0,pf_tab_index[2,1]-1
         old_energies[j]=log(old_energies[j])
         new_energies[j]=log(pf_min[2,1])+j*delta
      end do

      do j=0,pf_tab_index[2,1]-1
         new_energies[j]=find_index(new_energies[j],old_energies,
     $        pf_tab_index[2,1])
      end do

      do i=0,pf_tab_index[1,1]-1
         do j=0,pf_tab_index[2,1]-1
            old_values[j]=pf_data_table(i,j,0,0,0,1)
         end do
         call interpolate_grid(new_values,old_values,pf_spacing[0,1],
     $        new_energies,pf_tab_index[2,1],pf_tab_index[2,1])
         do j=0,pf_tab_index[2,1]-1
            pf_data_table(i,j,0,0,0,1)=new_values[j]
         end do
      end do

      do k=0,pf_tab_index[1,2]-1
         do i=0,pf_tab_index[2,2]-1
            do j=0,pf_tab_index[3,2]-1
               old_values[j]=pf_data_table(k,i,j,0,0,2)
            end do
            call interpolate_grid(new_values,old_values,pf_spacing[0,2],
     $           new_energies,pf_tab_index[3,2],pf_tab_index[3,2])
            do j=0,pf_tab_index[3,2]-1
               pf_data_table(k,i,j,0,0,2)=new_values[j]
            end do
         end do
      end do
            
      do l=0,pf_tab_index[1,3]-1
         do k=0,pf_tab_index[2,3]-1
            do i=0,pf_tab_index[3,3]-1
               do j=0,pf_tab_index[4,3]-1
                  old_values[j]=pf_data_table(l,k,i,j,0,3)
               end do
               call interpolate_grid(new_values,old_values,pf_spacing[0,3],
     $              new_energies,pf_tab_index[4,3],pf_tab_index[4,3])
               do j=0,pf_tab_index[4,3]-1
                  pf_data_table(l,k,i,j,0,3)=new_values[j]
               end do
            end do
         end do
      end do

      do m=0,pf_tab_index[1,4]-1
         do l=0,pf_tab_index[2,4]-1
            do k=0,pf_tab_index[3,4]-1
               do i=0,pf_tab_index[4,4]-1
                  do j=0,pf_tab_index[5,4]-1
                     old_values[j]=pf_data_table(m,l,k,i,j,4)
                  end do
                  call interpolate_grid(new_values,old_values,pf_spacing[0,4],
     $                 new_energies,pf_tab_index[5,4],pf_tab_index[5,4])
                  do j=0,pf_tab_index[5,4]-1
                     pf_data_table(m,l,k,i,j,4)=new_values[j]
                  end do
               end do
            end do
         end do
      end do

      do n=pf_num_dep_var+1,pf_dep_var_max
         do m=0,pf_tab_index[5,n]-1
            do l=0,pf_tab_index[4,n]-1
               do k=0,pf_tab_index[3,n]-1
                  do j=0,pf_tab_index[2,n]-1
                     do i=0,pf_tab_index[1,n]-1
                        pf_data_table(i,j,k,l,m,n)=real_unused
                     end do
                  end do
               end do
            end do
         end do
      end do
/*
   Write netCDF file and close everything up
*/
      fileout='./'\/trim(pf_name)\/'.nc'
      fileid = nccreate(fileout,NC_CLOBBER,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'description',NC_CHAR,
     $     string_length(description),
     $     description,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'data_version',NC_CHAR,
     $     string_length(pf_version),
     $     pf_version,nc_stat)
      
      pf_ncdef(fileid)
      call ncendef(fileid,nc_stat)
      pf_ncwrite(fileid)

      var_free(pf_data_tab)

      call ncclose(fileid,nc_stat)
      close(unit=diskin)

      return
      end

@ Read data from EIRENE file TRIM. There are enough data in this file for
ten projectile-surface combinations. However, the comments in EIRENE list
only eight:
\begin{enumerate}
  \item H $\rightarrow$ Fe
  \item D $\rightarrow$ Fe
  \item H $\rightarrow$ C
  \item D $\rightarrow$ C
  \item He $\rightarrow$ Fe
  \item He $\rightarrow$ C
  \item T $\rightarrow$ Fe
  \item T $\rightarrow$ C
\end{enumerate}
although the current version of EIRENE then makes use of only the first
four of these.

@m num_energies 12
@m num_angles 7
@m num_rn_old 5
@m num_rn_new 9
@m rec_size 1092     //  $|num_angles|(1 + 5 + 5^{2} + 5^{3})$
@m theta_max const(85.0)*PI/const(180.0)   // As in EIRENE for polar angles

@<Functions...@>=
      subroutine pmi_write_trim(tag,data_tag,version)
      implicit_none_f77
      pf_common                                                // Common
      implicit_none_f90
      pf_decls
      character*LINELEN tag,data_tag,version
      integer i,j,fileid,b,e,p,bin,ein,bm,em,jpair,k,l,m,ipoint,  // Local
     $        kold,lold,mold,n
      character*LINELEN description,line
      character*FILELEN filein,fileout
      character*el_sy_len proj,target,data_proj,data_target
      real old_energies[0:num_energies-1],new_energies[0:num_energies-1],
     $     old_angles[0:num_angles-1],new_angles[0:num_angles-1],
     $     old_values[0:num_angles-1][0:num_energies-1],
     $     new_values[0:num_angles-1][0:num_energies-1],
     $     old_random[num_rn_old],new_random[num_rn_new],
     $     new_dist_1d[num_rn_new],old_dist_1d[num_rn_old],
     $     new_dist_2d[num_rn_new][num_rn_new],
     $     old_dist_2d[num_rn_old][num_rn_old],
     $     new_dist_3d[num_rn_new][num_rn_new][num_rn_new],
     $     old_dist_3d[num_rn_old][num_rn_old][num_rn_old],
     $     data_at_j(rec_size)
      real delta,cos_phi,e_red_data,e_red_actual,e_out_min
      external find_index,find_reduced_energy                  // External
      real find_index,find_reduced_energy           

      nc_decls
      pf_ncdecl
      @<Memory allocation interface@>
      st_decls 

      description = 'Data for Plasma-Material Interactions in degas 2'
      pf_version = version

/* Parse tag into name */      
      p=0
      assert( next_token(tag,bin,ein,p) )
      assert( next_token(tag,b,e,p) )
      assert( tag(b:e) == '->' )
      assert( next_token(tag,bm,em,p) )
      proj=tag(bin:ein)
      target=tag(bm:em)

/* Parse data tag to find place in file */
      p=0
      assert( next_token(data_tag,bin,ein,p) )
      assert( next_token(data_tag,b,e,p) )
      assert( data_tag(b:e) == '->' )
      assert( next_token(data_tag,bm,em,p) )
      data_proj=data_tag(bin:ein)
      data_target=data_tag(bm:em)

      if (proj == data_proj && target == data_target) then
         pf_name=tag(bin:ein) \/ '_refl_trim_' \/ tag(bm:em)
      else
         pf_name=tag(bin:ein) \/ '_refl_strim_' \/ tag(bm:em)  // ``scaled TRIM''
      end if

      if (data_proj == 'H' && data_target == 'Fe') then
         jpair=1
      else if (data_proj == 'D' && data_target == 'Fe') then
         jpair=2
      else if (data_proj == 'H' && data_target == 'C') then
         jpair=3
      else if (data_proj == 'D' && data_target == 'C') then
         jpair=4
      else if (data_proj == 'He' && data_target == 'Fe') then
         jpair=5
      else if (data_proj == 'He' && data_target == 'C') then
         jpair=6
      else if (data_proj == 'T' && data_target == 'Fe') then
         jpair=7
      else if (data_proj == 'T' && data_target == 'C') then
         jpair=8
@#if 0
/*
   Suspect that this first pair is correct. Sure of the second based
   on data contained in Reiter, et al. JUL-2605. These are both
   commented out since W is not yet in the list of elements.
*/
      else if (data_proj == 'D' && data_target == 'W') then
         jpair=9
      else if (data_proj == 'He' && data_target == 'W') then
         jpair=10
@#endif
      else
         assert('Unsupport data species' == ' ')
      end if

@<PMI Format Initializations@>

      filein='../data/TRIM'
      open(unit=diskin,file=filein,status='old',form='formatted')

/*
   The file |TRIM| unfortunately has no literal tags in it. The
   only way to navigate about is by counting lines. This first loop
   skips over the required number of lines to reach the desired projectile
   target combination.
*/
      if (jpair > 1) then
         do j=1,3276*(jpair-1)
            read(diskin,'(a)') line
         end do
      end if

/*
   Read the data. The ordering of the data is nonstandard in that there is
   an implied loop over dependent variables inside the two loops over incoming
   energy and angle. Hence, we use here specialized read statements.
*/
      do j=0,num_energies-1
         read(diskin,'(4e20.12)') SP (data_at_j(ipoint),ipoint=1,1092)
         ipoint=0
         do i=pf_tab_index[1,1]-1,0,-1
            ipoint++
            pf_data_table(i,j,0,0,0,1)=data_at_j(ipoint)
         end do

         do i=pf_tab_index[2,2]-1,0,-1
            do k=1,pf_tab_index[1,2]-2,2
               ipoint++
               pf_data_table(k,i,j,0,0,2)=data_at_j(ipoint)
            end do
         end do

         do i=pf_tab_index[3,3]-1,0,-1
            do l=1,pf_tab_index[2,3]-2,2
               do k=1,pf_tab_index[1,3]-2,2
                  ipoint++
                  pf_data_table(k,l,i,j,0,3)=data_at_j(ipoint)
               end do
            end do
         end do

         do i=pf_tab_index[4,4]-1,0,-1
            do m=1,pf_tab_index[3,4]-2,2
               do l=1,pf_tab_index[2,4]-2,2
                  do k=1,pf_tab_index[1,4]-2,2
                     ipoint++
                     pf_data_table(k,l,m,i,j,4)=data_at_j(ipoint)
                  end do
               end do
            end do
         end do
         assert(ipoint == 1092)
      end do

@<Process and Write PMI Format Data@>

      return
      end

@ Read standalone TRIM data file.  These files have the same data
as the EIRENE file called TRIM (see |pmi_write_trim|), but with
one target-projectile combination per file and with the data
in a human-readable format (like the MARLOWE data).

@<Functions...@>=
      subroutine pmi_write_trim2(tag,data_tag,version,filein)
      implicit_none_f77
      pf_common                                                // Common
      implicit_none_f90
      pf_decls
      character*LINELEN tag,data_tag,version                   // Input
      character*FILELEN filein
      integer i,j,fileid,b,e,p,bin,ein,bm,em,k,l,m,            // Local
     $        kold,lold,mold,n
      character*LINELEN description,line
      character*FILELEN fileout
      character*el_sy_len proj,target,data_proj,data_target
      real old_energies[0:num_energies-1],new_energies[0:num_energies-1],
     $     old_angles[0:num_angles-1],new_angles[0:num_angles-1],
     $     old_values[0:num_angles-1][0:num_energies-1],
     $     new_values[0:num_angles-1][0:num_energies-1],
     $     old_random[num_rn_old],new_random[num_rn_new],
     $     new_dist_1d[num_rn_new],old_dist_1d[num_rn_old],
     $     new_dist_2d[num_rn_new][num_rn_new],
     $     old_dist_2d[num_rn_old][num_rn_old],
     $     new_dist_3d[num_rn_new][num_rn_new][num_rn_new],
     $     old_dist_3d[num_rn_old][num_rn_old][num_rn_old]
      real delta,cos_phi,e_red_data,e_red_actual,e_out_min,dummy
      external find_index,find_reduced_energy                  // External
      real find_index,find_reduced_energy           

      nc_decls
      pf_ncdecl
      @<Memory allocation interface@>
      st_decls 

      description = 'Data for Plasma-Material Interactions in degas 2'
      pf_version = version

/* Parse tag into name */      
      p=0
      assert( next_token(tag,bin,ein,p) )
      assert( next_token(tag,b,e,p) )
      assert( tag(b:e) == '->' )
      assert( next_token(tag,bm,em,p) )
      proj=tag(bin:ein)
      target=tag(bm:em)

/* Parse data tag to find place in file */
      p=0
      assert( next_token(data_tag,bin,ein,p) )
      assert( next_token(data_tag,b,e,p) )
      assert( data_tag(b:e) == '->' )
      assert( next_token(data_tag,bm,em,p) )
      data_proj=data_tag(bin:ein)
      data_target=data_tag(bm:em)

      if (proj == data_proj && target == data_target) then
         pf_name=tag(bin:ein) \/ '_refl_trim2_' \/ tag(bm:em)
      else
         pf_name=tag(bin:ein) \/ '_refl_strim2_' \/ tag(bm:em)  // ``scaled TRIM''
      end if

@<PMI Format Initializations@>

      open(unit=diskin,file=filein,status='old',form='formatted')
/*
   Read the data. The ordering of the data is nonstandard in that there is
   an implied loop over dependent variables inside the two loops over incoming
   energy and angle. Hence, we use here specialized read statements.
*/
      do j=1,6
         read(diskin,*) line  // Blank lines
      end do
      do j=0,num_energies-1
         do i=pf_tab_index[1,1]-1,0,-1
            read(diskin,*) dummy,dummy,dummy,dummy,dummy,dummy,
     &                     pf_data_table(i,j,0,0,0,1)
            read(diskin,*) line
            read(diskin,*) SP (pf_data_table(k,i,j,0,0,2),
     &                     k=1,pf_tab_index[1,2]-1,2)
            read(diskin,*) line
            do l=1,pf_tab_index[1,3]-2,2
               read(diskin,*) SP (pf_data_table(k,l,i,j,0,3),
     &                     k=1,pf_tab_index[1,3]-2,2)
            end do
            read(diskin,*) line
            do m=1,pf_tab_index[3,4]-2,2
               do l=1,pf_tab_index[2,4]-2,2
                  read(diskin,*) SP (pf_data_table(k,l,m,i,j,4),
     &                               k=1,pf_tab_index[1,4]-2,2)
               end do
            end do
            read(diskin,*) line
            read(diskin,*) line
         end do
      end do

@<Process and Write PMI Format Data@>

      return
      end

@ Initialize PMI format arrays for use with TRIM data.

@<PMI Format Initializations@>=
      pf_num_dep_var=4

/*
   First dependent variable: reflection coefficient(incident angle, energy)
*/
      pf_var[0,1]='reflection_coef'
      pf_eval_name[1]='table'
      pf_rank[1]=2
      pf_units[0,1]=' '
      pf_mult[0,1]=one
      pf_spacing[0,1]='linear'

/*
   Compute scaling factor of incident and outgoing energies
*/
      e_red_data=find_reduced_energy(data_proj,data_target)
      e_red_actual=find_reduced_energy(proj,target)
      if (proj == data_proj && target == data_target) then 
         assert(e_red_data == e_red_actual)
      end if
      assert(e_red_data > zero && e_red_actual > zero)

/*
   Second dependent variable: quantiles for outgoing energy
*/
      pf_var[0,2]='energy_out'
      pf_eval_name[2]='table'
      pf_rank[2]=3
      pf_units[0,2]='eV'
      pf_mult[0,2]=electron_charge*e_red_actual/e_red_data
      pf_spacing[0,2]='log'
/*
   This minimum will be established with the new random grid. It will
   serve as a ``minimum minimum'': a room temperature wall (|two| is from
   averaging over a Maxwellian). Larger values could be enforced at runtime.
*/
      e_out_min=two*const(3.,2)*boltzmanns_const/pf_mult[0,2]

/*
   Third dependent variable: quantiles for cosine of outgoing polar angle
*/
      pf_var[0,3]='cos_polar_angle_out'
      pf_eval_name[3]='table'
      pf_rank[3]=4
      pf_units[0,3]=' '
      pf_mult[0,3]=one
      pf_spacing[0,3]='linear'

/*
   Fourth dependent variable: quantiles for cosine of outgoing azimuthal angle
*/
      pf_var[0,4]='cos_azi_angle_out'
      pf_eval_name[4]='table'
      pf_rank[4]=5
      pf_units[0,4]=' '
      pf_mult[0,4]=one
      pf_spacing[0,4]='linear'

/*
   All dependent variables are functions of the incident energy and polar
   angle. However, these are sensibly the {\em last} of the independent 
   variables in the subscript list. Hence, the somewhat confused indexing
   below. The ``random number'' independent variables (below) will come
   first in the subscript list.
*/
      do j=1,pf_num_dep_var
         pf_var[j,j]='cos_polar_angle_in'
         pf_tab_index[j,j]=num_angles
         pf_units[j,j]=' '
         pf_mult[j,j]=one
         pf_spacing[j,j]='linear'
         pf_min[j,j]=cos(theta_max)
         pf_max[j,j]=one

         pf_var[j+1,j]='energy_in'
         pf_tab_index[j+1,j]=num_energies
         pf_units[j+1,j]='eV'
         pf_mult[j+1,j]=electron_charge*e_red_actual/e_red_data
         pf_spacing[j+1,j]='log'
         pf_min[j+1,j]=one
         pf_max[j+1,j]=const(5.,3)
      end do

/*
   The ``outgoing'' variables are chosen from quantiles formed from the
   calculated distributions. Hence, the independent variable in this case
   is a random number which will be used to interpolate a value from those
   provided here. These distributions are correlated. Hence, the first
   random number is used to sample from all three, etc.
*/
      pf_var[1,2]='1st_random_number'
      
      pf_var[1,3]='2nd_random_number'
      pf_var[2,3]='1st_random_number'

      pf_var[1,4]='3rd_random_number'
      pf_var[2,4]='2nd_random_number'
      pf_var[3,4]='1st_random_number'

      do j=2,pf_num_dep_var
         do i=1,pf_rank[j]-2
            pf_tab_index[i,j]=num_rn_new+2   // Includes 0 and 1
            pf_units[i,j]=' '
            pf_mult[i,j]=one
            pf_spacing[i,j]='linear'
            pf_min[i,j]=zero
            pf_max[i,j]=one
         end do
      end do

      do j=1,pf_num_dep_var
         if (pf_rank[j] < pf_table_rank_max) then
            do i=pf_rank[j]+1,pf_table_rank_max
               pf_tab_index[i,j]=1
               pf_var[i,j]='unknown'
               pf_spacing[i,j]='unknown'
               pf_units[i,j]='unknown'
               pf_mult[i,j]=zero
               pf_min[i,j]=zero
               pf_max[i,j]=zero
            end do
         end if
      end do

      do j=pf_num_dep_var+1,pf_dep_var_max
         pf_rank[j]=1
         pf_eval_name[j]='unknown'
         pf_var[0,j]='unknown'
         pf_spacing[0,j]='unknown'
         pf_units[0,j]='unknown'
         pf_mult[0,j]=zero
         do i=1,pf_table_rank_max
            pf_tab_index[i,j]=1
            pf_var[i,j]='unknown'
            pf_spacing[i,j]='unknown'
            pf_units[i,j]='unknown'
            pf_mult[i,j]=zero
            pf_min[i,j]=zero
            pf_max[i,j]=zero
         end do
      end do

      pf_ragged_alloc(pf_data,pf_tab_index)

@ Process and write PMI format data from TRIM.

@<Process and Write PMI Format Data@>=
/*
  Interpolate energy index onto uniform (log spaced) grid.
*/

      old_energies[0]=one
      old_energies[1]=const(2.)
      old_energies[2]=const(5.)
      old_energies[3]=const(10.)
      old_energies[4]=const(20.)
      old_energies[5]=const(50.)
      old_energies[6]=const(1.,2)
      old_energies[7]=const(2.,2)
      old_energies[8]=const(5.,2)
      old_energies[9]=const(1.,3)
      old_energies[10]=const(2.,3)
      old_energies[11]=const(5.,3)

      old_angles[6]=one
      old_angles[5]=cos(const(30.)*PI/const(180.))
      old_angles[4]=cos(const(45.)*PI/const(180.))
      old_angles[3]=cos(const(60.)*PI/const(180.))
      old_angles[2]=cos(const(70.)*PI/const(180.))
      old_angles[1]=cos(const(80.)*PI/const(180.))
      old_angles[0]=cos(const(85.)*PI/const(180.))

      assert(pf_tab_index[2,1] == num_energies) 
      assert(pf_tab_index[1,1] == num_angles)
      delta=log(pf_max[2,1]/pf_min[2,1])/(pf_tab_index[2,1]-one)
      do j=0,pf_tab_index[2,1]-1
         old_energies[j]=log(old_energies[j])
         new_energies[j]=log(pf_min[2,1])+j*delta
      end do

      do j=0,num_energies-1
         new_energies[j]=find_index(new_energies[j],old_energies,
     $        num_energies)
      end do

      delta=(pf_max[1,1]-pf_min[1,1])/(pf_tab_index[1,1]-one)
      do i=0,num_angles-1
         new_angles[i]=pf_min[1,1]+i*delta
      end do

      do i=0,num_angles-1
         new_angles[i]=find_index(new_angles[i],old_angles,num_angles)
      end do

      do i=0,pf_tab_index[1,1]-1
         do j=0,pf_tab_index[2,1]-1
            old_values[i][j]=pf_data_table(i,j,0,0,0,1)
         end do
      end do

      call interpolate_grid2(new_values,old_values,pf_spacing[0,1],
     $     new_angles,new_energies,pf_tab_index[1,1],pf_tab_index[2,1],
     $     pf_tab_index[1,1],pf_tab_index[2,1])
      do i=0,pf_tab_index[1,1]-1
         do j=0,pf_tab_index[2,1]-1
            pf_data_table(i,j,0,0,0,1)=new_values[i][j]
         end do
      end do

      do k=1,pf_tab_index[1,2]-2,2

         do i=0,pf_tab_index[2,2]-1
            do j=0,pf_tab_index[3,2]-1
               old_values[i][j]=pf_data_table(k,i,j,0,0,2)
            end do
         end do

         call interpolate_grid2(new_values,old_values,pf_spacing[0,2],
     $        new_angles,new_energies,pf_tab_index[2,2],pf_tab_index[3,2],
     $        pf_tab_index[2,2],pf_tab_index[3,2])
         do i=0,pf_tab_index[2,2]-1
            do j=0,pf_tab_index[3,2]-1
               pf_data_table(k,i,j,0,0,2)=new_values[i][j]
            end do
         end do
      end do
            
      do l=1,pf_tab_index[1,3]-2,2
         do k=1,pf_tab_index[2,3]-2,2

            do i=0,pf_tab_index[3,3]-1
               do j=0,pf_tab_index[4,3]-1
                  old_values[i][j]=pf_data_table(l,k,i,j,0,3)
               end do
            end do

            call interpolate_grid2(new_values,old_values,pf_spacing[0,3],
     $           new_angles,new_energies,pf_tab_index[3,3],pf_tab_index[4,3],
     $           pf_tab_index[3,3],pf_tab_index[4,3])
            do i=0,pf_tab_index[3,3]-1
               do j=0,pf_tab_index[4,3]-1
                  pf_data_table(l,k,i,j,0,3)=new_values[i][j]
               end do
            end do
         end do
      end do

      do m=1,pf_tab_index[1,4]-2,2
         do l=1,pf_tab_index[2,4]-2,2
            do k=1,pf_tab_index[3,4]-2,2

               do i=0,pf_tab_index[4,4]-1
                  do j=0,pf_tab_index[5,4]-1
                     old_values[i][j]=pf_data_table(m,l,k,i,j,4)
                  end do
               end do

               call interpolate_grid2(new_values,old_values,pf_spacing[0,4],
     $             new_angles,new_energies,pf_tab_index[4,4],pf_tab_index[5,4],
     $              pf_tab_index[4,4],pf_tab_index[5,4])
               do i=0,pf_tab_index[4,4]-1
                  do j=0,pf_tab_index[5,4]-1
                     pf_data_table(m,l,k,i,j,4)=new_values[i][j]
                  end do
               end do
            end do
         end do
      end do
/*
   Now interpolate from old random grid to new random grid. Apart from
   the bounding values, this is intended to be nearly trivial.
*/
      do k=1,num_rn_old
         old_random[k]=const(0.1)+(k-1)*const(0.2)
      end do
      do k=1,num_rn_new
         new_random[k]=k*const(0.1)
      end do

      do k=1,num_rn_new
         new_random[k]=find_index(new_random[k],old_random,num_rn_new)
      end do

      delta=log(pf_max[2,1]/pf_min[2,1])/(pf_tab_index[2,1]-one)
      do j=0,pf_tab_index[3,2]-1
         do i=0,pf_tab_index[2,2]-1

            kold=0
            do k=1,pf_tab_index[1,2]-2,2
               kold++
               old_dist_1d[kold]=pf_data_table(k,i,j,0,0,2)
            end do
            assert(kold==num_rn_old)
            call interpolate_grid(new_dist_1d,old_dist_1d,pf_spacing[0,2],
     $           new_random,num_rn_new,num_rn_old)
/*
  Set minimum reflected energy. There is a global minimum (set above),
  but here attempt to track EIRENE's practice of mindlessly extrapolating
  (linearly, not as log) to |k|=0.
*/
            pf_data_table(0,i,j,0,0,2)=max(e_out_min,
     $           const(1.5)*new_dist_1d[1]-half*new_dist_1d[3])
            do k=1,pf_tab_index[1,2]-2
               pf_data_table(k,i,j,0,0,2)=new_dist_1d[k]
            end do
            pf_data_table(pf_tab_index[1,2]-1,i,j,0,0,2)=pf_min[2,1]*exp(j*delta)

         end do
      end do

      do j=0,pf_tab_index[4,3]-1
         do i=0,pf_tab_index[3,3]-1

            lold=0
            do l=1,pf_tab_index[2,3]-2,2
               lold++
               kold=0
               do k=1,pf_tab_index[1,3]-2,2
                  kold++
                  old_dist_2d[lold][kold]=pf_data_table(l,k,i,j,0,3)
               end do
            end do
            assert(lold==num_rn_old && kold==num_rn_old)
            call interpolate_grid2(new_dist_2d,old_dist_2d,pf_spacing[0,3],
     $           new_random,new_random,num_rn_new,num_rn_new,
     $           num_rn_old,num_rn_old)
            do l=0,pf_tab_index[2,3]-1
               do k=0,pf_tab_index[1,3]-1
                  kold=min(max(k,1),pf_tab_index[1,3]-2)
                  if (l == 0) then
@#if 0
        // Sensible definite value for endpoint

                     pf_data_table(l,k,i,j,0,3)=cos(theta_max)
@#else
        // Hack endpoint to duplicate extrapolation done in EIRENE

                     pf_data_table(l,k,i,j,0,3)=max(cos(theta_max),
     $                 const(1.5)*new_dist_2d[1][kold]-half*new_dist_2d[3][kold])
@#endif
                  else if (l == pf_tab_index[2,3]-1) then
                     pf_data_table(l,k,i,j,0,3)=one
                  else
                     pf_data_table(l,k,i,j,0,3)=new_dist_2d[l][kold]
                  end if
               end do
            end do
         end do
      end do

      do j=0,pf_tab_index[5,4]-1
         do i=0,pf_tab_index[4,4]-1

            mold=0
            do m=1,pf_tab_index[3,4]-2,2
               mold++
               lold=0
               do l=1,pf_tab_index[2,4]-2,2
                  lold++
                  kold=0
                  do k=1,pf_tab_index[1,4]-2,2
                     kold++
                     old_dist_3d[mold][lold][kold]=pf_data_table(m,l,k,i,j,4)
                  end do
               end do
            end do
            call interpolate_grid3(new_dist_3d,old_dist_3d,pf_spacing[0,4],
     $           new_random,new_random,new_random,pf_tab_index[3,4]-2,
     $           pf_tab_index[2,4]-2,pf_tab_index[1,4]-2,mold,lold,kold)
            do m=0,pf_tab_index[3,4]-1
               do l=0,pf_tab_index[2,4]-1
                  lold=min(max(l,1),pf_tab_index[2,4]-2)
                  do k=0,pf_tab_index[1,4]-1
                     kold=min(max(k,1),pf_tab_index[1,4]-2)
                     if (m == 0) then
                        pf_data_table(m,l,k,i,j,4)=-one
                     else if (m == pf_tab_index[3,4]-1) then
                        pf_data_table(m,l,k,i,j,4)=one
                     else 
                        pf_data_table(m,l,k,i,j,4)=new_dist_3d[m][lold][kold]
                     end if
                  end do
               end do
            end do
         end do
      end do

/*
  In doing the interpolations, EIRENE forces perpendicular incident events
  to have azimuthal symmetry upon reflection. Can just as well modify
  the data to do this.
*/
      delta=(pf_max[1,4]-pf_min[1,4])/(pf_tab_index[1,4]-one)
      do m=0,pf_tab_index[1,4]-1
         cos_phi=cos(PI*(one-(pf_min[1,4]+m*delta))) // $(1-\xi)$ as in EIRENE!
         do l=0,pf_tab_index[2,4]-1
            do k=0,pf_tab_index[3,4]-1
               do j=0,pf_tab_index[5,4]-1
                  i=pf_tab_index[4,4]-1               // $\cos(\theta_{in})=1$
                  pf_data_table(m,l,k,i,j,4)=cos_phi
               end do
            end do
         end do
      end do
                  
      do n=pf_num_dep_var+1,pf_dep_var_max
         do m=0,pf_tab_index[5,n]-1
            do l=0,pf_tab_index[4,n]-1
               do k=0,pf_tab_index[3,n]-1
                  do j=0,pf_tab_index[2,n]-1
                     do i=0,pf_tab_index[1,n]-1
                        pf_data_table(i,j,k,l,m,n)=real_unused
                     end do
                  end do
               end do
            end do
         end do
      end do
/*
   Write netCDF file and close everything up
*/
      fileout='./'\/trim(pf_name)\/'.nc'
      fileid = nccreate(fileout,NC_CLOBBER,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'description',NC_CHAR,
     $     string_length(description),
     $     description,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'data_version',NC_CHAR,
     $     string_length(pf_version),
     $     pf_version,nc_stat)
      
      pf_ncdef(fileid)
      call ncendef(fileid,nc_stat)
      pf_ncwrite(fileid)

      var_free(pf_data_tab)

      call ncclose(fileid,nc_stat)
      close(unit=diskin)

@ Read data derived from an Excel spreadsheet.  These data were generated
by VFTRIM and presumably manually entered into an Excel spreadsheet.  To
avoid needless conversion of the data, have opted to read them directly
from a tab-delimited text version of this file.

@m num_old_energies 11
@m num_new_energies 10
@m num_old_angles 5
@m num_new_angles 6

@<Functions...@>=
      subroutine pmi_write_xls_vftrim(tag,data_tag,version,filein)
      implicit_none_f77
      pf_common                                                // Common
      implicit_none_f90
      pf_decls
      character*LINELEN tag,data_tag,version                   // Input
      character*FILELEN filein

      integer i,j,fileid,b,e,p,bin,ein,bm,em,k,l,m,n           // Local
      character*LINELEN line,description
      character*FILELEN fileout
      character*el_sy_len proj,target,data_proj,data_target
      logical cosspec,cosine
      real old_energies[0:num_old_energies-1],
     $     new_energies[0:num_new_energies-1],
     $     old_angles[0:num_old_angles-1],
     $     new_angles[0:num_new_angles-1],
     $     old_rn[0:num_old_angles-1][0:num_old_energies-1],
     $     new_rn[0:num_new_angles-1][0:num_new_energies-1],
     $     old_eout[0:num_old_angles-1][0:num_old_energies-1],
     $     new_eout[0:num_new_angles-1][0:num_new_energies-1]
      real angle,energy,dummy,delta_e,delta_a,e_red_data,
     $     e_red_actual
      external find_index,find_reduced_energy                   // External
      real find_index,find_reduced_energy 

      nc_decls
      pf_ncdecl
      @<Memory allocation interface@>
      st_decls 

/* The following two must be the opposite of each other! */
      cosspec=.true.
      cosine=.false.

      description = 'Data for Plasma-Material Interactions in degas 2'
      pf_version = version

/* Parse tag into name */      
      p=0
      assert( next_token(tag,bin,ein,p) )
      assert( next_token(tag,b,e,p) )
      assert( tag(b:e) == '->' )
      assert( next_token(tag,bm,em,p) )
      proj=tag(bin:ein)
      target=tag(bm:em)

/* Parse data tag into name */      
      p=0
      assert( next_token(data_tag,bin,ein,p) )
      assert( next_token(data_tag,b,e,p) )
      assert( data_tag(b:e) == '->' )
      assert( next_token(data_tag,bm,em,p) )
      data_proj=data_tag(bin:ein)
      data_target=data_tag(bm:em)

      if (proj == data_proj && target == data_target) then
         pf_name=tag(bin:ein) \/ '_refl_vftrim_' \/ tag(bm:em)
      else
         pf_name=tag(bin:ein) \/ '_refl_svftrim_' \/ tag(bm:em)  // ``scaled VFTRIM''
      end if
/*
   Compute scaling factor of incident and outgoing energies
*/
      e_red_data=find_reduced_energy(data_proj,data_target)
      e_red_actual=find_reduced_energy(proj,target)
      if (proj == data_proj && target == data_target) then 
         assert(e_red_data == e_red_actual)
      end if
      assert(e_red_data > zero && e_red_actual > zero)

      open(unit=diskin,file=filein,status='old',form='formatted')
/*
  Interpolate energies and angles onto uniform grids.
*/
      old_energies[0]=one
      old_energies[1]=two
      old_energies[2]=const(5.)
      old_energies[3]=const(10.)
      old_energies[4]=const(20.)
      old_energies[5]=const(50.)
      old_energies[6]=const(1.,2)
      old_energies[7]=const(2.,2)
      old_energies[8]=const(3.,2)
      old_energies[9]=const(5.,2)
      old_energies[10]=const(1.,3)

      old_angles[0]=zero
      old_angles[1]=const(30.)
      old_angles[2]=const(45.)
      old_angles[3]=const(60.)
      old_angles[4]=const(75.)
/*
  Read the data.
*/
      do i=1,4
         read(diskin,*) line  // Input data for VFTRIM
      end do

      do j=0,num_old_angles-1
         read(diskin,'(6x,f2.0)') angle
         assert(old_angles[j] == angle)
         read(diskin,*) line                 // Column labels
         do i=0,num_old_energies-1
            read(diskin,*) energy,old_rn[j][i],dummy,dummy,dummy,dummy,
     $                     dummy,old_eout[j][i]
            assert(old_energies[i] == energy)
            
         end do
         read(diskin,*) line                // Blank line
      end do

      pf_num_dep_var=3
 /* 
   Set up everything for the two dependent variables read from file.
*/
      pf_var[0,1]='reflection_coef'
      pf_spacing[0,1]='linear'
      pf_units[0,1]=' '
      pf_mult[0,1]=one

      pf_var[0,2]='energy_out'
      pf_spacing[0,2]='log'
      pf_units[0,2]='eV'
      pf_mult[0,2]=electron_charge*e_red_actual/e_red_data
      
      do i=1,2
         pf_eval_name[i]='table'
         pf_rank[i]=2

         pf_var[1,i]='energy_in'
         pf_tab_index[1,i]=num_new_energies
         pf_units[1,i]='eV'
         pf_mult[1,i]=electron_charge*e_red_actual/e_red_data
         pf_spacing[1,i]='log'
         pf_min[1,i]=one
         delta_e=const(10.0)**(one/const(3.))
         pf_max[1,i]=pf_min[1,i]*delta_e**(pf_tab_index[1,i]-1)

         pf_var[2,i]='polar_angle_in'
         pf_tab_index[2,i]=num_new_angles
         pf_units[2,i]='degrees'
         pf_mult[2,i]=PI/const(180.0)
         pf_spacing[2,i]='linear'
         pf_min[2,i]=zero
         delta_a=const(15.)
         pf_max[2,i]=const(75.)
      end do
/*
   Third dependent variable (fit)
*/
      if (cosspec) then
         pf_num_dep_var=3
         pf_var[0,3]='velocity_vector'
         pf_units[0,3]=' '
         pf_rank[3]=1
         pf_tab_index[1,3]=1
         pf_eval_name[3]='cosspec'
         pf_mult[0,3]=one
         pf_var[1,3]='polar_angle_in'
         pf_units[1,3]=' '
      end if
      if (cosine) then
         pf_num_dep_var=3
         pf_var[0,3]='velocity_vector'
         pf_units[0,3]=' '
         pf_rank[3]=0
         pf_eval_name[3]='cosine'
      end if
 /*
   Assign default values to everything else
*/
      do j=1,pf_num_dep_var
         do i=pf_rank[j]+1,pf_table_rank_max
            pf_tab_index[i,j]=1
            pf_var[i,j]='unknown'
            pf_spacing[i,j]='unknown'
            pf_units[i,j]='unknown'
            pf_mult[i,j]=zero
            pf_min[i,j]=zero
            pf_max[i,j]=zero
         end do
      end do

      do j=pf_num_dep_var+1,pf_dep_var_max
         pf_rank[j]=1
         pf_eval_name[j]='unknown'
         pf_var[0,j]='unknown'
         pf_spacing[0,j]='unknown'
         pf_units[0,j]='unknown'
         pf_mult[0,j]=zero
         do i=1,pf_table_rank_max
            pf_tab_index[i,j]=1
            pf_var[i,j]='unknown'
            pf_spacing[i,j]='unknown'
            pf_units[i,j]='unknown'
            pf_mult[i,j]=zero
            pf_min[i,j]=zero
            pf_max[i,j]=zero
         end do
      end do

      pf_ragged_alloc(pf_data,pf_tab_index)

      assert(pf_tab_index[1,1] == num_new_energies) 
      assert(pf_tab_index[2,1] == num_new_angles)

      do j=0,num_old_energies-1
         old_energies[j]=log(old_energies[j])
      end do
      do j=0,num_new_energies-1
         new_energies[j]=log(pf_min[1,1])+j*log(delta_e)
      end do

      do j=0,num_new_energies-1
         new_energies[j]=find_index(new_energies[j],old_energies,
     $        num_old_energies)
      end do

      do i=0,num_new_angles-1
         new_angles[i]=pf_min[2,1]+i*delta_a
      end do

      do i=0,num_new_angles-1
         new_angles[i]=find_index(new_angles[i],old_angles,num_old_angles)
      end do

      call interpolate_grid2(new_rn,old_rn,pf_spacing[0,1],
     $     new_angles,new_energies,num_new_angles,num_new_energies,
     $     num_old_angles,num_old_energies)
      call interpolate_grid2(new_eout,old_eout,pf_spacing[0,2],
     $     new_angles,new_energies,num_new_angles,num_new_energies,
     $     num_old_angles,num_old_energies)
      do i=0,num_new_energies-1
         do j=0,num_new_angles-1
            pf_data_table(i,j,0,0,0,1)=new_rn[j][i]
            pf_data_table(i,j,0,0,0,2)=new_eout[j][i]
         end do
      end do
/*
   Set fit coefficient for the third dependent variable
*/
      if (cosspec) then
         pf_data_table(0,0,0,0,0,3)=one
      else
         pf_data_table(0,0,0,0,0,3)=real_undef
      end if

      do n=pf_num_dep_var+1,pf_dep_var_max
         do m=0,pf_tab_index[5,n]-1
            do l=0,pf_tab_index[4,n]-1
               do k=0,pf_tab_index[3,n]-1
                  do j=0,pf_tab_index[2,n]-1
                     do i=0,pf_tab_index[1,n]-1
                        pf_data_table(i,j,k,l,m,n)=real_unused
                     end do
                  end do
               end do
            end do
         end do
      end do
/*
   Write netCDF file and close everything up
*/
      fileout='./'\/trim(pf_name)\/'.nc'
      fileid = nccreate(fileout,NC_CLOBBER,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'description',NC_CHAR,
     $     string_length(description),
     $     description,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'data_version',NC_CHAR,
     $     string_length(pf_version),
     $     pf_version,nc_stat)
      
      pf_ncdef(fileid)
      call ncendef(fileid,nc_stat)
      pf_ncwrite(fileid)

      var_free(pf_data_tab)

      call ncclose(fileid,nc_stat)
      close(unit=diskin)

      return
      end
     
@ Computes reduced energy for reflection. The formulas used here come
from W. Eckstein, {\em Computer Simulation of Ion-Solid Interactions}
(Springer-Verlag, New York, 1991) (the corresponding equation numbers
are indicated below. The binary collision approach to
dealing with reflections of an atom off of a material can be parameterized
by a dimensionless energy
$$
\varepsilon = \frac{A E_{0}}{1 + A} / \frac{Z_{p} Z_{t} {\rm e}^{2}}{a},
\eqno(2.7.31)
$$
where $A = M_{t} / M_{p}$ is the ratio of the target to projectile 
mass, $E_{0}$ is the projectile's incident energy, $Z_{t} {\rm e}$ and
$Z_{p} {\rm e}$ are the nuclear charges, and $a$ is the screening 
length for the nuclear potentials. Following EIRENE, we use here the
Lindhard expression for the screening length
$$
a = \left( \frac{9 \pi^{2}}{12} \right)^{1/3} a_{B} 
(Z_{p}^{2/3} + Z_{t}^{2/3})^{-1/2}, \eqno(4.1.6)
$$
with $a_{B}$ being the Bohr radius.

For convenience and clarity of expression, we define the ``reduced energy''
$E_{\rm red}$ by $\varepsilon \equiv E_{0} / E_{\rm red}$. Inserting the
values for the constants into the above, we then have
\[
E_{\rm red} = 30.735 Z_{p} Z_{t} (Z_{p}^{2/3} + Z_{t}^{2/3})^{1/2} 
\frac{M_{t} + M_{p}}{M_{t}}, \quad {\rm eV}.
\]

@<Functions...@>=
      function find_reduced_energy(proj,target)
      implicit_none_f77
      el_common
      implicit_none_f90

      real find_reduced_energy                    // Function
      character*(*) proj,target                   // Input

      el_decl(proj_el)                            // Local
      el_decl(target_el)

      st_decls

      proj_el=el_lookup(proj)       // Theory applies to atoms only!
      assert(el_check(proj_el))
      target_el=el_lookup(target)
      assert(el_check(target_el))

      find_reduced_energy=const(30.735)*el_z(proj_el)*el_z(target_el)
     &     *sqrt(el_z(proj_el)^(two/const(3.))+el_z(target_el)^(two/const(3.)))
     &     *(el_m(proj_el)+el_m(target_el))/el_m(target_el)

      return
      end

@ Ruzic's fit for the angular dependence of the reflection coefficient.
The input |rn| is assumed to be for normal incidence, polar angle
|theta| = 0; |theta| is assumed to be in degrees. 
An overall upper limit of 0.9 is enforced.

@<Functions...@>=
      function rn_ruzic_fit(rn,theta)
      implicit_none_f77
      implicit_none_f90
      real rn_ruzic_fit,rn,theta       // Input
      real rn_new                      // Local

      rn_new=rn * (one + half * sin(theta / const(57.296)))
      rn_new=min(rn_new,const(0.9))
      rn_ruzic_fit=rn_new

      return
      end

@ Relatively general routine to write several of the really trivial files,
the characteristics of which can be summarized in this short argument list.

@<Functions...@>=
      subroutine pmi_write_misc(tag,yield,v_type,version)
      implicit_none_f77
      pf_common                                      // Common
      implicit_none_f90
      character*LINELEN tag,v_type,version           // Input
      real yield
      integer i,j,k,l,m,n,fileid                     // Local
      character*LINELEN description
      character*FILELEN fileout
      nc_decls
      pf_ncdecl
      @<Memory allocation interface@>
      st_decls 
      pf_decls

      description = 'Data for Plasma-Material Interactions in degas 2'
      pf_version = version

/* Tag is the name here. */
      pf_name=tag

/* 
   Set up everything for first dependent variable
*/
      pf_num_dep_var=1
      pf_var[0,1]='yield'
      pf_rank[1]=0
      
      pf_units[0,1]=' '
      pf_mult[0,1]=one

      pf_eval_name[1]='table'
      pf_spacing[0,1]='linear'

/*
   Assign default values to everything else
*/
      do i=pf_rank[1]+1,pf_table_rank_max
         pf_tab_index[i,1]=1
         pf_var[i,1]='unknown'
         pf_spacing[i,1]='unknown'
         pf_units[i,1]='unknown'
         pf_mult[i,1]=zero
         pf_min[i,1]=zero
         pf_max[i,1]=zero
      end do

      do j=pf_num_dep_var+1,pf_dep_var_max
         pf_rank[j]=1
         pf_eval_name[j]='unknown'
         pf_var[0,j]='unknown'
         pf_spacing[0,j]='unknown'
         pf_units[0,j]='unknown'
         pf_mult[0,j]=zero
         do i=1,pf_table_rank_max
            pf_tab_index[i,j]=1
            pf_var[i,j]='unknown'
            pf_spacing[i,j]='unknown'
            pf_units[i,j]='unknown'
            pf_mult[i,j]=zero
            pf_min[i,j]=zero
            pf_max[i,j]=zero
         end do
      end do

/*
   Second dependent variable (fit)
*/
      if (v_type != 'none') then
         pf_num_dep_var=2
         pf_var[0,2]='velocity_vector'
         pf_rank[2]=0
         pf_eval_name[2]=v_type
      end if

/*
   Can now reallocate |pf_data_table| \ldots
*/
      pf_ragged_alloc(pf_data,pf_tab_index)
      
      pf_data_table(0,0,0,0,0,1)=yield

      do n=pf_num_dep_var+1,pf_dep_var_max
         do m=0,pf_tab_index[5,n]-1
            do l=0,pf_tab_index[4,n]-1
               do k=0,pf_tab_index[3,n]-1
                  do j=0,pf_tab_index[2,n]-1
                     do i=0,pf_tab_index[1,n]-1
                        pf_data_table(i,j,k,l,m,n)=real_unused
                     end do
                  end do
               end do
            end do
         end do
      end do
/*
   Write netCDF file and close everything up
*/

      fileout='./'\/trim(pf_name)\/'.nc'
      fileid = nccreate(fileout,NC_CLOBBER,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'description',NC_CHAR,
     $     string_length(description),
     $     description,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'data_version',NC_CHAR,
     $     string_length(pf_version),
     $     pf_version,nc_stat)
      
      pf_ncdef(fileid)
      call ncendef(fileid,nc_stat)
      pf_ncwrite(fileid)

      var_free(pf_data_tab)

      call ncclose(fileid,nc_stat)

      return
      end

@ Mirror process.

@<Functions...@>=
      subroutine pmi_write_mirror(tag,version)
      implicit_none_f77
      pf_common                                      // Common
      implicit_none_f90
      character*LINELEN tag,version                  // Input
      integer i,j,k,l,m,n,fileid                     // Local
      character*LINELEN description
      character*FILELEN fileout
      nc_decls
      st_decls 
      pf_decls
      pf_ncdecl
      @<Memory allocation interface@>

      description = 'Data for Plasma-Material Interactions in degas 2'
      pf_version = version

/* Tag is the name here. */
      pf_name=tag

/* 
   Set up everything for first dependent variable
*/
      pf_num_dep_var=1
      pf_var[0,1]='yield'
      pf_rank[1]=0
      
      pf_units[0,1]=' '
      pf_mult[0,1]=one

      pf_eval_name[1]='table'
      pf_spacing[0,1]='linear'

/*
   Assign default values to everything else
*/
      do i=pf_rank[1]+1,pf_table_rank_max
         pf_tab_index[i,1]=1
         pf_var[i,1]='unknown'
         pf_spacing[i,1]='unknown'
         pf_units[i,1]='unknown'
         pf_mult[i,1]=zero
         pf_min[i,1]=zero
         pf_max[i,1]=zero
      end do

      do j=pf_num_dep_var+1,pf_dep_var_max
         pf_rank[j]=1
         pf_eval_name[j]='unknown'
         pf_var[0,j]='unknown'
         pf_spacing[0,j]='unknown'
         pf_units[0,j]='unknown'
         pf_mult[0,j]=zero
         do i=1,pf_table_rank_max
            pf_tab_index[i,j]=1
            pf_var[i,j]='unknown'
            pf_spacing[i,j]='unknown'
            pf_units[i,j]='unknown'
            pf_mult[i,j]=zero
            pf_min[i,j]=zero
            pf_max[i,j]=zero
         end do
      end do

/*
   Second dependent variable (fit)
*/
      pf_num_dep_var=2
      pf_var[0,2]='velocity_vector'
      pf_units[0,2]=' '
      pf_rank[2]=1
      pf_eval_name[2]='specular'
      pf_var[1,2]='polar_angle_in'
      pf_units[1,2]=' '
/*
   Third dependent variable (table)
*/
      pf_num_dep_var=3
      pf_var[0,3]='energy_out'
      pf_rank[3]=1
      pf_tab_index[1,3]=2
      pf_eval_name[3]='table'
      pf_units[0,3]='eV'
      pf_mult[0,3]=electron_charge
      pf_spacing[0,3]='linear'
      pf_var[1,3]='energy_in'
      pf_units[1,3]='eV'
      pf_mult[1,3]=electron_charge
      pf_spacing[1,3]='linear'
      pf_min[1,3]=zero
      pf_max[1,3]=const(1.,5)

/*
   Can now reallocate |pf_data_table| \ldots
*/
      pf_ragged_alloc(pf_data,pf_tab_index)
      
      pf_data_table(0,0,0,0,0,1)=one

      pf_data_table(0,0,0,0,0,3)=pf_min[1,3]   // ``$E_{out} = E_{in}$''
      pf_data_table(1,0,0,0,0,3)=pf_max[1,3]

      do n=pf_num_dep_var+1,pf_dep_var_max
         do m=0,pf_tab_index[5,n]-1
            do l=0,pf_tab_index[4,n]-1
               do k=0,pf_tab_index[3,n]-1
                  do j=0,pf_tab_index[2,n]-1
                     do i=0,pf_tab_index[1,n]-1
                        pf_data_table(i,j,k,l,m,n)=real_unused
                     end do
                  end do
               end do
            end do
         end do
      end do
/*
   Write netCDF file and close everything up
*/

      fileout='./'\/trim(pf_name)\/'.nc'
      fileid = nccreate(fileout,NC_CLOBBER,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'description',NC_CHAR,
     $     string_length(description),
     $     description,nc_stat)

      call ncattputc(fileid,NC_GLOBAL,'data_version',NC_CHAR,
     $     string_length(pf_version),
     $     pf_version,nc_stat)
      
      pf_ncdef(fileid)
      call ncendef(fileid,nc_stat)
      pf_ncwrite(fileid)

      var_free(pf_data_tab)

      call ncclose(fileid,nc_stat)

      return
      end

@* References.

\bibliographystyle{report}
\bibliography{../../degas}

@* Index.

