% $Id: b74637c9c1c7c6a2641b28f6a06a3dae625652d6 $
\Title{score}

@* Routines to do scoring.

\ID{$Id: b74637c9c1c7c6a2641b28f6a06a3dae625652d6 $}

@m FILE 'score.web'

@m STARK 0

@m max_segments 60000

@I macros.hweb
@I sysdep.hweb
@I particle.hweb
@I problem.hweb
@I tally.hweb
@I output.hweb
@I stat.hweb
@I species.hweb
@I sector.hweb
@I detector.hweb
@I location.hweb
@I geomint.hweb
@I random.hweb
@I xsection.hweb
@I string.hweb
@I reactiondata.hweb
@I flight.hweb
@I reaction.hweb
@I materials.hweb
@I pmi.hweb
@I sources.hweb
@I background.hweb
@I zone.hweb
@I snapshot_pdf.hweb

@ The main program

@a
      @<Functions and subroutines@>

@ Handle scores of type ``test''.

@<Functions...@>=
      subroutine score_test(est,est_fac,pt_dummy(p),estimator_factors)

      implicit_none_f77
      pr_common                                        // Common
      tl_common
      implicit_none_f90

      tl_decls
      integer est                                      // Input
      real est_fac
      pt_decl(p)

      integer i,jscore,pr_reac                         // Local
      real scoring_data[scoring_data_max]
      real estimator_factors[*]                        // Scratch
      logical need_scores

      @<Memory allocation interface@>

      need_scores=.false.
      do i=1,tally_type_num[tl_type_test]
         jscore=tally_type_base[tl_type_test]+i-1
         estimator_factors[jscore]=tally_est_test[jscore][est]*est_fac*pt_w(p)
         if (estimator_factors[jscore] > zero) then
            need_scores=.true.
         end if
      end do

      if (need_scores) then

         do i=1,scoring_data_max
            scoring_data[i]=zero
         end do

         call test_scoring_data(pt_args(p),scoring_data)

         pr_reac=0
         call add_scores(tl_type_test,pt_args(p),pr_reaction_args(pr_reac),
     $        scoring_data,estimator_factors)
      end if

      if (est == tl_est_snapshot) call build_snapshot_pdf(pt_args(p))

      return
      end

@ Fill in |scoring_data| for test species.

@<Functions...@>=
      subroutine test_scoring_data(pt_dummy(p),scoring_data)

      implicit_none_f77
      sp_common                                     // Common
      implicit_none_f90

      pt_decl(p)                                    // Input
      real scoring_data[scoring_data_max]           // Output

      scoring_data[pr_var_mass]=sp_m(pt_sp(p))
      scoring_data[pr_var_momentum_vector]=sp_m(pt_sp(p))*pt_v(p)[1]
      scoring_data[pr_var_momentum_2]=sp_m(pt_sp(p))*pt_v(p)[2]
      scoring_data[pr_var_momentum_3]=sp_m(pt_sp(p))*pt_v(p)[3]
      scoring_data[pr_var_energy]=half*sp_m(pt_sp(p))*vc_abs2(pt_v(p))
      scoring_data[pr_var_xy_stress]=sp_m(pt_sp(p))*pt_v(p)[1]*pt_v(p)[2]

      return
      end

@ Handle scores at diagnostic sectors.

@<Functions...@>=
      subroutine score_diagnostics(nprod,pt_dummy(prod),estimator_factors)

      implicit_none_f77
      pr_common                                        // Common
      tl_common
      gi_common
      sc_common
      implicit_none_f90
      
      tl_decls

      integer nprod                                    // Input
      pt_decl(prod[0:pm_product_max])                 
      real estimator_factors[*]                        // Scratch

      integer i,j,jscore,pr_reac,idiag,i_side,sector,  // Local
     $        surface,count,i_sect,subsector,zone         
      real scoring_data[scoring_data_max]
      logical need_scores

      @<Memory allocation interface@>

      do j=0,nprod
         need_scores=.false.
         do i=1,tally_type_num[tl_type_sector]
            jscore=tally_type_base[tl_type_sector]+i-1
/*
   This was previously in the invocations of |sc_diag_check| below,
   but was wiping out nonzero entries after they had been set.
*/
            estimator_factors[jscore]=zero
            do i_side=1,2
               if (i_side == 1) then
                  sector=lc_sector(pt_loc(prod[j]))
                  zone=lc_zone(pt_loc(prod[j]))
               else if (i_side == 2) then
                  sector=lc_sector_next(pt_loc(prod[j]))
                  zone=lc_zone_next(pt_loc(prod[j]))
               else
                  assert(' You are seriously lost!' == ' ')
               end if
               if (sc_check(sector)) then
                  surface=sector_surface[sector]
                  count=surface_sectors[s_sign(surface),s_count,abs(surface)]
                  assert(count >= 1)
                  do i_sect=1,count
                     subsector=sectors[surface_sectors[s_sign(surface),s_start,abs(surface)]+i_sect-1]
                     idiag=sector_type_pointer[subsector][sc_diagnostic(tally_geometry_ptr[jscore])]
/*
   Disable scores for which direction-dependent dependent variables are 
   going the wrong way for the current pair of sectors (flight is going
   out of |sector| and coming into |sector_next|).
*/
                     if ((sc_diag_check(idiag,tally_geometry_ptr[jscore]) && (sector_zone[subsector] == zone)) 
     $                    && (((i_side == 1) && !((tally_dep_var[jscore] >= pr_var_mass_in) 
     $                                            && (tally_dep_var[jscore] <= pr_var_mass_in+pr_num_diag_vars-1))) 
     $                        || ((i_side == 2) && !((tally_dep_var[jscore] >= pr_var_mass_out) 
     $                                            && (tally_dep_var[jscore] <= pr_var_mass_out+pr_num_diag_vars-1))))) 
     $                    then
                        estimator_factors[jscore]=pt_w(prod[j])
                        need_scores=.true.
                     end if
                  end do      // |i_sect|
               end if         // |sc_check(sector)|
            end do            // |i_side|
         end do               // |i|

         if (need_scores) then

            do i=1,scoring_data_max
               scoring_data[i]=zero
            end do

            call sector_scoring_data(pt_args(prod[j]),scoring_data)

            pr_reac=0
            call add_scores(tl_type_sector,pt_args(prod[j]),pr_reaction_args(pr_reac),
     $           scoring_data,estimator_factors)
         end if
      end do  // Over |j|

      return
      end

@ Fill in |scoring_data| for sector diagnostics.

@<Functions...@>=
      subroutine sector_scoring_data(pt_dummy(p),scoring_data)

      implicit_none_f77
      sp_common                                     // Common
      sc_common
      pr_common
      implicit_none_f90

      pt_decl(p)                                    // Input
      real scoring_data[scoring_data_max]           // Output

      real cos_angle,cos_angle_next                 // Local
      integer psp

      external intersection_direction               // External
      real intersection_direction      

/* 
   The original set (angle and energy) will still be used for distributions.
*/
      scoring_data[pr_var_mass]=sp_m(pt_sp(p))

      if ((sc_check(lc_sector(pt_loc(p)))) && sc_check(lc_sector_next(pt_loc(p)))) then
         cos_angle=intersection_direction(sector_surface[lc_sector(pt_loc(p))],lc_x(pt_loc(p))[1],
     $     pt_v(p)[1])
         cos_angle_next=intersection_direction(sector_surface[lc_sector_next(pt_loc(p))],lc_x(pt_loc(p))[1],
     $     pt_v(p)[1])
/*
   Since these should be two sides of the same surface, the results of 
   |intersection_direction| should have opposite sign.  Since the
   orientation of the flight relative to the sector is handled via the
   diagnostic's dependent variable, we can take the absolute value
   (use this for the single sector cases also).
*/
         assert(cos_angle + cos_angle_next < geom_epsilon)
         cos_angle=abs(cos_angle)
      else if (sc_check(lc_sector(pt_loc(p)))) then
         cos_angle=abs(intersection_direction(sector_surface[lc_sector(pt_loc(p))],lc_x(pt_loc(p))[1],
     $     pt_v(p)[1]))
      else if (sc_check(lc_sector_next(pt_loc(p)))) then
         cos_angle=abs(intersection_direction(sector_surface[lc_sector_next(pt_loc(p))],lc_x(pt_loc(p))[1],
     $     pt_v(p)[1]))
      else
         assert(' No valid sector in sector_scoring_data!' == ' ')
      end if
      scoring_data[pr_var_angle]=acos(cos_angle)

      scoring_data[pr_var_energy]=half*sp_m(pt_sp(p))*vc_abs2(pt_v(p))

/*
   We originally thought to enforce the directionality here by zeroing
   one or the other set of data. The better plan turned out to be
   to do this in |score_diagnostics|.
*/
      assert(pr_test_check(pt_test(p)))
      psp=pr_problem_sp_test(pt_test(p))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_out,psp)]=scoring_data[pr_var_mass]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_out_vector,psp)]=sp_m(pt_sp(p))*pt_v(p)[1]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_out_2,psp)]=sp_m(pt_sp(p))*pt_v(p)[2]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_out_3,psp)]=sp_m(pt_sp(p))*pt_v(p)[3]
      scoring_data[pr_var_problem_sp_index(pr_var_energy_out,psp)]=scoring_data[pr_var_energy]

      scoring_data[pr_var_problem_sp_index(pr_var_mass_in,psp)]=scoring_data[pr_var_mass]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_in_vector,psp)]=sp_m(pt_sp(p))*pt_v(p)[1]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_in_2,psp)]=sp_m(pt_sp(p))*pt_v(p)[2]
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_in_3,psp)]=sp_m(pt_sp(p))*pt_v(p)[3]
      scoring_data[pr_var_problem_sp_index(pr_var_energy_in,psp)]=scoring_data[pr_var_energy]

      return
      end

@ Subroutine to score and process a reaction. The arguments here are |p|, 
the particle
index, |ts_reac|, the reaction index into the list of reactions participated
in by the test species corresponding to |p|, |nprod|, the number of products,
|prod|, their corresponding particle tags, and |x|, the current random
number thread. This routine uses |p| to pull together all of the more
specific information required by the lower level routines. The individual
pieces of data about the products they produce are incorporated into 
instances of the particle class.
      
@<Functions...@>=
      subroutine score_reaction(est,est_fac,
     $   pr_reaction_dummy(ts_reac),rate,
     $   nprod,pt_dummy(prod),estimator_factors,rn_dummy(x))

      implicit_none_f77
      sp_common                             // Common
      pr_common
      rc_common
      rd_common
      tl_common
      implicit_none_f90

      rd_decls
      integer est                          // Input
      real est_fac,rate
      pr_reaction_decl(ts_reac)
      integer nprod                        // Output
      pt_decl(prod[0:rc_product_max])
      real estimator_factors[*]            // Scratch
      rn_decl(x)                           // Input/output

      pr_reaction_decl(pr_reac)            // Local
      logical need_scores
      integer i,jscore
      real independent_parameters[xs_max_indep_params],
     $     scoring_data[scoring_data_max]

      st_decls
      @<Memory allocation interface@>

      pr_reac=pr_ts_rc(pt_test(prod[0]),ts_reac)

      need_scores=.false.
      nprod=0
      if (rate == zero) return
      do i=1,tally_type_num[tl_type_reaction]
         jscore=tally_type_base[tl_type_reaction]+i-1
         assert(rate > zero)
         estimator_factors[jscore]=tally_est_reaction[jscore][est][pr_reac]
     $        *pt_w(prod[0])*est_fac
         if (estimator_factors[jscore] > zero) then
            need_scores=.true.
         end if
      end do

      if (need_scores || est == tl_est_collision) then
         do i=1,scoring_data_max
            scoring_data[i]=zero
         end do

         call set_indep_params(pt_args(prod[0]),
     $        pr_background_args(pr_ts_bk(pt_test(prod[0]),ts_reac)),
     $        reaction_handling_num_rand[pr_reac],
     $        rn_args(x),independent_parameters)

         if (est == tl_est_track || est == tl_est_post_process) then
            call pick_track_reaction(pr_test_args(pt_test(prod[0])),
     $           pr_reaction_args(ts_reac),rate,independent_parameters,
     $           scoring_data,rn_args(x))
         else if (est == tl_est_collision) then
            call pick_reaction(pr_test_args(pt_test(prod[0])),
     $           pr_reaction_args(ts_reac),rate,independent_parameters,
     $           nprod,sp_args(pt_sp(prod[1])),vc_args(pt_v(prod[1])),
     $           pt_w(prod[1]),scoring_data,rn_args(x))
         else
            assert('Unsupported estimator' == ' ')
         end if

         call add_scores(tl_type_reaction,pt_args(prod[0]),
     $        pr_reaction_args(pr_ts_rc(pt_test(prod[0]),ts_reac)),
     $        scoring_data,estimator_factors)
      end if

/*
   Create particle instances from products. 
*/
      if (nprod > 0) then
         do i=1,nprod
            pt_test(prod[i])=pr_test_lookup(pt_sp(prod[i]))
            lc_copy(pt_loc(prod[0]),pt_loc(prod[i]))
            pt_t(prod[i])=pt_t(prod[0])
            pt_w(prod[i])=pt_w(prod[0])*pt_w(prod[i])
            pt_author_rc(prod[i],pr_reac)
            if (sp_z(pt_sp(prod[i])) == 0) then
               pt_type(prod[i])=pt_neutral
            else
               pt_type(prod[i])=pt_ion
            end if
         end do
      end if

      return
      end

@ Set up scoring data for puff source. This routine is analogous to the
collision routines. 

@<Functions...@>=
      subroutine puff_data(est,fl_dummy(x),scoring_data)

      implicit_none_f77
      sp_common
      pr_common
      sc_common
      implicit_none_f90

      integer est                                // Input
      fl_decl(x)

      real scoring_data[scoring_data_max]         // Output

      integer psp                                 // Local
      real vpuff,energy
      sp_decl(sptest)
      vc_decl(vcos)
      vc_decl(vsrc)

      sptest=pt_sp(fl_current(x))
      if (est == tl_est_post_process) then
         vpuff=const(3.)
         vc_set(vcos,zero,zero,const(8.)/(const(3.)*sqrt(const(6.)*PI)))
         call puff_v_details(fl_source(x),fl_source_xseg(x),
     $               fl_source_kseg(x),lc_args(pt_loc(fl_current(x))),
     $               vpuff,vc_args(vcos),vc_args(vsrc),energy)
      else if (est == tl_est_collision) then
         vc_copy(pt_v(fl_current(x)),vsrc)
         energy=half*sp_m(sptest)*vc_abs2(vsrc)
      else 
         assert('Incorrect value of est' == ' ')
      end if
      psp=pr_problem_sp_test(pt_test(fl_current(x)))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp)]+=
     $  sp_m(sptest)
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp)]+=
     $     sp_m(sptest)*vsrc[1] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp)]+=
     $     sp_m(sptest)*vsrc[2] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp)]+=
     $     sp_m(sptest)*vsrc[3] 
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp)]+=
     $     energy
      
      return
      end

@ Scoring data for plate source.  This also handles the plate source
with binned energy distribution.

@<Functions...@>=
      subroutine plate_data(est,fl_dummy(x),scoring_data)

      implicit_none_f77
      sp_common
      pr_common
      implicit_none_f90

      integer est                        // Input
      fl_decl(x)

      real scoring_data[scoring_data_max]         // Output

      integer psp_1,psp_2,type                    // Local
      real wa,energy
      sp_decl(spion)
      sp_decl(sptest)
      vc_decl(vsrc)

      spion=fl_source_root_sp(x)
      type=fl_source_type(x)
      if (est == tl_est_post_process) then
/*
   The current assumption is that the ion velocity is directed
   normally at the plate. Hence, need do nothing special here with
   |vsrc|. However, if a more detailed model is invoked, an appropriate
   average velocity expression needs to be used here.
*/
         if (type == so_plate) then
            wa=const(3.)
            call plate_v_details(fl_source(x),fl_source_xseg(x),
     $               fl_source_kseg(x),lc_args(pt_loc(fl_current(x))),
     $               wa,vc_args(vsrc),energy)
         else if (type == so_plt_e_bins) then
            wa=real_unused // Tells it to compute |energy| from distribution.
            call plt_e_bins_v_details(fl_source(x),fl_source_xseg(x),
     $               fl_source_kseg(x),lc_args(pt_loc(fl_current(x))),
     $               wa,vc_args(vsrc),energy)
         else
            assert('Unexpected value of isource' == ' ')
         end if
      else if (est == tl_est_collision) then
         vc_copy(pt_v(fl_current(x)),vsrc)
         energy=half*sp_m(pt_sp(fl_current(x)))*vc_abs2(vsrc)
      else 
         assert('Incorrect value of est' == ' ')
      end if
      psp_1=pr_problem_sp_back(pr_background_lookup(spion))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_1)]+=
     $  -sp_m(spion)
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_1)]+=
     $     -sp_m(spion)*vsrc[1] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_1)]+=
     $     -sp_m(spion)*vsrc[2] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_1)]+=
     $     -sp_m(spion)*vsrc[3] 
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_1)]+=
     $     -energy

      sptest=pt_sp(fl_current(x))
      psp_2=pr_problem_sp_test(pt_test(fl_current(x)))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp_2)]+=
     $  sp_m(sptest)
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp_2)]+=
     $     sp_m(sptest)*vsrc[1] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp_2)]+=
     $     sp_m(sptest)*vsrc[2] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp_2)]+=
     $     sp_m(sptest)*vsrc[3] 
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp_2)]+=
     $     energy
      
      return
      end

@ Set up scoring data for volume source. This routine is analogous to the
collision routines. 

@<Functions...@>=
      subroutine vol_source_data(est,fl_dummy(x),scoring_data)

      implicit_none_f77
      sp_common
      pr_common
      implicit_none_f90

      integer est                                // Input
      fl_decl(x)

      real scoring_data[scoring_data_max]         // Output

      integer psp                                 // Local
      real temp,energy
      sp_decl(sptest)
      vc_decl(v_gauss)
      vc_decl(vsrc)

      sptest=pt_sp(fl_current(x))
      if (est == tl_est_post_process) then
         vc_set(v_gauss,zero,zero,zero)
         call vol_source_v_details(fl_source(x),fl_source_xseg(x),
     $        fl_source_kseg(x),lc_args(pt_loc(fl_current(x))),
     $        vc_args(v_gauss),vc_args(vsrc),temp)
         energy=const(1.5)*temp+half*sp_m(sptest)*vc_abs2(vsrc)
      else if (est == tl_est_collision) then
         vc_copy(pt_v(fl_current(x)),vsrc)
         energy=half*sp_m(sptest)*vc_abs2(vsrc)
      else 
         assert('Incorrect value of est' == ' ')
      end if
      psp=pr_problem_sp_test(pt_test(fl_current(x)))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp)]+=
     $  sp_m(sptest)
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp)]+=
     $     sp_m(sptest)*vsrc[1] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp)]+=
     $     sp_m(sptest)*vsrc[2] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp)]+=
     $     sp_m(sptest)*vsrc[3] 
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp)]+=
     $     energy
      
      return
      end

@ Scoring data for snapshot source.  An approach to post-process scoring
remains to be established.

@<Functions...@>=
      subroutine snapshot_data(est,fl_dummy(x),scoring_data)

      implicit_none_f77
      sp_common
      pr_common
      implicit_none_f90

      integer est                                // Input
      fl_decl(x)

      real scoring_data[scoring_data_max]         // Output

      integer psp                                 // Local
      real energy
      sp_decl(sptest)
      vc_decl(vsrc)

      sptest=pt_sp(fl_current(x))
      if (est == tl_est_post_process) then
         assert('Snapshot source cannot be post-processed' == ' ')
      else if (est == tl_est_collision) then
         vc_copy(pt_v(fl_current(x)),vsrc)
         energy=half*sp_m(sptest)*vc_abs2(vsrc)
      else 
         assert('Incorrect value of est' == ' ')
      end if
      psp=pr_problem_sp_test(pt_test(fl_current(x)))
      scoring_data[pr_var_problem_sp_index(pr_var_mass_change,psp)]+=
     $  sp_m(sptest)
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_vector,psp)]+=
     $     sp_m(sptest)*vsrc[1] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_2,psp)]+=
     $     sp_m(sptest)*vsrc[2] 
      scoring_data[pr_var_problem_sp_index(pr_var_momentum_change_3,psp)]+=
     $     sp_m(sptest)*vsrc[3] 
      scoring_data[pr_var_problem_sp_index(pr_var_energy_change,psp)]+=
     $     energy
      
      return
      end

@ Loop through and fill all of the scores of this type.    
The geometry segments may be: a zone, a (diagnostic) sector, or a detector.
Since more than one detector may be affected by this reaction, this routine
actually returns an array |segments|. Likewise, in the simulation of certain
detectors (e.g., spectrometers), it might be desirable to score signals on
more than one scoring bin. Again, the affected bins are in an array |bins|.

@<Functions...@>=
      subroutine add_scores(type,pt_dummy(p),
     $   pr_reaction_dummy(pr_reac),scoring_data,estimator_factors)

      implicit_none_f77
      pr_common
      tl_common
      sc_common
      zn_common
      implicit_none_f90
      
      tl_decls
      st_decls

      integer type                               // Input
      pt_decl(p)
      pr_reaction_decl(pr_reac)
      real scoring_data[scoring_data_max],estimator_factors[*]

                                                 // Local
      integer i,j,k,jscore,problem_sp,number_segments,geom_seg_label,geom_seg,
     $     bin_label,ibin,problem_sp_min,problem_sp_max,j_tl_cv,icv
      integer index_parameters[tl_index_unknown:tl_index_max],
     $     segments[max_segments],ind_val[tl_rank_max],
     $     number_bins[max_segments],bins[max_segments][max_bins] 
      real check_data
      real geom_mult[max_segments][max_bins],
     $     converted_data[scoring_data_max]
      logical need_track_conversions

      @<Memory allocation interface@>

      do i=tl_index_unknown,tl_index_max
         index_parameters[i]=0
      end do

      index_parameters[tl_index_test]=pt_test(p)
      index_parameters[tl_index_test_author]=pt_author(p)
      index_parameters[tl_index_reaction]=pr_reac
      index_parameters[tl_index_sector]=lc_sector(pt_loc(p))
      index_parameters[tl_index_strata]=strata[lc_sector(pt_loc(p))]
      index_parameters[tl_index_strata_segment]=sector_strata_segment[lc_sector(pt_loc(p))]
      index_parameters[tl_index_zone_ind_1]=zn_index(lc_zone(pt_loc(p)),1)
      index_parameters[tl_index_zone_ind_2]=zn_index(lc_zone(pt_loc(p)),2)

      do i=1,tally_type_num[type]
         jscore=tally_type_base[type]+i-1
         need_track_conversions=.false.
         if (tally_num_conversions[jscore] > 0) then
            do j_tl_cv=1,tally_num_conversions[jscore]
               icv=tally_cv_ptr[jscore][j_tl_cv]
               if (tally_cv_type[icv] == tl_cv_track) 
     $              need_track_conversions=.true.
            end do
         end if
/*
   Determine whether or not |jscore| has a dependence on the background
   species. Also, see if the value of the dependent variable in 
   |scoring_data| is non-zero. 
*/
         check_data=zero
         if (tally_dep_var[jscore] >= pr_var_mass_change
     $        && tally_dep_var[jscore] <= pr_var_mass_change+pr_num_change_vars-1)
     $        then
            problem_sp_min=1
            problem_sp_max=pr_background_num+pr_test_num
            do problem_sp=1,pr_background_num+pr_test_num
               index_parameters[tl_index_problem_sp]=problem_sp
               do j=1,tally_dep_var_dim[jscore]
                  check_data+=abs(scoring_data[
     $            tl_scoring_index(tally_dep_var[jscore],j,index_parameters)])
               end do
            end do
         else
            problem_sp_min=0
            problem_sp_max=0
            index_parameters[tl_index_problem_sp]=0
            do j=1,tally_dep_var_dim[jscore]
               check_data+=abs(scoring_data[
     $           tl_scoring_index(tally_dep_var[jscore],j,index_parameters)])
            end do
         end if

         if (estimator_factors[jscore]*check_data > zero) then

            call handle_geometry(pt_args(p),tally_geometry[jscore],
     $           tally_geometry_ptr[jscore],tally_dep_var[jscore],
     $           scoring_data,number_segments,segments,geom_seg_label,
     $           number_bins,bins,bin_label,geom_mult)

            do geom_seg=1,number_segments
               index_parameters[geom_seg_label]=segments[geom_seg]
               do ibin=1,number_bins[geom_seg]
                  index_parameters[bin_label]=bins[geom_seg][ibin]
                  do problem_sp=problem_sp_min,problem_sp_max
                     index_parameters[tl_index_problem_sp]=problem_sp
                     do k=1,tl_rank_max
                        if (k <= tally_rank[jscore]) then
                           ind_val[k]
     $                        =index_parameters[tally_indep_var[jscore][k]]-1
                           assert(ind_val[k] >= 0 
     $                          && ind_val[k] < tally_tab_index[jscore][k])
                        else
                           ind_val[k]=0
                        end if
                     end do
/*
   The calls to |track_conversion| end up being numerous and, thus,
   expensive.  One of the reasons is that it copies |scoring_data|
   to |converted_data| in all cases.  Work around this by first
   identifying (above) the scores that actually have a track conversion
   and then use a separate call to |set_comp_scores| in the two cases.
*/
                     if (need_track_conversions) then 
                        call track_conversions(tl_args(jscore),pt_args(p),
     $                    index_parameters,scoring_data,converted_data)
                        do j=1,tally_dep_var_dim[jscore]
                           call set_comp_scores(
     $                          out_array_index(j,ind_val,jscore),
     $                          converted_data[
     $             tl_scoring_index(tally_dep_var[jscore],j,index_parameters)]
     $                       *geom_mult[geom_seg][ibin]
     $                       *estimator_factors[jscore])
                        end do 
                     else
                        do j=1,tally_dep_var_dim[jscore]
                           call set_comp_scores(
     $                          out_array_index(j,ind_val,jscore),
     $                          scoring_data[
     $             tl_scoring_index(tally_dep_var[jscore],j,index_parameters)]
     $                       *geom_mult[geom_seg][ibin]
     $                       *estimator_factors[jscore])
                        end do 
                     end if
                  end do  // |problem_sp|
               end do     // |ibin|
            end do        // |geom_seg|
         end if
      end do              // |jscore|

      return
      end

@ Set compressed score arrays. 

@<Functions...@>=
      subroutine set_comp_scores(ifull,datum)

      implicit_none_f77
      sa_common
      implicit_none_f90

      integer ifull                             // Input
      real datum
      integer ishort                            // Local
      
      @<Memory allocation interface@>

      if (datum == zero) return

      if (stat_comp_flt == TRUE) then
         if (stat_ptr2short_flt[ifull] == int_uninit) then
            stat_size_flt++
            if (stat_size_flt > stat_dim_flt) then
               var_realloc(stat_flt,stat_dim_flt-1,stat_dim_flt+stat_mem_inc_flt-1)
               var_realloc(stat_ptr2full_flt,stat_pf_dim_flt-1,stat_pf_dim_flt+stat_mem_inc_flt-1)
               stat_dim_flt+=stat_mem_inc_flt
               stat_pf_dim_flt+=stat_mem_inc_flt
            end if
            ishort=stat_size_flt-1
            stat_ptr2full_flt[ishort]=ifull
            stat_ptr2short_flt[ifull]=ishort
            stat_flt[ishort][o_mean]=zero
            stat_flt[ishort][o_var]=zero
         else
            ishort=stat_ptr2short_flt[ifull]
         end if
      else
         ishort=ifull
      end if
      stat_flt[ishort][o_mean]+=datum

      return
      end

@ Determine which (one or more) geometrical elements are involved in this
score. Set also the ``bin'' numbers associated with any independent variable
tracked by those elements.

@<Functions...@>=
      subroutine handle_geometry(pt_dummy(p),geometry,
     $     pointer,dep_var,scoring_data,number_segments,segments,
     $     geom_seg_label,number_bins,bins,bin_label,geom_mult)

      implicit_none_f77
      pr_common
      tl_common
      implicit_none_f90
      
      tl_decls

      pt_decl(p)                                   // Input
      integer geometry,pointer,dep_var
      real scoring_data[scoring_data_max]

                                                   // Output
      integer number_segments,geom_seg_label,bin_label
      integer segments[max_segments],number_bins[max_segments],
     $     bins[max_segments][max_bins]
      real geom_mult[max_segments][max_bins]

      number_segments=0
      segments[1]=0
      if (geometry == tl_geom_volume) then
         number_segments=1
         segments[1]=lc_zone(pt_loc(p))
         geom_seg_label=tl_index_zone
         number_bins[1]=1
         bins[1][1]=0
         bin_label=tl_index_unknown
         geom_mult[1][1]=one
      else if (geometry == tl_geom_detector) then
         call handle_detectors(pt_args(p),pointer,dep_var,
     $        scoring_data,number_segments,segments,
     $        number_bins,bins,bin_label,geom_mult)
         geom_seg_label=tl_index_detector
      else if (geometry == tl_geom_surface) then
         call handle_diagnostics(pt_args(p),pointer,dep_var,
     $        scoring_data,number_segments,segments,
     $        number_bins,bins,bin_label,geom_mult)
         geom_seg_label=tl_index_diagnostic
      else
         assert("Untreated scoring geometry" == " ")
      end if

      return
      end

@ Determine which detectors (one or more) are involved in this score. The
only independent variable tracked on these detectors presently is the
wavelength of emissions. 

@<Functions...@>=
      subroutine handle_detectors(pt_dummy(p),pointer,dep_var,
     $   scoring_data,number_segments,segments,
     $   number_bins,bins,bin_label,geom_mult)

      implicit_none_f77
      zn_common
      de_common                                       // Common
      pr_common
      bk_common
      tl_common
      implicit_none_f90
      
      pt_decls
      tl_decls

      pt_decl(p)                                              // Input
      integer pointer,dep_var
      real scoring_data[scoring_data_max]

      integer number_segments,bin_label                       // Output
      integer segments[max_segments],number_bins[max_segments],
     $     bins[max_segments][max_bins]
      real geom_mult[max_segments][max_bins]

      integer de_group,iview,i,ibin,num_lines,i_e_rate,       // Local
     $        i_line,zone,ifrag,inum
      integer lines[pr_max_lines],e_rates[pr_max_lines]
      real lambda0,lambda,lambda_f,dl,vth,delta_l_th,f,density,delta_l_st,
     $     x_voigt,y_voigt,zone_frag
      character*tl_tag_length line
      vc_decl(v)
      logical init
      
      lc_decls
      st_decls

      external find_lambda,voigt                               // External
      real find_lambda,voigt

      save init,num_lines,lines,e_rates
      data init/.true./

      if (init) then
         num_lines=0
         do i=1,pr_var0_num
            if (pr_var0_list[i]SP(1:10) == 'wavelength') then
               num_lines++
               lines[num_lines]=i
               line=pr_var0_list[i]SP(11:)
               i_e_rate=string_lookup('emission_rate'\/line,
     $              pr_var0_list,pr_var0_num)
               assert(i_e_rate > 0)
               e_rates[num_lines]=i_e_rate
            end if
         end do
         init=.false.
      end if

      de_group=pointer
      number_segments=0
      
      i_line=int_lookup(dep_var,e_rates,num_lines)
/*
   Should we check to see if |scoring_data[dep_var]| $\neq$ 0?
*/
      assert(i_line > 0)
      if (detector_var[de_group] == de_var_wavelength) then
         bin_label=tl_index_wavelength_bin
/*
   Only two options currently: single particle and Maxwellian profile.
   Determine if latter is being used by magnitude of |vth|. If additional
   options are added, analogous critical parameters will need to be used
   as flags to indicate which option is needed for this |dep_var|.
*/
         if (scoring_data[pr_var_emitter_vth_Maxwell] > zero) then
            vth=scoring_data[pr_var_emitter_vth_Maxwell]
            v[1]=scoring_data[pr_var_emitter_vf_Maxwell_vector]
            v[2]=scoring_data[pr_var_emitter_vf_Maxwell_2]
            v[3]=scoring_data[pr_var_emitter_vf_Maxwell_3]
         else
            vth=zero
            v[1]=scoring_data[pr_var_emitter_v_vector]
            v[2]=scoring_data[pr_var_emitter_v_2]
            v[3]=scoring_data[pr_var_emitter_v_3]
            assert(vc_abs(v) > zero)
         end if
         lambda0=scoring_data[lines[i_line]]
         assert(lambda0 > zero)
      else
         bin_label=tl_index_unknown
       end if

      density=bk_n(1,lc_zone(pt_loc(p)))       // electron density
      if (density < const(1.,20)) then
         delta_l_st=const(0.1)*(density/const(1.,20))
      else if (density < const(1.,21)) then
         delta_l_st=const(0.1)+(const(0.4)/const(9.))*(density/const(1.,20)-one)
      else if (density < const(1.,22)) then
         delta_l_st=const(0.5)+(const(1.9)/const(9.))*(density/const(1.,21)-one)
      else
         delta_l_st=const(2.4)
      end if
      delta_l_st*=const(1.,-10)    // from Angstroms to meters
      zone=lc_zone(pt_loc(p))
      do i=1,detector_num_views[de_group]
         iview=de_view_pointer(i,de_group)
/*
   Check |de_zone_frags|
*/
         zone_frag=zero
         if ((zone >= de_zone_frags_min_zn[iview])
     $        && (zone <= de_zone_frags_max_zn[iview])) then
            assert(de_zone_frags_num[iview] > 0)
            do inum=1,de_zone_frags_num[iview]
               ifrag=de_zone_frags_start[iview] + (inum-1)
               if (zone == de_zone_frags_zones[ifrag]) then
                  zone_frag=de_zone_frags[ifrag]
                  go to break
               end if
            end do
break:      continue            
         end if
         if (zone_frag != zero) then
            number_segments++
            assert(number_segments <= max_segments)
            segments[number_segments]=i
            if (detector_var[de_group] == de_var_wavelength) then
/*
   Single Particle Velocity
*/
               if (vth==zero) then
                  lambda=find_lambda(vc_args(lc_x(pt_loc(p))),vc_args(v),
     $                 vc_args(de_view_points[iview][de_view_start]),lambda0)
@#if !STARK
                  number_bins[number_segments]=1
                  if (detector_spacing[de_group] == de_spacing_log)
     $                 lambda=log(lambda)
                  if (detector_spacing[de_group] == de_spacing_log
     $                 || detector_spacing[de_group] == de_spacing_linear) then
/*
   ``one'' inside ``int()'' $\Rightarrow$ get |lambda| < |detector_min| right.
*/
                      bins[number_segments][1]=int((lambda
     $                      -detector_min[de_group])
     $                    /detector_delta[de_group]+one) 
                  else
                     assert('Unsupported spacing' == ' ')
                  end if
                  if (bins[number_segments][1] > 0 
     $                 && bins[number_segments][1] 
     $                     <= detector_tab_index[de_group]) then
                     geom_mult[number_segments][1]=zone_frag
                  else
                     bins[number_segments][1]=1            
                     geom_mult[number_segments][1]=zero  // Outside bin range: throw out
                  end if
@#else
                  number_bins[number_segments]=detector_tab_index[de_group]
                  assert(number_bins[number_segments] <= max_bins)
                  assert(delta_l_st > zero)
                  do ibin=1,number_bins[number_segments]
                     bins[number_segments][ibin]=ibin
                     lambda_f=detector_min[de_group]
     $                    +(ibin-half)*detector_delta[de_group]
                     assert(detector_spacing[de_group] == de_spacing_linear)
                     dl=detector_delta[de_group]
                     f=(delta_l_st/PI)/((lambda_f-lambda)**2+delta_l_st**2)
                     geom_mult[number_segments][ibin]=f*dl
     $                    *zone_frag
                  end do
@#endif
/*
   Maxwellian Distributed Profile
*/
               else if (vth>zero) then
                  lambda_f=find_lambda(vc_args(lc_x(pt_loc(p))),vc_args(v),
     $                 vc_args(de_view_points[iview][de_view_start]),lambda0)
                  delta_l_th=lambda0*vth/speed_of_light
                  number_bins[number_segments]=detector_tab_index[de_group]
                  assert(number_bins[number_segments] <= max_bins)
                  do ibin=1,number_bins[number_segments]
                     bins[number_segments][ibin]=ibin
                     lambda=detector_min[de_group]
     $                    +(ibin-half)*detector_delta[de_group]
                     if (detector_spacing[de_group] == de_spacing_log) then
                        lambda=exp(lambda)
                        dl=lambda*detector_delta[de_group]
                     else
                        assert(detector_spacing[de_group] == de_spacing_linear)
                        dl=detector_delta[de_group]
                     end if
                     x_voigt=(lambda-lambda_f)/(sqrt(two)*delta_l_th)
@#if !STARK
                     f=exp(-x_voigt^2)
@#else
                     assert(delta_l_st > zero)
                     y_voigt=delta_l_st / (sqrt(two)*delta_l_th)
                     f=voigt(x_voigt,y_voigt)
@#endif
                     f/=(delta_l_th*sqrt(two*PI))
                     geom_mult[number_segments][ibin]=f*dl
     $                    *zone_frag
                  end do
               else
                  assert('Incomplete emitter velocity specification' == ' ')
               end if
            else
               number_bins[number_segments]=1
               bins[number_segments][1]=0
               geom_mult[number_segments][1]=zone_frag
            end if
         end if
      end do

      return
      end
                  
@ Calculate the Doppler-shifted wavelength of a photon emitted from a moving 
body relative to a detector. This code is conceptually identical to that 
employed in the original DEGAS code. 

@<Functions...@>=
      function find_lambda(vc_dummy(x),vc_dummy(v),
     $                 vc_dummy(x0_detector),lambda0)

      implicit_none_f77
      gi_common                               // Common
      implicit_none_f90

      real find_lambda                        // Function
      vc_decl(x)                              // Input
      vc_decl(v)
      vc_decl(x0_detector)
      real lambda0

      real rr,toroidal_angle,vrel             // Local
      vc_decl(vp) 
      vc_decl(xp)
      vc_decl(line_of_sight)

      vc_decls

      if (geometry_symmetry == geometry_symmetry_plane ||
     $     geometry_symmetry == geometry_symmetry_oned) then
         vc_set(xp,x[1],zero,x[3])
         vc_copy(v,vp)
      else if (geometry_symmetry == geometry_symmetry_cylindrical) then
         rr=sqrt(x[1]**2+x[2]**2)
         vc_set(xp,rr,zero,x[3])
         if (x[1] == zero && x[2] == zero) then
            toroidal_angle=half*PI
         else
            toroidal_angle=atan2(x[2],x[1])
            if (toroidal_angle < zero) then
               toroidal_angle+=two*PI
            end if
         end if
         vc_set(vp,v[1]*cos(toroidal_angle)+v[2]*sin(toroidal_angle),
     $        -v[1]*sin(toroidal_angle)+v[2]*cos(toroidal_angle),v[3])
      else
         vc_copy(x,xp)
         vc_copy(v,vp)
      end if
      vc_difference(xp,x0_detector,line_of_sight)
      vc_unit(line_of_sight,line_of_sight)
      vrel=vc_product(vp,line_of_sight)
      find_lambda=lambda0*(one+vrel/speed_of_light)

      return
      end

@ Pick out the sectors involved in this score, and set the independent variable
bins. The treated variables thus far are energy and angle of incicidence.

@<Functions...@>=
      subroutine handle_diagnostics(pt_dummy(p),pointer,dep_var,
     $  scoring_data,number_segments,segments,
     $  number_bins,bins,bin_label,geom_mult)

      implicit_none_f77
      sc_common                                       // Common
      gi_common
      pr_common
      tl_common
      implicit_none_f90
      
      pt_decls
      tl_decls
      
      pt_decl(p)                                      // Input
      integer pointer,dep_var
      real scoring_data[scoring_data_max]

      integer number_segments,bin_label               // Output
      integer segments[max_segments],number_bins[max_segments],
     $     bins[max_segments][max_bins]
      real geom_mult[max_segments][max_bins]

      integer diag_grp,idiag,i_side,sector,           // Local
     $        i_sect,surface,count,subsector,zone      
      real value

      lc_decls

      diag_grp=pointer
      number_segments=0
/*
   Have now modified this to allow for multiple sectors per surface,
   as in |score_diagnostics|.

   Had also thought to enforce directionality here. Opted to do it instead
   in |score_diagnostics| since otherwise this routine might return
   |number_segments| = 0.
*/
      do i_side=1,2
         if (i_side == 1) then
            sector=lc_sector(pt_loc(p))
            zone=lc_zone(pt_loc(p))
         else if (i_side == 2) then
            sector=lc_sector_next(pt_loc(p))
            zone=lc_zone_next(pt_loc(p))
         else
            assert(' You are seriously lost!' == ' ')
         end if
         if (sc_check(sector)) then
            surface=sector_surface[sector]
            count=surface_sectors[s_sign(surface),s_count,abs(surface)]
            assert(count >= 1)
            do i_sect=1,count
               subsector=sectors[surface_sectors[s_sign(surface),s_start,abs(surface)]+i_sect-1]
               idiag=sector_type_pointer[subsector][sc_diagnostic(diag_grp)]
               if (sc_diag_check(idiag,diag_grp) 
     $              && (sector_zone[subsector] == zone)) then
                  number_segments++
                  assert(number_segments <= max_segments)
                  segments[number_segments]=idiag
                  if (diagnostic_var[diag_grp] == sc_diag_energy) then
                     bin_label=tl_index_energy_bin
                     value=scoring_data[pr_var_energy]
                  else if (diagnostic_var[diag_grp] == sc_diag_angle) then
                     bin_label=tl_index_angle_bin
                     value=scoring_data[pr_var_angle]
                  else
                     bin_label=tl_index_unknown
                  end if

                  if (bin_label != tl_index_unknown) then
                     number_bins[number_segments]=1
                     if (diagnostic_spacing[diag_grp] == sc_diag_spacing_log) 
     $                    value=log(value)
                     if (diagnostic_spacing[diag_grp] == sc_diag_spacing_log
     $                    || diagnostic_spacing[diag_grp] == sc_diag_spacing_linear) then
                        bins[number_segments][1]=int((value-diagnostic_min[diag_grp])
     $                       /diagnostic_delta[diag_grp]+one)
                     else
                        assert('Unsupported spacing' == ' ')
                     end if
                     if (bins[number_segments][1] > 0 
     $                    && bins[number_segments][1] 
     $                    <= diagnostic_tab_index[diag_grp]) then
                        geom_mult[number_segments][1]=one
                     else
                        bins[number_segments][1]=1            
                        geom_mult[number_segments][1]=zero  // Outside bin range: throw out
                     end if
                  else
                     number_bins[number_segments]=1
                     bins[number_segments][1]=0
                     geom_mult[number_segments][1]=one
                  end if                                    // |bin_label|
               end if                                       // |sc_diag_check|
            end do                                          // |i_sect|
         end if                                             // |sc_check|
      end do                                                // |i_side|

      return
      end

@ Moved post-processed scores from |flighttest| main routine to here.

@<Functions...@>=
      subroutine post_process_test_scores(is,estimator_factors)

      implicit_none_f77
      zn_common                                         // Common 
      pr_common
      tl_common
      sp_common
      so_common
      sa_common
      implicit_none_f90

      integer is                                        // Input

      real estimator_factors[*]                         // Scratch
      integer jscore,jscore_v,i,j,k,l,m,irank_test,irank_zone,test,zone,
     $        ir,ic,nprod
      integer index_parameters[tl_index_unknown:tl_index_max],
     $        ind_val[tl_rank_max]
      real est_fac,particle_no,rate
      vc_decl(velocity)
      lc_decl(zone_loc)
      pt_decl(fake_prod[0:rc_product_max])
      rn_seed_decl(seed)
      rn_decl(fake_rn)
      
      @<Memory allocation interface@>
      tl_decls
      st_decls
      lc_decls
      rn_decls
      zn_decls

      real find_rate                                      // External
      external find_rate
/*
   Should not need any random numbers at this point, but
   need to initialize to ensure that the random number
   index is reasonable.
*/
      call decimal_to_seed(so_seed_decimal,rn_seed_args(seed))
      rn_init(seed,fake_rn)
/*
   Test particle scores - The procedure here involves going through all of
   the test particle ``densities'' (more precisely, number since the 
   volume is not divided out) and velocities and using them to define 
   a ``fake'' test particle which can be run through the usual reaction
   scoring routines.
*/

      jscore=string_lookup('particle number',tally_name,tl_num)
      jscore_v=string_lookup('neutral flux vector',tally_name,tl_num)
      assert(jscore > 0 && jscore_v > 0)
      assert(tl_rank_max == 5)
      do i=1,tl_rank_max     
         if (tally_indep_var[jscore][i] == tl_index_test) irank_test=i
         if (tally_indep_var[jscore][i] == tl_index_zone) irank_zone=i
         assert(tally_indep_var[jscore][i] == tally_indep_var[jscore_v][i])
      end do

      do m=1,tally_tab_index[jscore][5]
         index_parameters[tally_indep_var[jscore][5]]=m
         ind_val[5]=m-1
         do l=1,tally_tab_index[jscore][4]
            index_parameters[tally_indep_var[jscore][4]]=l
            ind_val[4]=l-1
            do k=1,tally_tab_index[jscore][3]
               index_parameters[tally_indep_var[jscore][3]]=k
               ind_val[3]=k-1
               do j=1,tally_tab_index[jscore][2]
                  index_parameters[tally_indep_var[jscore][2]]=j
                  ind_val[2]=j-1
                  do i=1,tally_tab_index[jscore][1]
                     index_parameters[tally_indep_var[jscore][1]]=i
                     ind_val[1]=i-1

                     test=index_parameters[tl_index_test]
                     assert(pr_test_check(test))
                     zone=index_parameters[tl_index_zone]
                     assert(zn_check(zone))
                     if (zn_type(zone) == zn_plasma) then
                        vc_copy(zone_center[zone],lc_x(zone_loc))
/*
  This can take up huge chunks of time in large geometries and
  is really not needed.  Added |lc_set_b| to set |lc_zone| to |zone|,
  but make everything else trivial (i.e., 0).
*/
@#if 0
                        lc_set_a(zone_loc)
                        assert(lc_zone(zone_loc) == zone)
@#else
                        lc_set_b(zone_loc,zone)
@#endif
                        particle_no=stat_flt[out_array_index(1,ind_val,jscore)][o_mean]
                        do ic=1,tally_dep_var_dim[jscore_v]
@#if 0
/*
   THE DIVIDE NUMBER CONVERSION IS BROKEN - NEEDS TO DIVIDE BY TOTAL
   PARTICLE NUMBER NOT BY NUMBER PER GROUP. DO WITHOUT VELOCITY FOR NOW HERE.
*/
                           velocity[ic]=stat_flt[out_array_index(ic,ind_val,jscore_v)][o_mean]
@#else
                           velocity[ic]=one
@#endif
                        end do

                        pt_init(fake_prod[0],sp_sy(pr_test(test)),is)
                        lc_copy(zone_loc,pt_loc(fake_prod[0]))
                        pt_w(fake_prod[0])=particle_no
                        vc_copy(velocity,pt_v(fake_prod[0]))
                        est_fac=one
                        if (pr_rc_num(pt_test(fake_prod[0])) > 0 
     $                       && (particle_no > 0)) then
                           do ir=1,pr_rc_num(pt_test(fake_prod[0]))
                              rate=find_rate(pt_args(fake_prod[0]),
     $                             pr_background_args(pr_ts_bk(pt_test(fake_prod[0]),ir)),
     $                             pr_reaction_args(pr_ts_rc(pt_test(fake_prod[0]),ir)),
     $                             rn_args(fake_rn))
                              call score_reaction(tl_est_post_process,est_fac,
     $                             pr_reaction_args(ir),rate,
     $                             nprod,pt_args(fake_prod[0]),
     $                             estimator_factors,
     $                             rn_args(fake_rn))
                           end do
                        end if
                     end if
                  end do 
               end do    
            end do       
         end do
      end do

      return
      end

@ Moved post-processed scores from |flighttest| main routine to here. Note:
although it would be nice to call |set_source_v| to set the velocity here
just as we do with |set_source_x|, doing so would lead to erroneous 
energy scores. Namely, on the average $\langle E \rangle \neq
\frac{1}{2} m \langle v \rangle^{2}$, even though this is always 
true instantaneously. Hence, the ``data'' routines called here invoke
the same lower level routines called during the $\vec{v}$ source
computation and return a suitable energy value according to the 
situation.

@<Functions...@>=
      subroutine post_process_source_scores(so_dummy(is),estimator_factors)

      implicit_none_f77
      pr_common                                         // Common
      so_common
      sp_common
      bk_common
      gi_common
      zn_common
      implicit_none_f90

      so_decl(is)                                      // Input

      real estimator_factors[*]                        // Scratch

      integer i,bk_rc_is,seg,seg_tot,kseg,xseg,est     // Local
      pt_decl(fake_pt)
      rn_decl(fake_rn)
      fl_decl(fake_fl)

      @<Memory allocation interface@>
      lc_decls
      rn_decls
      st_decls
/*
   Skip for the snapshot source for now.  Need to fix before public
   release.
*/
      if (so_type(is) == so_snapshot) return
/*
   Similar to above, but the ``fake'' particle now corresponds to the sourced
   species.
*/
      do seg=1,so_nseg(is) 
         seg_tot=so_base(is)+seg-1
         kseg=seg-1
         xseg=source_segment_ptr[so_base(is)+kseg]

         est=tl_est_post_process

         pt_init(fake_pt,sp_sy(so_species(is)),is)
         pt_w(fake_pt)=so_scale(is)*source_current[seg_tot]
         pt_t(fake_pt)=zero  // Not used?
         call set_source_x(est,so_args(is),xseg,kseg,
     $        rn_args(fake_rn),lc_args(pt_loc(fake_pt)))
         if (so_type(is) == so_recomb) then
            bk_rc_is=0
            do i=1,pr_bkrc_num
               if (pr_bkrc_prod(i,1) == so_species(is)) then
                  assert(bk_rc_is == 0)
                  bk_rc_is=i
               end if
            end do
            assert(bk_rc_is != 0)
            v_ext_to_int(lc_x(pt_loc(fake_pt)),
     $           bk_v(pr_background_lookup(so_root_sp(is)),
     $           lc_zone(pt_loc(fake_pt))),pt_v(fake_pt),geometry_symmetry,background_coords)
         else
            vc_set(pt_v(fake_pt),zero,zero,zero)  // Tentative
         end if
/*
   What we need here is slightly different from |fl_init|;
   copy explicitly instead.
*/
         fl_pointer(fake_fl)=1
         pt_copy(fake_pt,fl_current(fake_fl))
         fl_source(fake_fl)=is
         fl_source_kseg(fake_fl)=kseg
         fl_source_xseg(fake_fl)=xseg
         fl_source_type(fake_fl)=so_type(is)
         fl_source_root_sp(fake_fl)=so_root_sp(is)
         call score_sources(est,fl_args(fake_fl),estimator_factors)
      end do      // |is|

      return
      end

      subroutine score_sources(est,fl_dummy(x),estimator_factors)

      implicit_none_f77                          // Common
      pr_common
      tl_common
      implicit_none_f90

      integer est                                // Input
      fl_decl(x)
      real estimator_factors[*]                  // Scratch
      
      integer kseg,xseg,i,jscore,prso_reac,type       // Local
      so_decl(is)
      real scoring_data[scoring_data_max]
      real est_fac
      logical need_scores

      rn_decls
      @<Memory allocation interface@>

      is=fl_source(x)
      kseg=fl_source_kseg(x)
      xseg=fl_source_xseg(x)
      type=fl_source_type(x)

      prso_reac=pr_reaction_num+type
      est_fac=one

      need_scores=.false.
      do i=1,tally_type_num[tl_type_reaction]
         jscore=tally_type_base[tl_type_reaction]+i-1
         estimator_factors[jscore]=tally_est_reaction[jscore][est][prso_reac]
     $        *pt_w(fl_current(x))*est_fac
         if (estimator_factors[jscore] > zero) then
            need_scores=.true.
         end if
      end do

      if (need_scores) then
         do i=1,scoring_data_max
            scoring_data[i]=zero
         end do

         if (type == so_recomb) then
            call recombination_data(est,fl_args(x),scoring_data)
         else if ((type == so_plate) 
     $           || (type == so_plt_e_bins)) then
            call plate_data(est,fl_args(x),scoring_data)
         else if (type == so_puff) then
            call puff_data(est,fl_args(x),scoring_data)
         else if (type == so_vol_source) then
            call vol_source_data(est,fl_args(x),scoring_data)
         else if (type == so_snapshot) then
            call snapshot_data(est,fl_args(x),scoring_data)
         end if
         call add_scores(tl_type_reaction,pt_args(fl_current(x)),prso_reac,
     $        scoring_data,estimator_factors)

      end if      // |need_scores|
      
      return
      end

@ Load data for a single particle into the snapshot arrays.

@<Functions...@>=
      subroutine build_snapshot_pdf(pt_dummy(p))

      implicit_none_f77
      sn_common                                  // Common
      sa_common
      zn_common
      implicit_none_f90

      pt_decl(p)                                 // Input

      @<Memory allocation interface@>

      if (!((zn_type(lc_zone(pt_loc(p))) == zn_plasma)
     $     || (zn_type(lc_zone(pt_loc(p))) == zn_vacuum))) then
         write(stdout,*) lc_x(pt_loc(p))[1],
     $   lc_x(pt_loc(p))[2],lc_x(pt_loc(p))[3]
         assert(' Bad snapshot particle' == ' ')
      end if
      sn_number_particles++
      if (sn_number_particles > sn_particles_dim) then
         sn_particles_dim=max(sn_particles_dim,sn_number_particles)
         var_realloca(sn_particles_float)
         var_realloca(sn_particles_int)
/*
   This macro resets |sn_particles_dim| to the actual dimension of the
   arrays as allocated by |var_realloca|.  See also corresponding comment
   in |slave_receive_flights|.
*/
         sn_particles_dim=last_ubounda(sn_particles_float)
      end if
/*
   The order of these statements is not random, but corresponds to that in 
   |pt_decl| and |lc_decl|.
*/
      sn_particles_int[sn_number_particles][sn_int_pt_sp]=pt_sp(p)
      sn_particles_int[sn_number_particles][sn_int_pt_test]=pt_test(p)
      sn_particles_float[sn_number_particles][sn_float_pt_t]=pt_t(p)
/*
   Recall that |stat_wt_tot_flt| comes via |sa_common| from 
   subroutine |do_flights|.
*/
      sn_particles_float[sn_number_particles][sn_float_pt_w]=pt_w(p)*stat_wt_tot_flt
      sn_particles_float[sn_number_particles][sn_float_pt_v1]=pt_v(p)[1]
      sn_particles_float[sn_number_particles][sn_float_pt_v2]=pt_v(p)[2]
      sn_particles_float[sn_number_particles][sn_float_pt_v3]=pt_v(p)[3]
      sn_particles_float[sn_number_particles][sn_float_lc_x1]=lc_x(pt_loc(p))[1]
      sn_particles_float[sn_number_particles][sn_float_lc_x2]=lc_x(pt_loc(p))[2]
      sn_particles_float[sn_number_particles][sn_float_lc_x3]=lc_x(pt_loc(p))[3]
      sn_particles_int[sn_number_particles][sn_int_lc_cell]=lc_cell(pt_loc(p))
      sn_particles_int[sn_number_particles][sn_int_lc_zone]=lc_zone(pt_loc(p))
      sn_particles_int[sn_number_particles][sn_int_lc_face]=lc_face(pt_loc(p))
      sn_particles_int[sn_number_particles][sn_int_lc_cell_next]=lc_cell_next(pt_loc(p))
      sn_particles_int[sn_number_particles][sn_int_lc_zone_next]=lc_zone_next(pt_loc(p))
      sn_particles_int[sn_number_particles][sn_int_lc_sector]=lc_sector(pt_loc(p))
      sn_particles_int[sn_number_particles][sn_int_lc_sector_next]=lc_sector_next(pt_loc(p))
      sn_particles_int[sn_number_particles][sn_int_pt_type]=pt_type(p)
      sn_particles_int[sn_number_particles][sn_int_pt_author]=pt_author(p)

      return
      end

      


      






