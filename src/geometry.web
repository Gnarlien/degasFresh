% $Id: d5fc2b94e8de7ce5d04325f09bac32f9d5595745 $

\Title{geometry}


@* Geometry routines for degas.

\ID{$Id: d5fc2b94e8de7ce5d04325f09bac32f9d5595745 $}

Each cell is described by an equation of the form
$$
C_j = \bigcap_{k\in K_j\cup K'_j} \{ \vect x : \sigma_k f_k(\vect x) \ge 0 \}.
$$
where each $f_k$ is a quadratic surface and $\sigma_k$ is an orientation
($\pm 1$).  $K_j$ is the set of {\it faces} of cell $C_j$, and $K'_j$ is
the set of {\it cut surfaces}.  Cut surfaces are used to eliminate
extraneous volumes that may appear when using quadratic surfaces.  We
require that each cell is {\it connected}.  The cut surfaces serve to
enforce this constraint.

There are $N_c+1$ cells numbered 0 thru $N_c$.  Cell 0 is the universe.  All
the other cells are disjoint and their union is the universe.  Thus
$$
C_0 = \bigcup_{j=1}^{N_c} C_j,
$$
and
$$
V(C_i \cap C_j) = 0,
$$
for all $i\ne j$, $i>0$, $j>0$, where $V(C)$ is the volume of $C$.

Cells are grouped together into {\it zones}.  All cells other than cell 0
belong to exactly one zone.  By combining cells together arbitrarily
complicated zones can be defined.  Zones are the basic geometrical
abstraction seen by the outside world.


The information about the cells is held in an array |cells[4,ncells]|.
The ``4'' represents the following items pertinent to each cell; the
actual integer value assigned to the first index in each case is specified
in |geomint.hweb|.
|cells[c_start,j]| is a pointer to a list of surfaces for cell $j$,
|cells[c_faces,j]| is the number of faces, and |cells[c_surfaces,j]| is
the number of faces plus cut surfaces.  |cells[c_zone,j]| holds a zone
index.

|cells[c_start,j]| points into an array |boundaries|.  Each element of
|boundaries| is a signed integer whose absolute value gives the surface
index $k$ and whose sign gives $\sigma_k$.

The faces of the $j$th cell are given by the |cells[c_faces,j]| surfaces
starting at |boundaries[cells[c_start,j]]| and the cut surfaces are gives
by the |cells[c_surfaces,j]-cells[c_faces,j]| surfaces starting at
|boundaries[cells[c_start,j]+cells[c_faces,j]]|.

|surfaces| holds four pieces of information about each surface: a count,
|surfaces[s_neg,s_count,k]|, of the number of cells for which this surface is
a face on the negative side; a pointer, |surfaces[s_neg,s_start,k]|, to
|neighbors|, giving the indices of the cells; and then the
corresponding information for the positive side, |surfaces[s_pos,s_count,k]|
and |surfaces[s_pos,s_start,k]|.

|surface_sectors| holds four pieces of information about the sectors
associated with each surface: a count,
|surface_sectors[s_neg,s_count,k]|, of the number of sectors for
this surface on the negative side; a pointer,
|surface_sectors[s_neg,s_start,k]|, to |sectors|, giving the
sectors for that surface; and then the corresponding information for the
positive side, |surface_sectors[s_pos,s_count,k]| and
|surface_sectors[s_pos,s_start,k]|.

|sector_points| gives bounding points on sectors. |strata| gives the
stratum number for each sector.

|sector_surface| gives the surface for each sector.

|sector_zone| gives the zone for each sector.

|surface_coeffs| holds the ten coefficients of the equations for the faces.

|neighbors| is a list of cells for each face.

Each surface may have a transformation associated with it.  If \newline
|surfaces_tx_ind[s_sign(k),t_surf,abs(k)]| is nonzero, then a point on
surface |k| is transformed to a point on surface
|surfaces_tx_ind[s_sign(k),t_surf,abs(k)]| using the transformation
|surfaces_tx_mx[1..3,1..4,surfaces_tx_ind[s_sign(k),t_mx,abs(k)]]|.

After the geometry is set up, information about the geometry is held in
|geom_args|.  This can be declared (in non-geometry routines) by
|decl_geom|.

@m FILE 'geometry.web'

@I macros.hweb

@I geomint.hweb
@I readfilenames.hweb
@I sector.hweb
@I zone.hweb
@I netcdf.hweb
@I sysdep.hweb
@I location.hweb
@I particle.hweb
@I detector.hweb
@I mpi.hweb

@* External interface to geometry routines.

The geometry is held in |geom_args|.  This should not be altered by any
external routine.  |decl_geom| declares |geom_args|.

The externally callable routines are:

|locate_point(x,zone)| returns the cell number for a point or $-1$ if
the point is outside the universal cell.  The zone number is returned in
|zone|.

|check_point_x(x)| checks the point.  This checks the point against
all the cells.  In the event that the point lies in multiple cells, it
checks that the cells are neighbors.  Returns |.true.| if the check
succeeded.

|track(type,tmax,x0,v,cell,t,x,cell1,exit_face,cell2)| tracks a
particle $\vect x = \vect x_0 + \vect v t$ through a zone stopping either
at the boundary of the zone (and returning |.false.|) or after a time
$t_{\mathrm{max}}$ (and returning |.true.|), whichever comes first.  
The updated
position is given in $\vect x$.  |cell| is the starting cell.  If the
result is |.true.|, then the particle did not leave the zone, |t = tmax|,
|cell1=cell2| is the ending cell, and |exit_face=0|.  Else, 
if the result is |.false.|, the particle stopped at the boundary of the
zone, |t < tmax|, |cell1| is the ending cell belonging
to the original zone, the face through which the particle is exiting is
given in |exit_face| and the next cell is given in |cell2|.  If |cell2==0|,
then the particle is leaving the universal cell.

|intersection_direction(face,x,v)| returns the cosine of angle of
$\vect v$ with the face.  A positive result implies the particle is leaving
the cell.

|call surface_specular(face,x,v,v1)| specularly reflects a
particle at $\vect x$ with velocity $\vect v$ off a surface.  Returns a new
velocity $\vect {v1} = \vect v - 2 \nabla f (\nabla f \cdot \vect v) /
\abs{\nabla f}^2 $, provided $v$ was heading out of the face, otherwise
$\vect {v1} = \vect v$.

|call surface_reflect(face,x,v,w,v1)| makes an arbitrary
reflection of a particle at $\vect x$ with velocity $\vect v$ off a face.
The new velocity is $\vect {v1}$.  In the coordinate system aligned with the
face, this new velocity is input as $\vect w$, where $w_i = \vect e_i\cdot
\vect w$.  This coordinate system is given by the unit vectors: $\vect e_3$
is inward unit normal to the face, $\vect e_1$ is parallel to $(\tens I -
\vect e_3\vect e_3)\cdot \vect v$ and $\vect e_2 = \vect e_3 \times \vect
e_1$.

|cell_enter(cell,x0,v,enter_face)| returns the time of
intersection of a trajectory $\vect x_0 + \vect v t$ with a cell where
$\vect x_0$ is not necessarily in the cell.  This is most likely only
called for the universal cells when doing things like plotting, so we are
not so much concerned with speed here.  The returned value will be negative
if $\vect x_0$ is already inside the cell and |geom_infinity| is returned
if the trajectory misses the cell entirely.  The face through which the
trajectory enters is given by |enter_face|.

@ |new_cell(exit_face,x)| returns the new cell for particle
exiting through face |exit_face|.  Returns 0, if there are no cells on the
other side of |exit_face|.  This indicates that the particle is exiting the
universal cell.

@ The unnamed module.

@a
      @<Functions and Subroutines@>

@* Simple utility routines.  This are expanded inline.

@ Evaluate surface function using Horner's rule.

@<Functions...@>=
@#if !SURFACE_EVAL_MACRO
      function surface_eval(surface_args,x)
      implicit_none_f77
      implicit_none_f90
      real surface_eval         // Function
      decl_surface_args         // Input
      real x[3] // Input

/*
      write(25,'(1p13e12.5)') x,coeff
*/

@#if PLANE_SURFACES
      surface_eval=sigma*(x[3]*coeff[cz]+
     $     x[2]*coeff[cy]+x[1]*coeff[cx]+
     $     coeff[c0])
@#else
      surface_eval=sigma*(x[3]*(coeff[czz]*x[3]+coeff[cyz]*x[2]+
     $     coeff[cxz]*x[1]+coeff[cz])+
     $     x[2]*(coeff[cyy]*x[2]+coeff[cxy]*x[1]+
     $     coeff[cy])+x[1]*(coeff[cxx]*x[1]+coeff[cx])+
     $     coeff[c0])
@#endif

      return
      end
@#endif

@ Evaluate gradient of a surface $\sigma \nabla f(\vect x)$.

@<Functions...@>=
      subroutine surface_gradient(surface_args,x,grad)
      implicit_none_f77
      implicit_none_f90
      decl_surface_args         // Input
      real x[3]
      real grad[3]              // Output

@#if PLANE_SURFACES
      grad[1]=sigma*coeff[cx]
      grad[2]=sigma*coeff[cy]
      grad[3]=sigma*coeff[cz]
@#else
      grad[1]=sigma*(coeff[cxz]*x[3]+coeff[cxy]*x[2]+
     $     2*coeff[cxx]*x[1]+coeff[cx])
      grad[2]=sigma*(coeff[cyz]*x[3]+2*coeff[cyy]*x[2]+
     $     coeff[cxy]*x[1]+coeff[cy])
      grad[3]=sigma*(2*coeff[czz]*x[3]+coeff[cyz]*x[2]+
     $     coeff[cxz]*x[1]+coeff[cz])
@#endif
      return
      end

@ Check whether a point lies within |geom_epsilon| of a surface.  If
|surface_val| is |.true.|, then the value of the surface function is given
in |f|.
It is necessary to relax the check a bit if you want to check for a point 
lying on the face of a cell or inside the cell because that rarely happens. 
A typical distance would be $f /\nabla f$. If this is smaller  than a small 
number say |geom_epsilon|, we could say that the point lies in the cell.
In order to avoid evaluating |f|  twice, |surface_val|  should be passed as 
|.true.| if |f| is known and |f| should be passed to this function.
@<Functions...@>=
      function in_surface(surface_args,x,surface_val,f)
      implicit_none_f77
      implicit_none_f90
      logical in_surface        // Function
      decl_surface_args         // Input
      real x[3],f               // Input
      logical surface_val
      real grad[3],f0           // Local
      external surface_eval,surface_gradient // External
      real surface_eval

      call surface_gradient(surface_args,x,grad)

      if ( surface_val ) then
         f0=f
      else
         f0=surface_eval_a(surface_args,x)
      end if

      in_surface = abs(f0) <= geom_epsilon*vc_abs(grad)

      return
      end

@ Debuggin version of |in_surface|.
@<Functions...@>=
      function in_surface_dump(surface_args,x,surface_val,f)
      implicit_none_f77
      implicit_none_f90
      logical in_surface_dump        // Function
      decl_surface_args         // Input
      real x[3],f               // Input
      logical surface_val
      real grad[3],f0           // Local
      external surface_eval,surface_gradient // External
      real surface_eval

      call surface_gradient(surface_args,x,grad)

      if ( surface_val ) then
         f0=f
      else
         f0=surface_eval_a(surface_args,x)
      end if

      write(stderr,*) ' In in_surface_dump'
      write(stderr,*) ' f0 = ',f
      write(stderr,*) ' grad = ',grad
      write(stderr,*) ' vc_abs(grad) = ',vc_abs(grad)
      write(stderr,*) ' surface_args = ',surface_args
      in_surface_dump = abs(f0) <= geom_epsilon*vc_abs(grad)

      return
      end

@ Check whether a point lies on the positive side of a surface (within
|geom_epsilon|).
Here, if |f| $\geq 0$ the point lies on the positive side of the surface. Else,
if it lies on the negative side within |geom_epsion| it is accepted.
@<Functions...@>=
      function inside_surface(surface_args,x)
      implicit_none_f77
      implicit_none_f90
      logical inside_surface        // Function
      decl_surface_args         // Input
      real x[3]               // Input
      real f           // Local
      external in_surface,surface_eval // External
      real surface_eval
      logical in_surface

      inside_surface=.true.

      f=surface_eval_a(surface_args,x)
      
      if (f >= zero) return
      
      inside_surface=in_surface(surface_args,x,.true.,f)
      
      return
      end

@* Basic geometrical routines.  First check whether a point lies in a cell.
| cell_args | is a dummy argument. |cell_surface_info(n)| contains information
on the surface.

@<Functions...@>=
      function inside_cell(cell_args,x)
      implicit_none_f77
      implicit_none_f90
      logical inside_cell       // Function
      decl_cell_args            // Input
      real x[3]
      integer n                 // Local
      external surface_eval     // External
      real surface_eval

      inside_cell=.false.

      dosurfaces(n)
         if ( surface_eval_a(cell_surface_info_a(n),x) < zero )
     $        return
      end do

      inside_cell=.true.

      return
      end

@ Sloppy check for whether a point lies inside a particular cell.
Sloppy check implies that if |x| lies within |geom_epsilon| of the face,
it is accepted. A strict check is done on the cut surfaces though.

@<Functions...@>=
      function sloppy_inside(cell_args,x)
      implicit_none_f77
      implicit_none_f90
      logical sloppy_inside     // Function
      decl_cell_args            // Input
      real x[3]
      real f0                   // Local
      integer n
      external surface_eval,in_surface // External
      real surface_eval
      logical in_surface

      sloppy_inside=.false.

      dofaces(n)                // Do the sloppy check on faces.
         f0 = surface_eval_a(cell_surface_info_a(n),x)
         if ( f0 < zero ) then
            if ( ! in_surface(cell_surface_info(n),x,.true.,f0) ) return
         end if
      end do

      docuts(n)                 // Do strict check on cut surfaces.
         if ( surface_eval_a(cell_surface_info_a(n),x) < zero )
     $        return
      end do

      sloppy_inside=.true.

      return
      end

@ Check that a face belongs to a cell.

@<Functions...@>=
      function face_in_cell(cell_args,face)
      implicit_none_f77
      implicit_none_f90
      logical face_in_cell      // Function
      decl_cell_args            // Input
      integer face
      integer n                 // Local

      face_in_cell=.true.

      dofaces(n)
         if (surf_list[n] == face) return
      end do

      face_in_cell=.false.

      return
      end

@ Now similar routines to check whether the point is in a cell, but
skipping the check on the face indexed by |face|.
this is used when a flight exits a cell through a face to another cell, this 
face is excluded from the check. A strict check for the condition 
$$ \sigma_k f_k(\vect x) \ge 0 $$ is done on all the other surfaces.
@<Functions...@>=
      function inside_cell_a(cell_args,face,x)
      implicit_none_f77
      implicit_none_f90
      logical inside_cell_a     // Function
      decl_cell_args            // Input
      integer face
      real x[3]
      integer n                 // Local
      external surface_eval     // External
      real surface_eval

      inside_cell_a=.false.

      dosurfaces(n)
         if ( surf_list[n] != face ) then
            if ( surface_eval_a(cell_surface_info_a(n),x) < zero )
     $           return
         end if
      end do

      inside_cell_a=.true.

      return
      end

@ Sloppy equivalent of |inside_cell_a|.
Here, the check on the all the surfaces other than the face is not done 
strictly (the point can lie within |geom_epsilon| of the surface). A strict
check is done on the cut surfaces.
@<Functions...@>=
      function sloppy_inside_a(cell_args,face,x,dump)
      implicit_none_f77
      implicit_none_f90
      logical sloppy_inside_a   // Function
      decl_cell_args             // Input
      integer face
      real x[3]
      logical dump
      integer n                 // Local
      real f0
      external surface_eval,in_surface,in_surface_dump // External
      real surface_eval
      logical in_surface,in_surface_dump

      sloppy_inside_a=.false.

      dofaces(n)
         if (dump) then
            write(stderr,*) ' In sloppy_inside_a'
            write(stderr,*) ' n = ',n
            write(stderr,*) ' surf_list[n] = ',surf_list[n]
         end if
         if ( surf_list[n] != face ) then
            f0 = surface_eval_a(cell_surface_info_a(n),x)
            if (dump) then
               write(stderr,*) ' f0 = ',f0
            end if
            if ( f0 < zero ) then
               if (!dump) then
                  if ( ! in_surface(cell_surface_info(n),x,.true.,f0) ) return
               else
                  if ( ! in_surface_dump(cell_surface_info(n),x,.true.,f0) ) 
     $                 then
                     write(stderr,*) ' in_surface came back false for n = ',n
                     return
                  end if
               end if
            end if
         end if
      end do

      docuts(n)                 // Do strict check on cut surfaces.
         if ( surface_eval_a(cell_surface_info_a(n),x) < zero )
     $        return
      end do

      sloppy_inside_a=.true.

      return
      end

@ Check that a point lies on a particular face of a cell.
For a point to lie on a face, it has to satisfy 2 conditions : \\
It has to lie within |geom_epsilon| of the face and also strictly inside 
the cell.
@<Functions...@>=
      function on_face(cell_args,face,x)
      implicit_none_f77
      implicit_none_f90
      logical on_face           // Function
      decl_cell_args            // Input
      integer face
      real x[3]
      external in_surface,inside_cell_a,face_in_cell // External
      logical in_surface,inside_cell_a,face_in_cell

      check(face_in_cell(cell_args,face))
      on_face = in_surface(surface_info(face),x,.false.,zero) &&
     $     inside_cell_a(cell_args,face,x)

      return
      end

@ A sloppy version of |on_face|.
This is the same as |on_face| except that the point does'nt have to lie 
strictly inside the cell; ie., it may lie within |geom_epsilon| of the faces. 
@<Functions...@>=
      function sloppy_on(cell_args,face,x)
      implicit_none_f77
      implicit_none_f90
      logical sloppy_on         // Function
      decl_cell_args            // Input
      integer face
      real x[3]
      external in_surface,sloppy_inside_a,face_in_cell // External
      logical in_surface,sloppy_inside_a,face_in_cell

      check(face_in_cell(cell_args,face))
      sloppy_on = in_surface(surface_info(face),x,.false.,zero) &&
     $     sloppy_inside_a(cell_args,face,x,.false.)

      return
      end

@ Check that a point lies outside ($-1$), inside ($1$), or on ($0$) a cell.

@<Functions...@>=
      function cell_compare(cell_args,x)
      implicit_none_f77
      implicit_none_f90
      integer cell_compare            // Function
      decl_cell_args            // Input
      real x[3]
      integer n                 // Local
      real f0
      logical on
      external surface_eval,in_surface // External
      real surface_eval
      logical in_surface

      cell_compare=-1

      docuts (n)
         if (surface_eval_a(cell_surface_info_a(n),x) < zero) return
      end do

      on=.false.

      dofaces(n)
         f0=surface_eval_a(cell_surface_info_a(n),x)
         if (in_surface(cell_surface_info(n),x,.true.,f0)) f0=zero
         if (f0 < zero) return
         if (f0 == zero) on=.true.
      end do

      if (on) then
         cell_compare=0
      else
         cell_compare=1 // comes here if f0 $> 0$
      end if

      return
      end
      
@* Face intersections.  |surface_intersect| returns the first outgoing
intersection of $\vect x_0 + \vect v t$ with the surface.  If no such
intersection is found, return |geom_infinity|.  This may return a negative
result, if $\vect x_0$ is initially on the wrong side of the face.  (In
this case the particle should pass to the neighboring cell.)

To find the intersection of the surface |f(x)| with the path of the particle 
given by $\vect x_0 + \vect v t$ , we put this in the equation  
$$f(\vect x_{0} + 
\vect v t)= 0. $$ 
We get
a  quadratic equation,
$$ a t^2 + 2 h t +c = 0, $$ where $a$, $h$ and $c$ are given as
\begin{eqnarray*}
 a & = & \sigma
     \left[ v_{3}(\mathit{coeff}_{czz}v_{3}+\mathit{coeff}_{cyz}v_{2}+
       \mathit{coeff}_{cxz}v_{1}) \right. \\
   &  &  \left. +v_{2}(\mathit{coeff}_{cyy}v_{2}+
       \mathit{coeff}_{cxy}*v_{1})+\mathit{coeff}_{cxx}*v_{1}^2 \right]
\end{eqnarray*}
$ h= \frac {1}{2} \left. \nabla f \right @|_{x_{0}} \cdot \vect v, $
$ c= f(\vect x_{0}) $ \\
solving this equation gives the value of $t$ (time) taken for the particle to
intersect the first face in its direction. 
@<Functions...@>=
      function surface_intersect(surface_args,x0,v)
      implicit_none_f77
      implicit_none_f90
      real surface_intersect    // Function
      decl_surface_args         // Input
      real x0[3],v[3]
      real a,h,c,temp[3],disc   // Local
      external surface_eval     // Exter nal
      real surface_eval
@#if DEBUG
      external surface_intersection_direction,in_surface // External
      real surface_intersection_direction
      logical in_surface
@#endif

@#if PLANE_SURFACES
      a=zero
@#else
      a=sigma*
     $    (v[3]*(coeff[czz]*v[3]+coeff[cyz]*v[2]+
     $    coeff[cxz]*v[1])+v[2]*(coeff[cyy]*v[2]+
     $    coeff[cxy]*v[1])+coeff[cxx]*v[1]^2)
@#endif
      call surface_gradient(surface_args,x0,temp)
      h=half*vc_product(temp,v)
      c=surface_eval_a(surface_args,x0)

@#if DEBUG
      if ( c < zero ) then
@#if 0
         assert(in_surface(surface_args,x0,.true.,c))
@#else
         if (!(in_surface(surface_args,x0,.true.,c))) then
            write(stderr,*) ' c < zero in surface_intersect'
            write(stderr,*) ' c = ',c
            write(stderr,*) ' h = ',h
            write(stderr,*) ' x0 = ',x0
            write(stderr,*) ' v = ',v
            write(stderr,*) ' surface_args = ',surface_args
            assert(in_surface(surface_args,x0,.true.,c))
         end if
@#endif
      end if
@#endif

      surface_intersect = geom_infinity

      if ( a != zero ) then // Quadratic equation
         disc=h^2-a*c
         if ( disc <= zero ) then // No roots
            if ( a < zero ) then // but if on wrong side, return maximum
               surface_intersect = -h/a
            end if
         else                   // |disc > zero| two distinct roots
            disc=sqrt(disc)
            if ( h < zero ) then
               surface_intersect = -c/(h-disc) // Avoid cancellation in |-(h+disc)/a|
            else                // |h >= zero|
               if ( a < zero ) surface_intersect = -(h+disc)/a
            end if
         end if
      else if ( h != zero ) then // Linear equation
         if ( h < zero ) surface_intersect = -c/(two*h)
      end if                    // else the equation is a constant

@#if DEBUG
      if ( surface_intersect < zero ) then
         assert( c < zero )     // Should only have a negative intersection if point is on wrong side
      end if
/* Check result, except cases with no intersection or zero velocity */
      if ( surface_intersect*vc_abs(v) < geom_large ) then
         vc_xvt(x0,v,surface_intersect,temp)
         assert(in_surface(surface_args,temp,.false.,zero))
         assert(surface_intersection_direction(surface_args,temp,v) >= -epsilon_angle )
      end if
@#endif

      return
      end

@ Compute direction of intersection.  Returns cosine of angle of $\vect v$
with $-\sigma \nabla f$.  A positive result implies the particle is leaving
the cell.

@<Functions...@>=
      function surface_intersection_direction(surface_args,x,v)
      implicit_none_f77
      implicit_none_f90
      real surface_intersection_direction // Function
      decl_surface_args         // Input
      real x[3],v[3]
      real grad[3]              // Local
      external surface_gradient // External

      call surface_gradient(surface_args,x,grad)
      surface_intersection_direction=-vc_product(grad,v)/
     $     (vc_abs(v)*vc_abs(grad))
      if (surface_intersection_direction < -one) surface_intersection_direction=-one
      if (surface_intersection_direction > one) surface_intersection_direction=one
      assert(abs(surface_intersection_direction) <= one)

      return
      end

@ An externally callable version of |surface_intersection_direction|.

@<Functions...@>=
      function intersection_direction(face,x,v)
      implicit_none_f77
      gi_common
      implicit_none_f90
      real intersection_direction // Function
      integer face
      real x[3],v[3]            // Input
      external surface_intersection_direction // External
      real surface_intersection_direction

      intersection_direction=surface_intersection_direction(surface_info(face),x,v)

      return
      end
      
@ Specularly reflect a particle at $\vect x$ with velocity $\vect v$ off a
surface.  Returns a new velocity $\vect v' = \vect v - 2 \nabla f (\nabla f
\cdot \vect v) / \abs{\nabla f}^2 $, provided $v$ was heading out of the
face, otherwise $\vect {v1} = \vect v$.

@<Functions...@>=
      subroutine surface_specular(face,x,v,v1)
      implicit_none_f77
      gi_common
      implicit_none_f90
      integer face              // Input
      real x[3],v[3]
      real v1[3]                // Output
      real grad[3],vperp         // Local
      vc_decls
      external surface_gradient // External

      call surface_gradient(surface_info(face),x,grad)
      vc_unit(grad,grad)
      vperp=vc_product(grad,v)  // The perpendicular component of $\vect v$.

      vc_xvt(v,grad,(-one+sign(one,vperp))*vperp,v1)

      return
      end

@ Arbitrary reflection of a particle at $\vect x$ with velocity $\vect v$ of a
face.  The new velocity is $\vect w$ in the coordinate system where $w_i =
\vect e_i\cdot \vect w$, and $\vect e_3$ is unit normal to the face, $\vect
e_1$ is parallel to $(\tens I - \vect e_3\vect e_3)\cdot \vect v$ and
$\vect e_2 = \vect e_3 \times \vect e_1$.

@<Functions...@>=
      subroutine surface_reflect(face,x,v,w,v1)
      implicit_none_f77
      gi_common
      implicit_none_f90
      integer face              // Input
      real x[3],v[3],w[3]
      real v1[3]                // Output
      real e[3,3],e1[3],e2[3],e3[3],vunit[3] // Local
      real vperp
      equivalence (e1,e[1,1]),(e2,e[1,2]),(e3,e[1,3])
      vc_decls
      integer i
      external surface_gradient // External

      call surface_gradient(surface_info(face),x,e3)
      vc_unit(e3,e3)

      if (vc_abs(v) > zero) then
         vc_unit(v,vunit)
         vperp=abs(one+vc_product(e3,vunit))
      else
         vperp=one
      end if

      vc_xvt(v,e3,-vc_product(e3,v),e1)
      if ((vc_abs(e1) <= vc_abs(v)*const(4.)*epsilon) 
     $     || (vperp <= const(4.)*epsilon)) then
/*
   $\vect v_\parallel = 0$, so choose an arbitrary direction in the surface.

   This calculation appears particularly prone to roundoff errors in
   the (frequent) case of normal incidence (at the start of a flight).
   The original fix of comparing |e1| with |epsilon| has failed 
   multiple times in simulations by Takenaga. However, these failures
   were just slightly larger than |epsilon| (less than $10 \%$). 
   Argue that the roundoff error applies separately to each vector
   component so that $\sqrt{3} \epsilon$ is a more appropriate upper
   bound for the total error. Have now found one case that exceeds this
   by about $1 \%$. Use $2 \epsilon$ to allow for a little more slop
   (this coefficient should not be allowed to grow continuously!).
   The subsequent assert using
   $\sqrt{\epsilon}$ will still catch those cases which are
   not caught by this test, but should be treated with suspicion.

   Another case arose with a nearly horizontal target in which |e1| was
   orders of magnitude larger than $\epsilon$ due to roundoff error.
   Developed the expression for |vperp| as an alternative test for 
   parallel vectors; it seems to work better for this situation.
*/
         vc_set(e2,one,zero,zero)
         vc_cross(e3,e2,e1)
         if (vc_abs(e1) <= vc_abs(v)*const(3.)*epsilon) then
/*
   Found a case (box geometry with plate source) that slipped through 
   this with $\vec{e2}$ and $\vec{e3}$ differing only by roundoff
   error. This result argued for loosening this test as well.
*/
            e[2,2]=one
            vc_cross(e3,e2,e1)
         end if
/*
  Subsequently had a case of normal incidence on a nearly vertical target.
  The normal incidence caused the first ``if'' above to be entered. However,
  the surface had enough inclination to get past the second one (and this
  was numerically a reasonable thing to do). The case then failed the
  subsequent assert because of the magnitude of |v|. Decided that the
  test in this assert must be dimensionless (as it would be in the
  off-normal incidence case), so add the factor of |vc_abs(v)| here.
*/
         if (vc_abs(v) > zero) then
            vc_scale(vc_abs(v),e1,e1)
         end if
      end if
      if (vc_abs(v) > zero) then
         assert(vc_abs(e1)/vc_abs(v) > sqrt(epsilon)) // Test, to see if anything squeaks by
      end if

      vc_unit(e1,e1)
      vc_cross(e3,e1,e2) // $\vect e_{1,2,3}$ form a right-handed basis set.

      do i=1,3
        v1[i] = w[1]*e[i,1] + w[2]*e[i,2] + w[3]*e[i,3]
      end do

      return
      end

@* Cell intersection.  Calculate intersection of a trajectory $\vect x_0 +
\vect v t$ with a cell.  |cell_intersect| returns time of the intersection
as function value.  The face through which the trajectory exits is given by
|exit_face|.
The time taken to intersect each of the faces is calculated by the function 
|surface_intersect|. The smallest of these times is taken as |cell_intersect|.
The face of intersection is saved in |ns|. If the value of |cell_intersect| is
$< 0$, it is taken as 0.

@<Functions...@>=
      function cell_intersect(cell_args,x0,v,exit_face)
      implicit_none_f77
      implicit_none_f90
      real cell_intersect       // Function
      decl_cell_args            // Input
      real x0[3],v[3]
      integer exit_face         // Output
      real t                    // Local
      integer n,ns
      external surface_intersect // External
      real surface_intersect

      cell_intersect=geom_infinity

      dofaces(n)
         t=surface_intersect(cell_surface_info(n),x0,v)
         if ( t < cell_intersect ) then
            cell_intersect = t
            ns = n
         end if
      end do

      cell_intersect = max(zero, cell_intersect)
      assert(cell_intersect < geom_infinity)

      exit_face = surf_list[ns]

      return
      end

@ Determine the new cell for particle exiting through face |exit_face|.
Returns 0, if there are no cells on the other side of |exit_face|.  This
indicates that the particle is exiting the universal cell.  Using the
face index of |exit_face|, the starting index which points to the list
of cells for that face and the number of cells for the face is found.
we check whether |x| lies strictly inside any of the cells and return if
it does. Otherwise, a relaxed check is done for the same.

@<Functions...@>=
      function new_cell(exit_face,x)
      implicit_none_f77
      gi_common
      implicit_none_f90
      integer new_cell          // Function
      integer exit_face         // Input
      real x[3]
      integer n,s,i,j,face        // Local
      external inside_cell_a,sloppy_inside_a // External
      logical inside_cell_a,sloppy_inside_a

      face=-exit_face           // Face index for new cell
      new_cell = 0

      n=surfaces[s_sign(face),s_count,abs(face)] // Number of cells
      s=surfaces[s_sign(face),s_start,abs(face)] // Starting index

      if (n == 0) return        // Outermost surface

      do i=s,s+n-1              // Try with the strict conditions
         j=neighbors[i]         // Get cell number
         if ( j > 0 ) then      // Skip if it's the universe
            if (inside_cell_a(cell_info(j),face,x)) then
               new_cell = j
               return
            end if
         end if
      end do

      do i=s,s+n-1              // Now relax the criteria
         j=neighbors[i]
         if ( j > 0 ) then
            if (sloppy_inside_a(cell_info(j),face,x,.false.)) then
               new_cell = j
               return
            end if
         end if
      end do

@#if 0
      assert(new_cell > 0)     // Can't find a satisfactory new cell
@#else
      if (!(new_cell > 0)) then
         write(stderr,*) ' new_cell <= 0 '
         write(stderr,*) ' x = ',x
         write(stderr,*) ' exit_face = ',exit_face
         write(stderr,*) ' new_cell = ',new_cell
         write(stderr,*) ' n = ',n
         write(stderr,*) ' s = ',s
         do i=s,s+n-1        
            j=neighbors[i]
            write(stderr,*) ' For i = ',i,' j = ',j
            if ( j > 0 ) then
               if (sloppy_inside_a(cell_info(j),face,x,.true.)) then
                  write(stderr,*) ' WHOA! This did not work above!'
               end if
            end if
         end do
         assert(new_cell > 0)     // Can't find a satisfactory new cell
      end if
@#endif

      return
      end

@ Track a particle $\vect x = \vect x_0 + \vect v t$
through a zone stopping either at the boundary of the zone (and
returning |.false.|) or after a time $t_{\mathrm{max}}$ (and returning
|.true.|), whichever comes first.  Give the updated position $\vect x$ and
the new cell |cell1|.  If an intersection is found, the |cell1| belongs to
the original zone and, in addition, the face through which the particle
is exiting is given in |exit_face| and the new cell is given in |cell2|.

@<Functions...@>=
      function track(type,tmax,x0,v,cell,t,x,cell1,exit_face,cell2,sector1,sector2)
      implicit_none_f77
      gi_common
      sc_common
      implicit_none_f90
      logical track             // Function
      real tmax,x0[3],v[3]      // Input
      integer type,cell
      real t,x[3]               // Output
      integer cell1,exit_face,cell2,sector1,sector2
      integer j,k,k1,tx,i,start,count // Local
      real dt,tleft,t1,v1[3],temp[3]
      external cell_intersect,new_cell,in_surface   // External
      real cell_intersect
      integer new_cell
      logical in_surface

      assert(type == pt_geometry || type == pt_neutral || type == pt_ion)
      assert(cell>0)
      j = cell
      vc_copy(x0,x)
      if (type == pt_ion) then
         vc_set(v1,zero,zero,zero)
      else
         vc_copy(v,v1)
      end if
      t1=zero
      sector1=0
      sector2=0

loop: continue
      cell1 = j                 // Update cell
      tleft = tmax-t1
/* Some things in |cell_intersect| and so forth choke on $|v1| \equiv 0$ */
      if (vc_abs(v1) > zero) then 
         dt = min(tleft,cell_intersect(cell_info(cell1),x,v1,k))
      else
         dt = tleft
      end if
      t1 = t1+dt
      vc_xvt(x,v1,dt,x)       // Update position
      if ( dt == tleft ) then  // We're done
         t = tmax               // Set |t| exactly to |tmax|
         exit_face = 0
         cell2 = j
         track = .true.
         return
      end if

/* 
   Check for outgoing sector.
   This used to be inside the check on |type| below.
*/
      count=surface_sectors[s_sign(k),s_count,abs(k)]
      if (count > 0) then
         start=surface_sectors[s_sign(k),s_start,abs(k)]
         do i=0,count-1
            if (cells[c_zone,cell1] == sector_zone[sectors[start+i]]) then
               sector1=sectors[start+i]
               assert(sector_surface[sector1] == k)
               goto break1
            end if
         end do
break1:  continue
      end if
      if (type != pt_geometry) then

/* Process the transformation */
         k1=surfaces_tx_ind[s_sign(k),t_surf,abs(k)]
         if (k1 != 0) then
            tx=surfaces_tx_ind[s_sign(k),t_mx,abs(k)]
@#if 0
            write(stderr,*) 'Surface tx: ',k,k1
            write(stderr,*) 'Old x,v: ',(x[i],i=1,3),(v1[i],i=1,3)
@#endif
            k=k1
            vc_copy(x,temp)
            call transform(surfaces_tx_mx[1,1,tx],temp,x)
            vc_copy(v1,temp)
            call transform_velocity(surfaces_tx_mx[1,1,tx],temp,v1)
            if (type != pt_ion) then
               vc_copy(v1,v)
            end if
@#if 0
            write(stderr,*) 'New x,v: ',(x[i],i=1,3),(v1[i],i=1,3)
@#endif
            assert(in_surface(surface_info(k),x,.false.,zero))
         end if

      end if

      j = new_cell(k,x) // Find next cell
      
/* Check for incoming sector */
      count=surface_sectors[s_sign(-k),s_count,abs(k)]
      if (count > 0) then
         start=surface_sectors[s_sign(-k),s_start,abs(k)]
         do i=0,count-1
            if (cells[c_zone,j] == sector_zone[sectors[start+i]]) then
               sector2=sectors[start+i]
               assert(sector_surface[sector2] == -k)
               goto break2
            end if
         end do
break2:  continue
      end if

/* Keep tracking if still in same zone and if not on a sector */
      if ( cells[c_zone,cell1] == cells[c_zone,j] && sector1 == 0 && sector2 == 0 ) goto loop

      t = t1
      exit_face = k
      cell2 = j
      track=.false.

      return
      end

@ Find entering intersection of a trajectory $\vect x_0 + \vect v t$ with a
cell where $\vect x_0$ is not necessarily in the cell.  This is most likely
only called for the universal cells when doing things like plotting, so we
are not so much concerned with speed here.  |cell_enter| returns time of
the entry as function value.  This will be negative if $\vect x_0$ is
already inside the cell and |geom_infinity| is returned if the trajectory
misses the cell entirely.  The face through which the trajectory enters is
given by |enter_face|.

If the point $\vect x_0$ does'nt lie inside the given |cell|, get the surface
 index
of the surface of |cell| of which |x0| lies on the +ve side from  |boundaries|
and find the time for intersection with this surface. Advance $\vect x_0$  by  
$\vect v t$ and check if it lies inside |cell|. If it does, get the index of
the surface and return as |enter_face|.
@<Functions...@>=
      function cell_enter(cell,x0,v,enter_face)
      implicit_none_f77
      gi_common
      implicit_none_f90
      real cell_enter           // Function
      integer cell              // Input
      real x0[3],v[3]
      integer enter_face        // Output
      real x[3],v1[3],t         // Local
      integer n,ns
      external surface_intersect,cell_intersect,inside_cell,inside_cell_a,inside_surface // External
      real surface_intersect,cell_intersect
      logical inside_cell,inside_cell_a,inside_surface

      cell_enter=geom_infinity
      ns=0
      if (inside_cell(cell_info(cell),x0)) then // Already inside the cell
         vc_scale(-one,v,v1)    // Reverse $\vect v$
         cell_enter = -cell_intersect(cell_info(cell),x0,v1,enter_face) // and call |cell_intersect|
      else                      // On boundary or outside cell
         do n=cells[c_start,cell],cells[c_start,cell]+cells[c_faces,cell]-1
            if (inside_surface(surface_info(-boundaries[n]),x0)) then
               t=surface_intersect(surface_info(-boundaries[n]),x0,v)
               vc_xvt(x0,v,t,x)
               if ( inside_cell_a(cell_info(cell),boundaries[n],x) ) then
                  if ( t < cell_enter ) then
                     cell_enter=t
                     ns=n
                  end if
               end if
            end if
         end do
         if ( ns > 0 ) enter_face=ns
      end if

      return
      end

@* Locate point in geometry.  The first version |locate_point| assumes
that the geometry is consistent.  It returns the cell number of the
point, or $-1$ if the point is outside the universal cell.  The zone
number is returned as an argument.

@<Functions...@>=
      function locate_point(x,zone)
      implicit_none_f77
      gi_common
      implicit_none_f90
      integer locate_point      // Function
      real x[3]                 // Input
      integer zone              // Output

      integer k,c,cell1,cell2,sector1,sector2   // Local
      real x0[3],x1[3],v[3],t,tmax
      logical done
      external track,new_cell,cell_enter // External
      real cell_enter
      integer new_cell
      logical track
      
      external sloppy_inside    // External
      logical sloppy_inside
      
      vc_set(v,one,zero,zero)
      
      t=cell_enter(0,x,v,k)
      
      if (t > geom_epsilon) then
         locate_point = -1
         goto break
      end if
      
      vc_xvt(x,v,t,x0)
      c=new_cell(-k,x0)
      assert(c > 0)
      
      if (t >= zero) then
         locate_point=c
         goto break
      end if

      tmax=-t
      
loop: continue
      done=track(TRACK_BASIC,tmax,x0,v,c,t,x1,cell1,k,cell2,sector1,sector2)
      if (done) then
         locate_point=cell1
         goto break
      end if
      vc_copy(x1,x0)
      tmax=tmax-t
      c=cell2
      goto loop
      
break: continue
      if (locate_point > 0) then
         assert(sloppy_inside(cell_info(locate_point),x))
         zone=cells[c_zone,locate_point]
      else
         zone=-1
      end if


      return
      end

@ Now a more thorough check on the location of a point.  This checks the
point against all the cells.  In the event that the point lies in multiple
cells, it checks that the cells are neighbors.

@<Functions...@>=
      function check_point_x(x)
      implicit_none_f77
      gi_common
      implicit_none_f90
      logical check_point_x       // Function
      real x[3]                 // Input
      integer j,l               // Local
      logical interior,onface
      external sloppy_inside,inside_cell,cell_compare // External
      logical sloppy_inside,inside_cell
      integer cell_compare

      check_point_x=.false.
      interior=.false.
      onface=.false.

      if ( ! sloppy_inside(cell_info(0),x) ) then
         do j=1,ncells
            if (inside_cell(cell_info(j),x)) return
         end do
         check_point_x=.true.
      else
         do j=1,ncells
            l=cell_compare(cell_info(j),x)
            if (l >= 0) then
               if (interior) return // Already with another cell
               if (l > 0) then
                  if (onface) return // Already on face of another cell
                  interior=.true.
               else             // |l == 0|
                  onface=.true.
               end if
            end if
         end do
         check_point_x=onface || interior
      end if

      return
      end

@* A simple consistency checker for locations.

@<Functions...@>=
      function check_location(lc_dummy(x))
      implicit_none_f77
      gi_common
      implicit_none_f90
      logical check_location    // Function
      lc_decl(x)                // Input
      external sloppy_inside,face_in_cell,in_surface // External
      logical sloppy_inside,face_in_cell,in_surface
      
      check_location=.false.
      
      if (lc_cell(x) <= 0 || lc_cell(x) > ncells) return
      if (lc_zone(x) <= 0) return
      if (lc_zone(x) != cells[c_zone,lc_cell(x)]) return
      if (! sloppy_inside(cell_info(lc_cell(x)),lc_x(x)) ) return
      if (lc_face(x) != 0) then
         if (abs(lc_face(x)) > nsurfaces) return
         if (lc_cell_next(x) <= 0 || lc_cell(x) > ncells) return
         if (lc_zone_next(x) <= 0) return
         if (lc_zone_next(x) != cells[c_zone,lc_cell_next(x)]) return
         if (! sloppy_inside(cell_info(lc_cell_next(x)),lc_x(x)) ) return
         if (! in_surface(surface_info(lc_face(x)),lc_x(x),.false.,zero) ) return
         if (! face_in_cell(cell_info(lc_cell(x)),lc_face(x)) ) return
         if (! face_in_cell(cell_info(lc_cell_next(x)),-lc_face(x)) ) return
      end if
      check_location = .true.
      
      return
      end

@* Check zone number and type.  This used to be a simple macro, but
transformed it into code to avoid possibly referencing |zone_type(0)|.

@<Functions...@>=
      function check_zone(zn_dummy(x))
      implicit_none_f77
      zn_common
      implicit_none_f90
      logical check_zone    // Function
      zn_decl(x)            // Input

      check_zone=.false.
      if (x <= 0 || x > zn_num) return
      if (zn_type(x) <= 0 || zn_type(x) > zn_type_max) return
      check_zone=.true.

      return
      end

@* Read in the geometry specification from a netcdf file.

@<Functions...@>=
      subroutine read_geometry
      implicit_none_f77
      gi_common             // Common
      zn_common
      rf_common
      sc_common
      de_common
      mp_common
      implicit_none_f90
      nc_decls               // Local
      gi_ncdecl
      zn_ncdecl
      cm_ncdecl
      mp_decls
      @<Memory allocation interface@>
      sc_ncdecl
      de_ncdecl
      integer fileid
      character*FILELEN tempfile    //local

      if (mpi_master) then
         tempfile = filenames_array[geometryfile]
         assert(tempfile != char_undef)
         fileid = ncopen(tempfile,NC_NOWRITE,nc_stat)
         cm_ncread(fileid)
         gi_ncread(fileid)
         zn_ncread(fileid)
         sc_ncread(fileid)
         de_ncread(fileid)
         call ncclose(fileid,nc_stat)
      endif
      cm_mpibcast
      gi_mpibcast
      zn_mpibcast
      sc_mpibcast
      de_mpibcast
      return
      end

@* The basic transformation routines. Transform a position vector,
$\vect y = \tens M \cdot \vect x$.  $\vect x$ and $\vect y$ can overlap.
THIS SHOULD NOT BE ASSUMED.

@<Functions...@>=
      subroutine transform(m,x,y)
      implicit_none_f77
      implicit_none_f90
      real m[3,4],x[3]          // Input
      real y[3]                 // Output
      integer i                 // Local
      real temp[3]

      do i=1,3
         temp[i]=m[i,1]*x[1]+m[i,2]*x[2]+m[i,3]*x[3]+m[i,4]
      end do

      do i=1,3
         y[i]=temp[i]
      end do
      return
      end

@ Transform a velocity vector, $\vect w = \tens M \cdot \vect v$.  $\vect
x$ and $\vect y$ can overlap.  THIS SHOULD NOT BE ASSUMED.

@<Functions...@>=
      subroutine transform_velocity(m,v,w)
      implicit_none_f77
      implicit_none_f90
      real m[3,4],v[3]          // Input
      real w[3]                 // Output
      integer i                 // Local
      real temp[3]

      do i=1,3
         temp[i]=m[i,1]*v[1]+m[i,2]*v[2]+m[i,3]*v[3]
      end do

      do i=1,3
         w[i]=temp[i]
      end do
      return
      end

@* INDEX.
