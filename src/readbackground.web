% $Id: e96c08bdd2fa384156aaf14b2f60fa29bb7cf521 $
\Title{readbackground}


@* A program to read a background specification from a file.

\ID{$Id: e96c08bdd2fa384156aaf14b2f60fa29bb7cf521 $}

This program reads background plasma and neutral source data generated
by some other code and translates it into the format needed by
{\tt DEGAS 2}.  It is invoked with the command line

\begin{verbatim}
readbackground an_input_file
\end{verbatim}

This code currently accepts three types of input files:
\begin{enumerate}
  \item An input file for the original {\tt DEGAS} code.  The file specified
on the command line, \verb+an_input_file+, should end with 
\verb+.d+.
  \item A data transfer file generated by the {\tt UEDGE} code.  In this
case, \verb+an_input_file+ should end in \verb+.u+.  This usage is
consistent with the original implementation of |readbackground| in 
which only a single ion species is considered.
  \item An input file pointing to a data transfer file generated
by the {\tt UEDGE} code and providing additional descriptive information.
This option is selected by having \verb+an_input_file+ end in 
anything other than \verb+.d+ or \verb+.u+.
\end{enumerate}

The old {\tt DEGAS} option has been used infrequently of late, although
the {\tt DEGAS} - {\tt DEGAS 2} benchmark remains in the {\tt DEGAS 2}
examples. 
Consequently, newer {\tt DEGAS 2} features may not be available with this
option.

The {\tt UEDGE} data file is assumed to be in the format corresponding
to the {\tt UEDGE} subroutine |writemcnfile|.  M. Rensink has used
a {\tt BASIS} script to create functionally equivalent files that will
also work with this program.  Presently, this program can only handle
runs with two divertor targets, i.e., single null or symmetric
double null geometries.

The third option indicated above provides compatibility with 
multispecies {\tt UEDGE} runs and allows the user to specify plasma
parameters for {\tt DEGAS 2} zones filling the volume between the {\tt UEDGE}
mesh and surrounding solid zones (e.g., created with
|definegeometry2d|).  This input file is of the sort used
elsewhere in {\tt DEGAS 2}.  Namely, blank lines, spaces, and
lines beginning with the comment character \verb+#+ are 
ignored; comments can also appear at the end of a line.

Each line in the input file is of the form:

{\it keyword} {\tt arguments}

The available keywords are 

\begin{description}
  \item[|uedge_file|] {\tt filename} specifies the name of the {\tt UEDGE}
data file.  In this case, {\tt filename} does {\em not} need to end in
\verb+.u+.
  \item[|ion_species|] {\tt sp1} {\tt sp2} {\tt sp3} \ldots 
provides the list of ion species appearing in the {\tt UEDGE} run.  The
order of this list must correspond to the species ordering used
by {\tt UEDGE} in writing the file.  The strings provided here should
correspond to {\tt DEGAS 2} species symbols (i.e., to entries in
the |species_sy| array).  The code will ignore data corresponding to
unrecognized symbols; the code will generate a warning message in those
cases.  If a species is recognized, but not included
in the problem input file for the current {\tt DEGAS 2} run (e.g.,
an impurity species used in {\tt UEDGE}, but not in {\tt DEGAS 2}), its
density will be used to compute the electron density via quasineutrality.
Hence, to guarantee consistency of the electron density in {\tt DEGAS 2}
and {\tt UEDGE}, all pertinent species should be added to the 
{\tt DEGAS 2} reference species list.  The flow velocity for such
species will also be used in computing the total ion flow velocity that
is used in the sheath potential expression.
If a species in this list is recognized and is in the current problem
input file, its density and flow velocity data will be read into
the background density and velocity arrays.  Its (nonzero) fluxes to the
targets will be used to define source groups, one per species per
target.  These are always assumed to be plate (recycling) sources.
  \item[|bdy_ni|] {\tt sp} $i_{s}$ $n$ instructs the code to assign
ion species {\tt sp} (again, representing a species symbol; it must appear
in the |ion_species| keyword and in the current problem input
file) a density $n$ (in $m^{-3}$) in zones associated with stratum
$i_{s}$.  This stratum number corresponds to those used in 
|definegeometry2d|'s |stratum| keyword.  The stratum number
there acts as a label for all
zones created out of the polygon specified in conjunction with that
keyword.  Ensuring uniqueness of the stratum label is ultimately
the user's responsibility, although the code may catch some 
duplications.  The stratum labels are contained in the polygon
netCDF file generated by |definegeometry2d|; the name of this
file must be specified with the |polygon_file| keyword (see below).
  \item[|bdy_vr|] {\tt sp} $i_{s}$ $v_{r}$ instructs the code to assign
ion species {\tt sp}
a radial flow
velocity $v_{r}$ (in $m/s$) in zones associated with stratum
$i_{s}$.  The cylindrical components of the flow velocity are
provided; during {\tt DEGAS 2} execution, they resulting vector
is rotated to the toroidal angle where the information is needed.
  \item[|bdy_vphi|] {\tt sp} $i_{s}$ $v_{\phi}$ instructs the code to assign
ion species {\tt sp}
a radial flow
velocity $v_{\phi}$ (in $m/s$) in zones associated with stratum
$i_{s}$.  The cylindrical components of the flow velocity are
provided; during {\tt DEGAS 2} execution, they resulting vector
is rotated to the toroidal angle where the information is needed.
  \item[|bdy_vz|] {\tt sp} $i_{s}$ $v_{z}$ instructs the code to assign
ion species {\tt sp}
a radial flow
velocity $v_{z}$ (in $m/s$) in zones associated with stratum
$i_{s}$.  The cylindrical components of the flow velocity are
provided; during {\tt DEGAS 2} execution, they resulting vector
is rotated to the toroidal angle where the information is needed.
  \item[|bdy_ti|] $i_{s}$ $T_{i}$ instructs the code to assign an
ion temperature $T_{i}$ (in eV) to all ion species in the problem
(more specifically, all background species except electrons) in
zones associated with stratum $i_{s}$.
  \item[|bdy_te|] $i_{s}$ $T_{e}$ instructs the code to assign
an electron temperature $T_{e}$ (in eV) to zones associated with
stratum $i_{s}$.
  \item[|polygon_file|] {\tt filename} specified the name of the
polygon netCDF file generated |definegeometry2d|.  The information
in this file is needed to relate the stratum labels in the 
|bdy_ni|, etc. keywords to the zone numbers.
\end{description}
  
@m FILE 'readbackground.web'

@I macros.hweb
@I degas.hweb
@I geomint.hweb
@I readfilenames.hweb
@I sysdep.hweb
@I zone.hweb
@I problem.hweb
@I background.hweb
@I species.hweb
@I element.hweb
@I reaction.hweb
@I sources.hweb
@I string.hweb
@I netcdf.hweb
@I sector.hweb
@I materials.hweb

@ The unnamed module.
@f namelist integer

@a
      @<Functions and Subroutines@>

@ The main program

@<Functions...@>=
      program readbackground
      implicit_none_f77
      implicit_none_f90
      character*FILELEN datafilename

      call command_arg(1,datafilename)

      call process_background(datafilename)

      stop
      end

@ The main subroutine.

@<Functions...@>=
      subroutine process_background(datafilename)
      implicit_none_f77
      zn_common
      pr_common
      bk_common
      so_common
      gi_common
      mp_common
      implicit_none_f90
      mp_decls
      character*FILELEN datafilename,degasfilename,uedgefilename
      integer uedge,degas,update,geom_modified
@#if 0
      integer i,ii
@#endif
@#if MPI
      mpi_init
@#endif
      @<Memory allocation interface@>

      call readfilenames
      
      degas = FALSE 
      uedge = FALSE
/* 
   Find out whether the data file is DEGAS or UEDGE depending on 
   the extension of the file name.  Have now generalized the UEDGE 
   case to permit some additional options or information to be specified
   in a text file.  A DEGAS file is still denoted by a ``.d'' extension.
   To use just a UEDGE data file by itself, the user would have to give
   it a ``.u'' extension.
*/
      if (index(datafilename,'.d') > 0) then
         degasfilename = datafilename
         degas = TRUE
@#if 1
      else
         uedgefilename=datafilename
         uedge=TRUE
@#else
      else if (index(datafilename,'.u') > 0) then
         uedgefilename = datafilename
         uedge = TRUE
      else
         assert('File name must end in .d or .u' == ' ')
@#endif
      end if

      call read_geometry
            
      call nc_read_elements
      call nc_read_species
      call nc_read_materials
      call nc_read_reactions
      call nc_read_pmi
      call nc_read_problem

      call setup_back_arrays(geom_modified)

      so_grps=0
      so_seg_tot=0
      so_set_run_flags
      so_time_dependent=FALSE
      so_time_initialization=FALSE

      so_gparams_list_size=0
      so_gparams_list_dim=1
      so_params_list_size=0
      so_params_list_dim=1
      so_params_data_size=0
      so_params_data_dim=1
      so_giparams_list_size=0
      so_giparams_list_dim=1
      so_iparams_list_size=0
      so_iparams_list_dim=1
      so_iparams_data_size=0
      so_iparams_data_dim=1
      var_alloc(source_gparameters_list)
      var_alloc(source_parameters_list)
      var_alloc(source_gparameters_data)
      var_alloc(source_parameters_data)
      var_alloc(source_giparameters_list)
      var_alloc(source_iparameters_list)
      var_alloc(source_giparameters_data)
      var_alloc(source_iparameters_data)

      update=FALSE
      if (degas == TRUE) then
         call read_degas_background(degasfilename)
      elseif (uedge == TRUE) then
         call read_uedge_background(uedgefilename,update)         
      endif
/*
   Mindlessly copied this section from |defineback| following
   an allocation assertion in |set_background_sources|.

   Note that we do |var_reallocb| here so that |set_background_sources|
   can do an explicit |var_realloc| once the final |so_grps| is
   known.  The other (segment-based) arrays, however, will still
   be growing one segment at a time.
*/
      if (update == FALSE) then
         var_reallocb(source_base_ptr)
         var_reallocb(source_num_segments)
         var_reallocb(source_type)
         var_reallocb(source_geometry)
         var_reallocb(source_num_flights)
         var_reallocb(source_num_checkpoints)
         var_reallocb(source_species)
         var_reallocb(source_root_species)
         var_reallocb(source_time_variation)
         var_reallocb(source_num_gparameters)
         var_reallocb(source_num_parameters)
         var_reallocb(source_gparameters_base)
         var_reallocb(source_parameters_base)
         var_reallocb(source_parameters_data_base)
         var_reallocb(source_num_giparameters)
         var_reallocb(source_num_iparameters)
         var_reallocb(source_giparameters_base)
         var_reallocb(source_iparameters_base)
         var_reallocb(source_iparameters_data_base)
         var_reallocb(source_total_current)
         var_reallocb(source_weight_norm)
         var_reallocb(source_scale_factor)
      end if

      call add_cramd_data         // So we'll have recomb. rates

      call set_background_sources

      call init_wt_alias(uedge)   // Do likewise in boxgen?

      call write_background
/*
    Possibly relabeled vacuum zones.
*/
      if (geom_modified == TRUE) call write_geometry    

@#if MPI
      mpi_end
@#endif
      return
      end

@ Set up the background data using a DEGAS input file.

@m increment_params(num_params) so_params_list_size+=num_params;
         if (so_params_list_size > so_params_list_dim) then;
            var_realloc(source_parameters_list,so_params_list_dim,so_params_list_size);
            so_params_list_dim=so_params_list_size;
         end if @;

@<Functions...@>=
      subroutine read_degas_background(file)

      implicit_none_f77
      zn_common
      pr_common
      bk_common
      sp_common
      el_common
      rc_common
      so_common
      gi_common
      sc_common
      implicit_none_f90

      st_decls
      @<Memory allocation interface@>

      integer zone,jh,jv,js,jsp,jwall,jseg,seg,iparam // Local
      real xmin,xmax,zmin,zmax,curr_tot
      character*FILELEN file
      logical new_group
      sp_decl(sp_hyd[3])
      sp_decl(degas_species[9])
      sc_decl(sector)
      vc_decl(x1)
      vc_decl(x2)

      external lookup_sector,neutralize_species
      integer lookup_sector,neutralize_species

      @<pardef.h@>
      @<combal.h@>
      @<comst.h@>
      @<comgeo.h@>
      @<compls.h@>
      @<comflg.h@>
      @<comrfl.h@>
      @<comrat.h@>
      @<comsv.h@>
      @<comstat.h@>
      @<compar.h@>

      open(unit=diskin,file=file,status='old',form='formatted')

      call inpt(diskin,geometry_symmetry,xmin,xmax,zmin,zmax)
      close(unit=diskin)

      sp_hyd[1]=sp_lookup('H')
      sp_hyd[2]=sp_lookup('D')
      sp_hyd[3]=sp_lookup('T')
      nohyds=0                                                       
      do js=1,nphyd
         if (nhyd[js] != 0) nohyds=nohyds+1
      end do
      if (nohyds == 1) then
         degas_species[1]=sp_hyd[nhyd[1]]
         degas_species[2]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[1]])) \/ '2')
      else if (nohyds == 2) then
         degas_species[1]=sp_hyd[nhyd[1]]
         degas_species[2]=sp_hyd[nhyd[2]]
         degas_species[3]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[1]])) \/ '2')
         degas_species[4]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[1]])) \/ 
     $        trim(sp_sy(sp_hyd[nhyd[2]])))
         if (degas_species[4] == 0) then
            degas_species[4]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[2]])) \/ 
     $           trim(sp_sy(sp_hyd[nhyd[1]])))
         end if
         degas_species[5]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[2]])) \/ '2')
      else if (nohyds == 3) then
         degas_species[1]=sp_hyd[nhyd[1]]
         degas_species[2]=sp_hyd[nhyd[2]]
         degas_species[3]=sp_hyd[nhyd[3]]
         degas_species[4]=sp_lookup(sp_sy(sp_hyd[nhyd[1]]) \/ '2')
         degas_species[5]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[1]])) \/ 
     $        trim(sp_sy(sp_hyd[nhyd[2]])))
         if (degas_species[5] == 0) then
            degas_species[5]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[2]])) \/ 
     $           trim(sp_sy(sp_hyd[nhyd[1]])))
         end if
         degas_species[6]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[2]])) \/ '2')
         degas_species[7]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[1]])) \/ 
     $        trim(sp_sy(sp_hyd[nhyd[3]])))
         if (degas_species[7] == 0) then
            degas_species[7]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[3]])) \/ 
     $           trim(sp_sy(sp_hyd[nhyd[1]])))
         end if
         degas_species[8]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[2]])) \/ 
     $        trim(sp_sy(sp_hyd[nhyd[3]])))
         if (degas_species[8] == 0) then
            degas_species[8]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[3]])) \/ 
     $           trim(sp_sy(sp_hyd[nhyd[2]])))
         end if
         degas_species[9]=sp_lookup(trim(sp_sy(sp_hyd[nhyd[3]])) \/ '2')
      end if
      assert(npis <= 9)    // Assume no impurity species !!

      assert(sp_sy(pr_background(1))=='e')
      do zone=1,zn_num
         if (zn_type(zone) == zn_plasma) then
            jh=zn_index(zone,1)
            jv=zn_index(zone,2)
/* Check that both |jh| and |jv| are valid. If not, could set some default */
            assert(jh*jv != 0)       
            bk_n(1,zone)=denehvt[jh,jv,1]
            bk_temp(1,zone)=electron_charge*tehvt[jh,jv,1]
            vc_set(bk_v(1,zone),zero,zero,zero)
            do js=1,nohyds
/* This assumes only singly charged ions. Same assumption made below. */
               jsp=pr_background_lookup(sp_lookup(trim(sp_sy(degas_species[js])) \/ '+'))
               assert(jsp > 1)
               bk_n(jsp,zone)=denihvt[jh,jv,1,js]
               bk_temp(jsp,zone)=electron_charge*tihvt[jh,jv,1,js]
               vc_set(bk_v(jsp,zone),zero,zero,zero)
            end do
         end if
      end do
/* 
   DEGAS only uses cartesian flow velocities 
*/
      background_coords=plasma_coords_cartesian
                                                       
      do js=1,npis
         do jwall=1,nowals
            new_group=.true.
            curr_tot=zero
            do jseg=1,nosegsxz[jwall]
               curr_tot+=abs(currxzt[jseg,1,jwall,js])
            end do
            if (curr_tot > zero) then
               do jseg=1,nosegsxz[jwall]
                  if (new_group) then
                     so_grps++
                     var_realloca(source_base_ptr)
                     var_realloca(source_num_segments)
                     var_realloca(source_type)
                     var_realloca(source_geometry)
                     var_realloca(source_num_flights)
                     var_realloca(source_num_checkpoints)
                     var_realloca(source_species)
                     var_realloca(source_root_species)
                     var_realloca(source_time_variation)

                     var_realloca(source_num_gparameters)
                     var_realloca(source_num_parameters)
                     var_realloca(source_gparameters_base)
                     var_realloca(source_parameters_base)
                     var_realloca(source_parameters_data_base)
                     var_realloca(source_num_giparameters)
                     var_realloca(source_num_iparameters)
                     var_realloca(source_giparameters_base)
                     var_realloca(source_iparameters_base)
                     var_realloca(source_iparameters_data_base)

                     var_realloca(source_total_current)
                     var_realloca(source_weight_norm)
                     var_realloca(source_scale_factor)
                     so_base(so_grps)=so_seg_tot+1
                     so_nseg(so_grps)=nosegsxz[jwall]
                     so_nflights(so_grps)=100
                     so_chkpt(so_grps)=0
                     so_t_varn(so_grps)=so_delta_fn

                     source_num_gparameters[so_grps]=0
                     source_num_parameters[so_grps]=0
                     source_gparameters_base[so_grps]=so_gparams_list_size
                     source_parameters_base[so_grps]=so_params_list_size
                     source_parameters_data_base[so_grps]=so_params_data_size
                     source_num_giparameters[so_grps]=0
                     source_num_iparameters[so_grps]=0
                     source_giparameters_base[so_grps]=so_giparams_list_size
                     source_iparameters_base[so_grps]=so_iparams_list_size
                     source_iparameters_data_base[so_grps]=so_iparams_data_size
/*
   Assume these are same for all segments: 
*/
                     if (currxzt[jseg,1,jwall,js] > zero) then 
                        so_type(so_grps)=so_plate  
                        so_root_sp(so_grps)=
     $                       sp_lookup(trim(sp_sy(degas_species[js])) \/ '+')
                        so_species(so_grps)=
     $                       neutralize_species(so_root_sp(so_grps))
                        source_num_parameters[so_grps]=3            // Placeholder only
                        increment_params(source_num_parameters[so_grps])
                        so_params_list(1,so_grps)=so_param_e_ion_delta
                        so_params_list(2,so_grps)=so_param_e_ion_mult
                        so_params_list(3,so_grps)=so_param_e_ion_sheath
                     else                                    
                        so_type(so_grps)=so_puff 
                        so_species(so_grps)=degas_species[js]
                        so_root_sp(so_grps)=degas_species[js]
                        source_num_gparameters[so_grps]=2
                        so_gparams_list_size+=source_num_gparameters[so_grps]
                        if (so_gparams_list_size > so_gparams_list_dim) then
                           var_realloc(source_gparameters_list,
     $                          so_gparams_list_dim,so_gparams_list_size)
                           var_realloc(source_gparameters_data,
     $                          so_gparams_list_dim,so_gparams_list_size)
                           so_gparams_list_dim=so_gparams_list_size
                        end if
                        so_gparams_list(1,so_grps)=so_gparam_puff_temp
                        so_gparams_data(1,so_grps)=t0puff[js]*electron_charge
                        so_gparams_list(2,so_grps)=so_gparam_puff_exponent
                        so_gparams_data(2,so_grps)=one   // Hardwired !
                     end if
                     assert(so_species(so_grps) > 0)
                     so_geom(so_grps)=so_surface
                     so_tot_curr(so_grps)=zero
                     so_scale(so_grps)=one       // Default
                     seg=so_seg_tot
                     so_seg_tot+=nosegsxz[jwall]
                     var_reallocc(source_current,seg,so_seg_tot)
                     var_reallocc(source_segment_ptr,seg,so_seg_tot)
                     var_reallocc(source_segment_rel_wt,seg,so_seg_tot)
                     var_reallocc(source_segment_prob_alias,seg,so_seg_tot)
                     var_reallocc(source_segment_ptr_alias,seg,so_seg_tot)
                     new_group=.false.
                  end if
/*
   Any reason not to exclude segments with zero current? 
*/
                  if ((xwall(jseg,jwall) != xwall(jseg+1,jwall)
     $                 || zwall(jseg,jwall) != zwall(jseg+1,jwall))
     $                 && currxzt[jseg,1,jwall,js] != zero) then
                     seg++
                     source_current[seg]=abs(currxzt[jseg,1,jwall,js])
                     so_tot_curr(so_grps)+=source_current[seg]

                     vc_set(x1,xwall(jseg,jwall),zero,zwall(jseg,jwall))
                     vc_set(x2,xwall(jseg+1,jwall),zero,zwall(jseg+1,jwall))
                     sector=lookup_sector(x2,x1)
                     assert(sc_check(sector))
                     if (so_type(so_grps) == so_plate) then
                        assert(source_num_parameters[so_grps] > 0) // Should be 3 !
                        so_params_data_size+=source_num_parameters[so_grps]
                        if (so_params_data_size > so_params_data_dim) then
                           var_realloc(source_parameters_data,so_params_data_dim,
     $                          so_params_data_size)
                           so_params_data_dim=so_params_data_size
                        end if
/*
   Set incident ion description to be $3 T_{e}$ (sheath potential) plus
   $1 \times E_{\rm ion}$ with $E_{\rm ion}$ sampled from a Maxwellian.
*/
                        do iparam=1,source_num_parameters[so_grps]
                           if (so_params_list(iparam,so_grps) 
     $                          == so_param_e_ion_delta) then
                              so_params_data(iparam,seg,so_grps)
     $                             =const(3.)*bk_temp(1,sector_zone[sector])
                           else if (so_params_list(iparam,so_grps) 
     $                             == so_param_e_ion_sheath) then
                              so_params_data(iparam,seg,so_grps)=zero
                           else if (so_params_list(iparam,so_grps) 
     $                             == so_param_e_ion_mult) then
                              so_params_data(iparam,seg,so_grps)=one
                           end if
                        end do
                     end if
                     source_segment_ptr[seg]=sector
                  else
                     so_nseg(so_grps)--
                     so_seg_tot--
                  end if
               end do
            end if
         end do
      end do

      return
      end

