% $Id: 0f16e28dfeb8a48d994d5a4a9dcd0f00f93fcbd2 $
\Title{writeback}

@* Routines used by readbackground, etc. 

\ID{$Id: 0f16e28dfeb8a48d994d5a4a9dcd0f00f93fcbd2 $}

The principal routines in this file are those used to read and interpret
{\tt UEDGE} data files.  Their functionality is documented in 
|readbackground|.

@m FILE 'writeback.web'

@I macros.hweb
@I readfilenames.hweb
@I netcdf.hweb
@I element.hweb
@I species.hweb
@I sysdep.hweb
@I string.hweb
@I vector.hweb
@I background.hweb
@I geomint.hweb
@I sources.hweb
@I particle.hweb
@I location.hweb
@I random.hweb
@I problem.hweb
@I zone.hweb
@I sector.hweb
@I reaction.hweb
@I materials.hweb
@I geometry2d.hweb
@I mpi.hweb
@I snapshot_pdf.hweb

@m OLD_UEDATA 0    //  Set to 1 if file does not contain ghost cell data

@m GPI_WEIGHTING 0  // Set to 1 for synthetic GPI weighting

@m increment_params(num_params) so_params_list_size+=num_params;
         if (so_params_list_size > so_params_list_dim) then;
            var_realloc(source_parameters_list,so_params_list_dim,so_params_list_size);
            so_params_list_dim=so_params_list_size;
         end if @;

@ The unnamed module.

@a
      @<Functions and Subroutines@>

@ Read UEDGE background data.  This routine acts as a main routine,
calling separate subroutines to read the UEDGE file and to do most
of the source definition.

@<Functions...@>=
      subroutine read_uedge_background(file,update)

      implicit_none_f77
      sp_common                                  // Common
      so_common
      sc_common
      pr_common
      bk_common
      implicit_none_f90
      integer update                             // Input
      character*FILELEN file                 
                                               
      integer nx,ny,nxpt,ns                      // Local; UEDGE file data:
      integer ixlb[bk_xpt],ixrb[bk_xpt]
      real rm[bk_mx,bk_my,0:4],zm[bk_mx,bk_my,0:4],
     $     ni[bk_mx,bk_my,bk_ms],vr[bk_mx,bk_my,bk_ms],
     $     vz[bk_mx,bk_my,bk_ms],vphi[bk_mx,bk_my,bk_ms],
     $     te[bk_mx,bk_my],ti[bk_mx,bk_my],
     $     ni1[bk_my,bk_ms,bk_xpt],vr1[bk_my,bk_ms,bk_xpt],
     $     vz1[bk_my,bk_ms,bk_xpt],vphi1[bk_my,bk_ms,bk_xpt],
     $     ti1[bk_my,bk_xpt],te1[bk_my,bk_xpt],flux1[bk_my,bk_ms,bk_xpt],
     $     ni2[bk_my,bk_ms,bk_xpt],vr2[bk_my,bk_ms,bk_xpt],
     $     vz2[bk_my,bk_ms,bk_xpt],vphi2[bk_my,bk_ms,bk_xpt],
     $     ti2[bk_my,bk_xpt],te2[bk_my,bk_xpt],flux2[bk_my,bk_ms,bk_xpt],
     $     flux1_tot[bk_ms,bk_xpt],flux2_tot[bk_ms,bk_xpt]

      character*sp_sy_len uedge_species[bk_ms]
      integer tot,js,isp,sp_back,itarg,grp,ixpt  // Other local
      integer flux1_present[bk_xpt],flux2_present[bk_xpt],
     $        group_map[2,bk_ms,bk_xpt]

      st_decls
      @<Memory allocation interface@>

      external neutralize_species      // External
      integer neutralize_species
      
      call init_uedge_background(file,nx,ny,nxpt,ixlb,ixrb,rm,zm,ni,
     $     vr,vz,vphi,ti,te,ni1,vr1,vz1,vphi1,ti1,te1,flux1,ni2,vr2,vz2,
     $     vphi2,ti2,te2,flux2,flux1_tot,flux2_tot,ns,uedge_species)
/*
   Make an initial survey of the source groups needed, recording the
   results in the |group_map| array.
*/
      so_grps=0
      so_seg_tot=0
      do ixpt=1,nxpt
         flux1_present[ixpt]=FALSE
         flux2_present[ixpt]=FALSE
         do js=1,ns
            group_map[1,js,ixpt]=int_undef
            group_map[2,js,ixpt]=int_undef
            isp=sp_lookup(uedge_species[js])
            if (sp_check(isp)) then
               sp_back=pr_background_lookup(isp)
               if (bk_check(sp_back)) then
                  if (flux1_tot[js,ixpt] > zero) then
                     so_grps++
                     so_seg_tot+=ny
                     group_map[1,js,ixpt]=so_grps
                     flux1_present[ixpt]=TRUE
                  end if
                  if (flux2_tot[js,ixpt] > zero) then
                     so_grps++
                     so_seg_tot+=ny
                     group_map[2,js,ixpt]=so_grps
                     flux2_present[ixpt]=TRUE
                  end if
               end if
            end if
         end do
      end do
      if (so_grps == 0) then
         assert('Zero fluxes in UEDGE background' == ' ')
      end if
      if (update == TRUE) then
/*
   Need to initialize these since |set_uedge_plate_sources| uses
   the ``+='' operator.  All of the other variables set below
   for the not-update case retain their values as read in from
   the old sources file.
*/
         do grp=1,so_grps
            so_tot_curr(grp)=zero
         end do
      else
         so_set_run_flags
/*
   We are using |var_reallocc| here so that we are allocating
   memory in |mem_inc| chunks in every case.  This is needed 
   to permit this to work with |defineback| which will call
   |var_reallocb| later on; it assumes this sort of initial
   allocation.
*/
         var_reallocc(source_base_ptr,0,so_grps)
         var_reallocc(source_num_segments,0,so_grps)
         var_reallocc(source_type,0,so_grps)
         var_reallocc(source_geometry,0,so_grps)
         var_reallocc(source_num_flights,0,so_grps)
         var_reallocc(source_num_checkpoints,0,so_grps)
         var_reallocc(source_species,0,so_grps)
         var_reallocc(source_root_species,0,so_grps)
         var_reallocc(source_time_variation,0,so_grps)

         var_reallocc(source_num_gparameters,0,so_grps)
         var_reallocc(source_num_parameters,0,so_grps)
         var_reallocc(source_gparameters_base,0,so_grps)
         var_reallocc(source_parameters_base,0,so_grps)
         var_reallocc(source_parameters_data_base,0,so_grps)
         var_reallocc(source_num_giparameters,0,so_grps)
         var_reallocc(source_num_iparameters,0,so_grps)
         var_reallocc(source_giparameters_base,0,so_grps)
         var_reallocc(source_iparameters_base,0,so_grps)
         var_reallocc(source_iparameters_data_base,0,so_grps)

         var_reallocc(source_total_current,0,so_grps)
         var_reallocc(source_weight_norm,0,so_grps)
         var_reallocc(source_scale_factor,0,so_grps)

         var_reallocc(source_segment_ptr,0,so_seg_tot)
         var_reallocc(source_current,0,so_seg_tot)
         var_reallocc(source_segment_rel_wt,0,so_seg_tot)
         var_reallocc(source_segment_prob_alias,0,so_seg_tot)
         var_reallocc(source_segment_ptr_alias,0,so_seg_tot)
/*
   Can set all of the group-wide variables, except total current. 
   Can initialize total current; note that in |update_uedge_background|,
   this is done in section analogous to above (before allocations).
*/
         tot=0
         do ixpt=1,nxpt
            do js=1,ns
               do itarg=1,2
                  if (group_map[itarg,js,ixpt] != int_undef) then
                     grp=group_map[itarg,js,ixpt]
                     so_root_sp(grp)=sp_lookup(uedge_species[js])
                     assert(sp_check(so_root_sp(grp)))
                     so_t_varn(grp)=so_delta_fn
                     so_species(grp)=neutralize_species(so_root_sp(grp))
                     assert(sp_check(so_species(grp)))
                     so_tot_curr(grp)=zero
                     so_type(grp)=so_plate
                     so_nseg(grp)=ny
                     so_geom(grp)=so_surface
                     so_scale(grp)=one
                     so_nflights(grp)=100
                     so_chkpt(grp)=0
                     so_base(grp)=tot+1
                     tot+=ny
                     source_num_gparameters[grp]=0
                     source_gparameters_base[grp]=so_gparams_list_size
                     source_parameters_base[grp]=so_params_list_size
/*
   Just an initialization; |so_params_data_size| is trivial here.
*/      
                     source_parameters_data_base[grp]=so_params_data_size
                     source_num_giparameters[grp]=0
                     source_num_iparameters[grp]=0
                     source_giparameters_base[grp]=so_giparams_list_size
                     source_iparameters_base[grp]=so_iparams_list_size
                     source_iparameters_data_base[grp]=so_iparams_data_size

                     source_num_parameters[grp]=3       
                     increment_params(source_num_parameters[grp])
                     so_params_list(1,grp)=so_param_e_ion_delta
                     so_params_list(2,grp)=so_param_e_ion_mult
                     so_params_list(3,grp)=so_param_e_ion_sheath
                  end if
               end do
            end do
         end do
      end if

      call set_uedge_plate_sources(nx,ny,nxpt,ixlb,ixrb,
     $     ns,uedge_species,rm,zm,
     $     ni1,vr1,vz1,vphi1,te1,ti1,flux1,
     $     ni2,vr2,vz2,vphi2,te2,ti2,flux2,
     $     flux1_present,flux2_present,group_map,update)

      return
      end

@ Read UEDGE input file and set up corresponding background data.

@m open_file(aunit,aname)    open(unit=aunit,file=aname,status='old',form='formatted',iostat=open_stat);
            if (open_stat != 0) then;
         write (stderr,*) ' Cannot open file ',aname,', error number ',open_stat;
         return;
      end if @;

@m species_loop #:0

@<Functions...@>=
      subroutine init_uedge_background(file,nx,ny,nxpt,ixlb,ixrb,rm,zm,ni,
     $     vr,vz,vphi,ti,te,ni1,vr1,vz1,vphi1,ti1,te1,flux1,ni2,vr2,vz2,
     $     vphi2,ti2,te2,flux2,flux1_tot,flux2_tot,ns,uedge_species)

      define_dimen(stratum_ind,dim_stratum)
      define_dimen(species_ind,bk_ms)

      define_varp(bdy_ni,FLOAT,species_ind,stratum_ind)
      define_varp(bdy_vr,FLOAT,species_ind,stratum_ind)
      define_varp(bdy_vz,FLOAT,species_ind,stratum_ind)
      define_varp(bdy_vphi,FLOAT,species_ind,stratum_ind)
      define_varp(bdy_ti,FLOAT,stratum_ind)
      define_varp(bdy_te,FLOAT,stratum_ind)
      define_varp(stratum_list,INT,stratum_ind)

      define_varp(zone_stratum,INT,zone_ind)

      implicit_none_f77
      zn_common                                       // Common
      bk_common
      sp_common
      pr_common
      g2_common
      implicit_none_f90

      character*FILELEN file                          // Input

      integer nx,ny,nxpt,ns                           // Output
      integer ixlb[bk_xpt],ixrb[bk_xpt]
      real rm[bk_mx,bk_my,0:4],zm[bk_mx,bk_my,0:4],
     $     ni[bk_mx,bk_my,bk_ms],vr[bk_mx,bk_my,bk_ms],
     $     vz[bk_mx,bk_my,bk_ms],vphi[bk_mx,bk_my,bk_ms],
     $     te[bk_mx,bk_my],ti[bk_mx,bk_my],
     $     ni1[bk_my,bk_ms,bk_xpt],vr1[bk_my,bk_ms,bk_xpt],
     $     vz1[bk_my,bk_ms,bk_xpt],vphi1[bk_my,bk_ms,bk_xpt],
     $     ti1[bk_my,bk_xpt],te1[bk_my,bk_xpt],flux1[bk_my,bk_ms,bk_xpt],
     $     ni2[bk_my,bk_ms,bk_xpt],vr2[bk_my,bk_ms,bk_xpt],
     $     vz2[bk_my,bk_ms,bk_xpt],vphi2[bk_my,bk_ms,bk_xpt],
     $     ti2[bk_my,bk_xpt],te2[bk_my,bk_xpt],flux2[bk_my,bk_ms,bk_xpt],
     $     flux1_tot[bk_ms,bk_xpt],flux2_tot[bk_ms,bk_xpt]
      character*sp_sy_len uedge_species[bk_ms]

      integer nu,i,j1,j2,j3,js,                       // Local
     $        sp_back,length,p,b,e,nstratum,is,open_stat,
     $        fileid,ipoly,isp,dim_stratum,stratum,
     $        species_index,stratum_index,zone,first_zone,
     $        match,diskin2,ixpt
      integer iysptrx1[bk_xpt],iysptrx2[bk_xpt],ixpt1[bk_xpt],
     $     ixmdp[bk_xpt],ixpt2[bk_xpt]
      real zone_ni[bk_ms],zone_vr[bk_ms],zone_vz[bk_ms],
     $     zone_vphi[bk_ms]
      real dummy,zone_ti,zone_te,zone_ne
      character*LINELEN line,keyword
      character*FILELEN uedge_file,polygon_file

      declare_varp(bdy_ni)
      declare_varp(bdy_vr)
      declare_varp(bdy_vz)
      declare_varp(bdy_vphi)
      declare_varp(bdy_ti)
      declare_varp(bdy_te)
      declare_varp(stratum_list)

      declare_varp(zone_stratum)

      @<Memory allocation interface@>
      st_decls
      g2_ncdecl
      nc_decls
      vc_decls
      zn_decls
/*
   To permit these to be reallocated by any of the three possible macros,
   helps to make the initial allocation of size |mem_inc|. 
*/
      dim_stratum=mem_inc

      var_alloc(bdy_ni)
      var_alloc(bdy_vr)
      var_alloc(bdy_vz)
      var_alloc(bdy_vphi)
      var_alloc(bdy_ti)
      var_alloc(bdy_te)
      var_alloc(stratum_list)
      
      var_alloc(zone_stratum) 
/*
   Initializations / defauls
*/
      background_coords=plasma_coords_cylindrical
      uedge_file=char_uninit
      ns=0
      polygon_file=char_uninit
      nstratum=0
      diskin2=diskin+2
/*
   Check to see whether the input file is a UEDGE data file or a text
   file with keywords.
*/
      if (index(file,'.u') > 0) then
/* 
   If this is just a UEDGE data file, have to assume that only one
   ion species is present since we cannot guarantee the correct order
   without a specific list.  For consistency with older versions of
   this code, the species is D$^{+}$.
*/
         uedge_file=file
         ns=1
         uedge_species[ns]='D+'
      else
/*
   Otherwise, this is a keyword file.  The following is then the
   loop over keywords.
*/
         open_file(diskin2,file)
loop1: continue
         if (read_string(diskin2,line,length)) then
            assert(length<=len(line))
            length=parse_string(line(:length))
            p=0
            assert(next_token(line,b,e,p))
            keyword=line(b:e)

            if (keyword == 'uedge_file') then
               assert(next_token(line,b,e,p))
               uedge_file=line(b:e)

            else if (keyword == 'ion_species') then
species_loop: continue
               if (next_token(line,b,e,p)) then
                  ns++
/*
   Check |ns| against dimension of |uedge_species|.
*/
                  assert(ns <= bk_ms)
                  uedge_species[ns]=line(b:e)
                  go to species_loop
               end if

            else if (keyword == 'polygon_file') then
               assert(next_token(line,b,e,p))
               polygon_file=line(b:e)

            else if (keyword == 'bdy_ni') then
               assert(next_token(line,b,e,p))
               @<Get Species Index@>
               assert(species_index > 0)
               assert(next_token(line,b,e,p))
               stratum=read_integer(line(b:e))
               @<Get Stratum Index@>
               assert((stratum_index > 0)  && (stratum_index <= nstratum))
               assert(next_token(line,b,e,p))
               bdy_ni[stratum_index][species_index]=read_real(line(b:e))
               assert(bdy_ni[stratum_index][species_index] >= zero)

            else if (keyword == 'bdy_vr') then
               assert(next_token(line,b,e,p))
               @<Get Species Index@>
               assert(species_index > 0)
               assert(next_token(line,b,e,p))
               stratum=read_integer(line(b:e))
               @<Get Stratum Index@>
               assert((stratum_index > 0)  && (stratum_index <= nstratum))
               assert(next_token(line,b,e,p))
               bdy_vr[stratum_index][species_index]=read_real(line(b:e))
               
            else if (keyword == 'bdy_vz') then
               assert(next_token(line,b,e,p))
               @<Get Species Index@>
               assert(species_index > 0)
               assert(next_token(line,b,e,p))
               stratum=read_integer(line(b:e))
               @<Get Stratum Index@>
               assert((stratum_index > 0)  && (stratum_index <= nstratum))
               assert(next_token(line,b,e,p))
               bdy_vz[stratum_index][species_index]=read_real(line(b:e))
               
            else if (keyword == 'bdy_vphi') then
               assert(next_token(line,b,e,p))
               @<Get Species Index@>
               assert(species_index > 0)
               assert(next_token(line,b,e,p))
               stratum=read_integer(line(b:e))
               @<Get Stratum Index@>
               assert((stratum_index > 0)  && (stratum_index <= nstratum))
               assert(next_token(line,b,e,p))
               bdy_vphi[stratum_index][species_index]=read_real(line(b:e))

            else if (keyword == 'bdy_ti') then
               assert(next_token(line,b,e,p))
               stratum=read_integer(line(b:e))
               @<Get Stratum Index@>
               assert((stratum_index > 0)  && (stratum_index <= nstratum))
               assert(next_token(line,b,e,p))
               bdy_ti[stratum_index]=read_real(line(b:e))*electron_charge
               assert(bdy_ti[stratum_index] >= zero)

            else if (keyword == 'bdy_te') then
               assert(next_token(line,b,e,p))
               stratum=read_integer(line(b:e))
               @<Get Stratum Index@>
               assert((stratum_index > 0)  && (stratum_index <= nstratum))
               assert(next_token(line,b,e,p))
               bdy_te[stratum_index]=read_real(line(b:e))*electron_charge
               assert(bdy_te[stratum_index] >= zero)

            else
               assert('Unrecognized keyword' == ' ')
            end if
            go to loop1
         end if
         close(unit=diskin2)
      end if
/*
   Read UEDGE data file.  The variable list and format now match
   that in UEDGE subroutine |writemcnfile|.  Note that only |nx| and
   |ny| are needed here, although |nxpt| is needed to loop over
   X-point parameters.
*/
      open_file(diskin2,uedge_file)
      nu=diskin2
/* skip first comment line */
      read(nu,*)
      read(nu,*) nx,ny,nxpt
      assert((nxpt >= 1) && (nxpt <= bk_xpt))
      do i=1,nxpt
         read(nu,*) iysptrx1[i], iysptrx2[i]
         read(nu,*) ixlb[i], ixpt1[i], ixmdp[i], ixpt2[i], ixrb[i]
      end do
      assert(nx <= bk_mx && ny <= bk_my)

      read(nu,*) SP (((rm[j1,j2,j3],j1=1,nx),j2=1,ny),j3=0,4)
      read(nu,*) SP (((zm[j1,j2,j3],j1=1,nx),j2=1,ny),j3=0,4)
/* 
   Skip data for br,bz,bphi 
*/
      do i=1,3
         read(nu,*) SP (((dummy,j1=1,nx),j2=1,ny),j3=0,4)
      enddo
      do js=1,ns
         read (nu,*,err= 6)SP ((ni[j1,j2,js],j1=1,nx),j2=1,ny)
      end do
      do js=1,ns
         read (nu,*,err= 6)SP ((vr[j1,j2,js],j1=1,nx),j2=1,ny)
      end do
      do js=1,ns
         read (nu,*,err= 6)SP ((vz[j1,j2,js],j1=1,nx),j2=1,ny)
      end do
      do js=1,ns
         read (nu,*,err= 6)SP ((vphi[j1,j2,js],j1=1,nx),j2=1,ny)
      end do
      read (nu,*,err= 6)SP ((ti[j1,j2],j1=1,nx),j2=1,ny)
      read (nu,*,err= 6)SP ((te[j1,j2],j1=1,nx),j2=1,ny)
@#if !OLD_UEDATA
      do ixpt=1,nxpt
         do js=1,ns
            read (nu,*,err= 6)SP (ni1[j2,js,ixpt],j2=1,ny)
         end do
         do js=1,ns
            read (nu,*,err= 6)SP (vr1[j2,js,ixpt],j2=1,ny)
         end do
         do js=1,ns
            read (nu,*,err= 6)SP (vz1[j2,js,ixpt],j2=1,ny)
         end do
         do js=1,ns
            read (nu,*,err= 6)SP (vphi1[j2,js,ixpt],j2=1,ny)
         end do
         read (nu,*,err= 6)SP (ti1[j2,ixpt],j2=1,ny)
         read (nu,*,err= 6)SP (te1[j2,ixpt],j2=1,ny)
         do js=1,ns
            read (nu,*,err= 6)SP (flux1[j2,js,ixpt],j2=1,ny)
         end do
         do js=1,ns
            read (nu,*,err= 6)SP (ni2[j2,js,ixpt],j2=1,ny)
         end do
         do js=1,ns
            read (nu,*,err= 6)SP (vr2[j2,js,ixpt],j2=1,ny)
         end do
         do js=1,ns
            read (nu,*,err= 6)SP (vz2[j2,js,ixpt],j2=1,ny)
         end do
         do js=1,ns
            read (nu,*,err= 6)SP (vphi2[j2,js,ixpt],j2=1,ny)
         end do
         read (nu,*,err= 6)SP (ti2[j2,ixpt],j2=1,ny)
         read (nu,*,err= 6)SP (te2[j2,ixpt],j2=1,ny)
         do js=1,ns
            read (nu,*,err= 6)SP (flux2[j2,js,ixpt],j2=1,ny)
         end do
@#else
      read (nu,*,err= 6)SP ((flux1[j2,js,ixpt],j2=1,ny),js=1,ns)
      read (nu,*,err= 6)SP ((flux2[j2,js,ixpt],j2=1,ny),js=1,ns)
@#endif
      end do                // Over |ixpt|
      close(unit=diskin2)
/*
   Get stratum numbers for each zone from polygon netCDF file 
   (if specified).  This is needed to assign the boundary plasma values.
*/
      do zone=1,zn_num
         zone_stratum[zone]=int_unused
      end do
      if (polygon_file != char_uninit) then
         fileid=ncopen(polygon_file,NC_NOWRITE,nc_stat)
         g2_ncread(fileid)
         do ipoly=1,g2_num_polygons
            zone=g2_polygon_zone[ipoly]
            if (zone_stratum[zone] == int_unused) then
               assert(g2_polygon_stratum[ipoly] >= 0)  // Do we need this?
               zone_stratum[zone]=g2_polygon_stratum[ipoly]
            else                                       // Or this?
/*
   Typically use a single zone for all solid polygons, even from different
   strata.  This check for unique stratum numbers is really only needed
   for plasma zones.
*/
               assert((zone_stratum[zone] == g2_polygon_stratum[ipoly])
     $              || (zn_type(zone) != zn_plasma))
            end if
         end do
      else
         if (nstratum > 0) write(stderr,*) 'Need to specify polygon.nc file to set boundary parameters!'
      end if
      if (nstratum > 0) then
         dim_stratum=nstratum
         var_reallocb(bdy_ni)
         var_reallocb(bdy_vr)
         var_reallocb(bdy_vz)
         var_reallocb(bdy_vphi)
         var_reallocb(bdy_ti)
         var_reallocb(bdy_te)
         var_reallocb(stratum_list)
      end if
/*
   Assign plasma parameters to each zone.  Species related warning messages
   are printed only when the flag |first_zone| is |TRUE|.  The flag is
   changed to |FALSE| once the first plasma zone has been processed, 
   eliminating repetitive messages.
*/
      first_zone=TRUE
      do zone=1,zn_num
         assert(zn_check(zone))
         if (zn_type(zone) == zn_plasma) then
/*
   Zone is in the UEDGE mesh
*/
            if ((zn_index(zone,1) > 0) && (zn_index(zone,2) > 0)) then
               j1=zn_index(zone,1)
               assert(j1 <= nx)
               j2=zn_index(zone,2)
               assert(j2 <= ny)
               do js=1,ns
                  zone_ni[js]=ni[j1,j2,js]
                  zone_vr[js]=vr[j1,j2,js]
                  zone_vz[js]=vz[j1,j2,js]
                  zone_vphi[js]=vphi[j1,j2,js]
               end do
               zone_ti=ti[j1,j2]
               zone_te=te[j1,j2]
            else
               if (nstratum > 0) then
                  is=int_lookup(zone_stratum[zone],stratum_list,nstratum)
               else
                  is=0
               end if
/*
   Else is included in the list of specified boundary parameters
*/
               if (is > 0) then
                  assert(is <= nstratum)
                  do js=1,ns
                     zone_ni[js]=bdy_ni[is][js]
                     zone_vr[js]=bdy_vr[is][js]
                     zone_vz[js]=bdy_vz[is][js]
                     zone_vphi[js]=bdy_vphi[is][js]
                  end do
                  zone_ti=bdy_ti[is]
                  zone_te=bdy_te[is]
               else
/*
   Not specified anywhere; set parameters to zero
*/
                  do js=1,ns
                     zone_ni[js]=zero
                     zone_vr[js]=zero
                     zone_vz[js]=zero
                     zone_vphi[js]=zero
                  end do
                  zone_ti=zero
                  zone_te=zero
               end if
            end if
/*
   Compute electron density from quasineutrality using |uedge_species|
   list.  These species must appear at least in the reference species list.
*/
            zone_ne=zero
            do js=1,ns
               isp=sp_lookup(uedge_species[js])
               if (sp_check(isp)) then
                  zone_ne+=zone_ni[js]*sp_z(isp)
               else
                  if (first_zone == TRUE) write(stderr,*) 'UEDGE species ',
     $                 uedge_species[js],' not in reference species list'
               end if
/*
   Assign ion background parameters for this zone for each species
   that appears in the current problem background list.
*/
               sp_back=pr_background_lookup(isp)
               if (bk_check(sp_back)) then
                  bk_n(sp_back,zone)=zone_ni[js]
                  vc_set(bk_v(sp_back,zone),zone_vr[js],zone_vphi[js],
     $                 zone_vz[js])
                  bk_temp(sp_back,zone)=zone_ti
               else
                  if (first_zone == TRUE) write(stderr,*) 'UEDGE species ',
     $                 uedge_species[js],' not in problem species list'
               end if
            end do
/*
   Assign (background) electron density and temperature
*/
            isp=sp_lookup('e')
            if (sp_check(isp)) then
               sp_back=pr_background_lookup(isp)
               if (bk_check(sp_back)) then
                  bk_n(sp_back,zone)=zone_ne
                  bk_temp(sp_back,zone)=zone_te
               else
                  if (first_zone == TRUE) write(stderr,*) 
     $                 'e not listed as a background species!'
               end if
            else
               if (first_zone == TRUE) write(stderr,*) 
     $              'e not listed as a species!'
            end if
            first_zone=FALSE
         end if    // Plasma zones
      end do       // Zones
@#if 0  
/*
   Original code corresponding to the above.  Note the assumed zone
   numbering.
*/    
      do sp_back=1,bk_num
         i=0
         do j1=1,nx
            do j2=1,ny
               i++
               assert(i<=zone_type_num[zn_plasma])
               assert(j1==zn_index(i,1) && j2==zn_index(i,2))
               if (sp_z(pr_background(sp_back)) != 0) then
                  bk_n(sp_back,i)=ni[j1,j2]
                  if(sp_back == 1) bk_temp(sp_back,i)=te[j1,j2]
                  if(sp_back == 2) bk_temp(sp_back,i)=ti[j1,j2]
                  vc_set(bk_v(sp_back,i),vr[j1,j2],vphi[j1,j2],vz[j1,j2])
               endif
            enddo
         enddo
      enddo
@#endif
/*
   Calculate total currents for all species in |uedge_species|
*/
      do ixpt=1,nxpt
         do js=1,ns
            flux1_tot[js,ixpt]=zero
            flux2_tot[js,ixpt]=zero
            do j2=1,ny
               flux1_tot[js,ixpt]+=flux1[j2,js,ixpt]
               flux2_tot[js,ixpt]+=flux2[j2,js,ixpt]
            end do
         end do
      end do
      go to eof

 6    assert('error occurred in reading uedge data file' == ' ')

eof: continue

      var_free(bdy_ni)
      var_free(bdy_vr)
      var_free(bdy_vz)
      var_free(bdy_vphi)
      var_free(bdy_ti)
      var_free(bdy_te)
      var_free(stratum_list)
      var_free(zone_stratum) 

      return
      end

@ Return index in |uedge_species| corresponding to this species.

@<Get Species Index@>=
               assert(ns > 0)
               species_index=0
               do is=1,ns
                  if (uedge_species[is] == line(b:e)) then
                     assert(species_index == 0)
                     species_index=is
                  end if
               end do

@ Return index in |stratum_list| corresponding to |stratum|, if present.
If not, add to the list.

@<Get Stratum Index@>=

               match=FALSE
               if (nstratum > 0) then
                  do is=1,nstratum
                     if (stratum_list[is] == stratum) then
                        match=TRUE
                        stratum_index=is
                     end if
                  end do
               end if
               if (match == FALSE) then
                  nstratum++
                  dim_stratum=max(dim_stratum,nstratum)
                  var_realloca(bdy_ni)
                  var_realloca(bdy_vr)
                  var_realloca(bdy_vz)
                  var_realloca(bdy_vphi)
                  var_realloca(bdy_te)
                  var_realloca(bdy_ti)
                  var_realloca(stratum_list)
                  assert(ns > 0)
                  do is=1,ns
                     bdy_ni[nstratum][is]=zero
                     bdy_vr[nstratum][is]=zero
                     bdy_vz[nstratum][is]=zero
                     bdy_vphi[nstratum][is]=zero
                  end do
                  bdy_te[nstratum]=zero
                  bdy_ti[nstratum]=zero
                  stratum_index=nstratum
                  stratum_list[stratum_index]=stratum
               end if

@ Write out background information.

@m NC_CLASSIC 0
@m NC_64_BIT 1
@m NC_HDF5 2  // AKA netcdf4
@m BACKGROUND_NC_FILE_TYPE NC_CLASSIC

@<Functions...@>=
      subroutine write_background
      implicit_none_f77
      zn_common
      bk_common
      so_common
      rf_common
      implicit_none_f90
      integer fileid
      character *FILELEN tempfile
      bk_ncdecl
      cm_ncdecl
      nc_decls
      so_ncdecl

      tempfile = filenames_array[backgroundfile]
      assert(tempfile != char_undef)
@#if (BACKGROUND_NC_FILE_TYPE == NC_CLASSIC)
      fileid=nccreate(tempfile,NC_CLOBBER,nc_stat)
@#elseif (BACKGROUND_NC_FILE_TYPE == NC_64_BIT)
      fileid=nccreate(tempfile,or(NC_CLOBBER,NF_64BIT_OFFSET),nc_stat)
@#else
      fileid=nccreate(tempfile,or(NC_CLOBBER,NF_NETCDF4),nc_stat)
@#endif
      cm_ncdef(fileid)
      bk_ncdef(fileid)
      so_ncdef(fileid)
      call ncendef(fileid,nc_stat);
      cm_ncwrite(fileid)
      bk_ncwrite(fileid)
      so_ncwrite(fileid)
      call ncclose(fileid,nc_stat)

      return
      end

@ Write out sources to be read in prior to later DEGAS 2 - UEDGE iterations.

@<Functions...@>=
      subroutine write_old_sources
      implicit_none_f77
      so_common
      rf_common
      implicit_none_f90
      integer fileid
      character *FILELEN tempfile
      nc_decls
      so_ncdecl
      st_decls

      tempfile=filenames_array[oldsourcefile]
      if (tempfile != char_undef) then
         fileid = nccreate(tempfile,NC_CLOBBER,nc_stat)
         so_ncdef(fileid)
         call ncendef(fileid,nc_stat);
         so_ncwrite(fileid)
         call ncclose(fileid,nc_stat)
         write(stdout,*) 'Old source file ',trim(tempfile),' written'
      end if

      return
      end

@ Read in old sources.

@<Functions...@>=
      subroutine nc_read_old_sources(old_source_file)
      implicit_none_f77
      so_common
      rf_common
      implicit_none_f90
      integer old_source_file      // Output
      integer fileid
      character *FILELEN tempfile  // Local
      nc_decls
      @<Memory allocation interface@>
      so_ncdecl

      tempfile=filenames_array[oldsourcefile]
      if (tempfile == char_undef) then
         old_source_file=FALSE
         return
      end if
      call ncpopt(0)
      fileid=ncopen(tempfile,NC_NOWRITE,nc_stat)
      if (nc_stat != 0) then
         old_source_file=FALSE
         return
      else
         old_source_file=TRUE
      end if
      call ncpopt(NC_VERBOSE+NC_FATAL)
      
      so_ncread(fileid)
      call ncclose(fileid,nc_stat)

      return
      end

@ Set sources due to background reactions (recombination).

@<Functions...@>=
      subroutine set_background_sources
      implicit_none_f77
      pr_common                             // Common
      bk_common
      so_common
      implicit_none_f90

      integer jr,update                    // Local

      @<Memory allocation interface@>

      if (pr_bkrc_num > 0) then
         var_realloc(source_base_ptr,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_num_segments,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_type,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_geometry,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_num_flights,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_num_checkpoints,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_species,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_root_species,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_time_variation,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_total_current,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_weight_norm,so_grps,so_grps+pr_bkrc_num)
         var_realloc(source_scale_factor,so_grps,so_grps+pr_bkrc_num)
@#if 0
         so_grps+=pr_bkrc_num  <--- THIS IS A BUG!!!
@#endif
         update=FALSE        // Argument for |set_background_rate|
         do jr=1,pr_bkrc_num
            so_grps++
            so_base(so_grps)=so_seg_tot+1
            so_type(so_grps)=so_recomb
/* 
   In |set_prod_recomb|, assumed that these reactions had just one product:
   the test species being sourced. The ``root'' ion was also assumed to be
   the second reagent.
 */
            so_species(so_grps)=pr_bkrc_prod(jr,1)
            so_root_sp(so_grps)=pr_background(pr_bkrc_rg(jr,2))
            if (so_time_dependent == TRUE) then
               assert(so_time_final > so_time_initial)
               so_t_varn(so_grps)=so_time_uniform
            else
               so_t_varn(so_grps)=so_delta_fn
            end if
            so_nseg(so_grps)=0
            so_geom(so_grps)=so_volume
            so_nflights(so_grps)=100
            so_chkpt(so_grps)=0
            so_scale(so_grps)=one
            call set_background_rate(jr,so_grps,update)
            so_nseg(so_grps)=so_seg_tot-so_base(so_grps)+1
         end do    
      end if

      return
      end

@ Set background (recombination) rate.

@<Functions...@>=

      subroutine set_background_rate(jr,grp,update)

      implicit_none_f77
      pr_common                   // Common
      bk_common
      so_common
      gi_common
      zn_common
      sp_common
      implicit_none_f90

      integer jr,update           // Input
      so_decl(grp)

      integer zone                // Local
      real rate
      pt_decl(bk_rg2)
      lc_decl(zone_loc)
      rn_decl(dummy_rand)         // Not really used!

      external find_rate
      real find_rate

      @<Memory allocation interface@>
      lc_decls
      rn_decls
      st_decls
/*
   Note: have to pass in |so_seg_tot| so this routine can be called for
   subsequent iterations without overwriting the number of segments.
*/
      pt_init(bk_rg2,sp_sy(pr_background(pr_bkrc_rg(jr,2))),grp)
      so_tot_curr(grp)=zero
      do zone=1,zn_num
         if (zn_type(zone) == zn_plasma) then
            vc_copy(zone_center[zone],lc_x(zone_loc))
            lc_set_a(zone_loc)
            assert(lc_zone(zone_loc) == zone)
            lc_copy(zone_loc,pt_loc(bk_rg2))
            v_ext_to_int(lc_x(zone_loc),bk_v(pr_bkrc_rg(jr,2),zone),pt_v(bk_rg2),geometry_symmetry,background_coords)
            rate=bk_n(pr_bkrc_rg(jr,2),zone)*find_rate(pt_args(bk_rg2),
     $           pr_background_args(pr_bkrc_rg(jr,1)),
     $           pr_reaction_args(pr_bk_rc(jr)),rn_args(dummy_rand))
     $           *zn_volume(zone)
            if (rate > zero) then
               so_seg_tot++
               if (update == TRUE) then
/*
   Be sure we don't have a zone oscillating between zero and nonzero rates
   on iterations with the plasma code.
*/
                  assert(source_segment_ptr[so_seg_tot] == zone)
               else                                     // It's a new one
                  var_realloca(source_segment_ptr)
                  var_realloca(source_current)
                  var_realloca(source_segment_rel_wt)
                  var_realloca(source_segment_prob_alias)
                  var_realloca(source_segment_ptr_alias)
                  source_segment_ptr[so_seg_tot]=zone
               end if
               if (so_time_dependent == TRUE) then
                  assert(so_time_final > so_time_initial)
                  rate*=(so_time_final-so_time_initial)
               end if
               source_current[so_seg_tot]=rate
               so_tot_curr(grp)+=rate
            end if
         end if
      end do

      return
      end

@ Set plate sources for UEDGE case.

@<Functions...@>=
      subroutine set_uedge_plate_sources(nx,ny,nxpt,ixlb,ixrb,
     $     ns,uedge_species,rm,zm,
     $     ni1,vr1,vz1,vphi1,te1,ti1,flux1,
     $     ni2,vr2,vz2,vphi2,te2,ti2,flux2,
     $     flux1_present,flux2_present,group_map,update)

      implicit_none_f77
      so_common                                  // Common
      sp_common
      sc_common
      implicit_none_f90

      integer nx,ny,nxpt,ns,update               // Input; UEDGE file data:
      integer ixlb[bk_xpt],ixrb[bk_xpt],
     $        flux1_present[bk_xpt],flux2_present[bk_xpt],
     $        group_map[2,bk_ms,bk_xpt]
      real rm[bk_mx,bk_my,0:4],zm[bk_mx,bk_my,0:4],
     $     ni1[bk_my,bk_ms,bk_xpt],vr1[bk_my,bk_ms,bk_xpt],
     $     vz1[bk_my,bk_ms,bk_xpt],vphi1[bk_my,bk_ms,bk_xpt],
     $     ti1[bk_my,bk_xpt],te1[bk_my,bk_xpt],flux1[bk_my,bk_ms,bk_xpt],
     $     ni2[bk_my,bk_ms,bk_xpt],vr2[bk_my,bk_ms,bk_xpt],
     $     vz2[bk_my,bk_ms,bk_xpt],vphi2[bk_my,bk_ms,bk_xpt],
     $     ti2[bk_my,bk_xpt],te2[bk_my,bk_xpt],flux2[bk_my,bk_ms,bk_xpt]
      character*sp_sy_len uedge_species[bk_ms]

      integer i_seg,j1,j2,js,is_seg,isp,plasma_sc,ixpt,iparam    // Local   
      real ne
      so_decl(grp)
      sc_decl(sector)
      sc_plasma_decl(plasma_sc_ptr)
      vc_decl(x1)
      vc_decl(x2)
      vc_decl(v_isp)
      vc_decl(v_bdy)

      external lookup_sector,phi_sheath             // External
      integer lookup_sector
      real phi_sheath

      @<Memory allocation interface@>
      st_decls
/*
   This stuff needs to be in a separate routine so it can be
   called by |readbackground| and |updatebackground|.
*/
      do ixpt=1,nxpt
         i_seg=0
         if (flux1_present[ixpt] == TRUE) then
/*
   Loop over segments along the outer target.  Use coordinates
   of each segment to look up the corresponding geometry sector.

   Note that the |ixlb| and |ixrb| indices are set up to skip the
   ghost zones in the middle of a double null geometry.  However,
   these are, at present, included in the geometry.  The if-then's
   here account for that.
*/
            if ((nxpt == 2) && (ixpt == 2)) then
               j1=ixlb[ixpt]
            else
               j1=ixlb[ixpt]+1
            end if
            do j2=ny,1,-1
               i_seg++
               vc_set(x1,rm[j1,j2,3],zero,zm[j1,j2,3])
               vc_set(x2,rm[j1,j2,1],zero,zm[j1,j2,1])
               sector=lookup_sector(x1,x2)
               if (sc_check(sector)) then
                  plasma_sc_ptr=sector_type_pointer[sector][sc_plasma]
                  if (sc_plasma_check(plasma_sc_ptr)) then
                     plasma_sc=TRUE
                  else
                     plasma_sc=FALSE
                  end if
               else
                  plasma_sc=FALSE
               end if
               if (plasma_sc == FALSE) then
                  sector=lookup_sector(x2,x1)
                  assert(sc_check(sector))
                  plasma_sc_ptr=sector_type_pointer[sector][sc_plasma]
                  assert(sc_plasma_check(plasma_sc_ptr))
                  plasma_sc=TRUE
               end if
/* 
   Now, for each segment, loop over species.  Set source current
   for each species for which a source group is to be defined.
*/
               vc_set(v_bdy,zero,zero,zero)
               ne=zero
               do js=1,ns
                  if (group_map[1,js,ixpt] != int_undef) then
                     grp=group_map[1,js,ixpt]
                     is_seg=so_base(grp)+i_seg-1
                     source_current[is_seg]=flux1[j2,js,ixpt]
                     so_tot_curr(grp)+=source_current[is_seg]
/*
   This is the only use of the |update| flag, ensuring a
   one-to-one correspondence between the source segments in consecutive
   runs.
*/
                     if (update == FALSE) then
                        source_segment_ptr[is_seg]=sector
                     else
                        assert(source_segment_ptr[is_seg] == sector)
                     end if
                  end if
                  isp=sp_lookup(uedge_species[js])
                  if (sp_check(isp)) then
                     vc_set(v_isp,vr1[j2,js,ixpt],vphi1[j2,js,ixpt],
     $                      vz1[j2,js,ixpt])
                     vc_xvt(v_bdy,v_isp,sp_z(isp)*ni1[j2,js,ixpt],v_bdy)
                     ne+=sp_z(isp)*ni1[j2,js,ixpt]
                  end if
               end do
@#if !OLD_UEDATA
/*
   Finally, use the ion and electron temperatures and total ion
   velocity to compute the sheath related parameters.  These
   data will be used in the main code to compute the incident
   ion energy as $E_{in} = 3 T_{i} + (1/2 + \phi_{s})T_{e}$.
   This expression was developed during the benchmark against
   EIRENE.
*/
               if (ne > zero) then
                  vc_scale(one/ne,v_bdy,v_bdy)
               end if
               assert(source_num_parameters[grp] > 0) // Should be 3 !
               if (i_seg == 1) 
     $              source_parameters_data_base[grp]=so_params_data_size
               so_params_data_size+=source_num_parameters[grp]
               if (so_params_data_size > so_params_data_dim) then
                  var_realloc(source_parameters_data,so_params_data_dim,
     $                 so_params_data_size)
                  so_params_data_dim=so_params_data_size
               end if
               do iparam=1,source_num_parameters[grp]
                  if (so_params_list(iparam,grp) 
     $                 == so_param_e_ion_delta) then
                     if (vc_abs(v_bdy) > zero || te1[j2,ixpt] > zero) then
                        so_params_data(iparam,is_seg,grp)
     $                          =const(3.0)*ti1[j2,ixpt]+half*te1[j2,ixpt]
                     else
                        so_params_data(iparam,is_seg,grp)=zero  // Default
                     end if
                  else if (so_params_list(iparam,grp) 
     $                    == so_param_e_ion_sheath) then
                     if (vc_abs(v_bdy) > zero || te1[j2,ixpt] > zero) then
                        so_params_data(iparam,is_seg,grp)
     $                        =te1[j2,ixpt]*phi_sheath(vc_args(v_bdy),
     $                                               ti1[j2,ixpt],te1[j2,ixpt])
                     else
                        so_params_data(iparam,is_seg,grp)=zero
                     end if
                  else if (so_params_list(iparam,grp) 
     $                    == so_param_e_ion_mult) then
                     if (vc_abs(v_bdy) > zero || te1[j2,ixpt] > zero) then
                        so_params_data(iparam,is_seg,grp)=zero
                     else
                        so_params_data(iparam,is_seg,grp)=one
                     end if
                  end if
               end do
@#endif
            end do
         end if

         i_seg=0
         if (flux2_present[ixpt] == TRUE) then
/* 
   This is the corresponding section for the inner target.  Enough of the
   variable names differ to make a separate section useful.
*/
            if ((nxpt == 2) && (ixpt == 1)) then
               j1=ixrb[ixpt]+1
            else
               j1=ixrb[ixpt]
            end if
            do j2=1,ny
               i_seg++
               vc_set(x1,rm[j1,j2,4],zero,zm[j1,j2,4])
               vc_set(x2,rm[j1,j2,2],zero,zm[j1,j2,2])
               sector=lookup_sector(x1,x2)
               if (sc_check(sector)) then
                  plasma_sc_ptr=sector_type_pointer[sector][sc_plasma]
                  if (sc_plasma_check(plasma_sc_ptr)) then
                     plasma_sc=TRUE
                  else
                     plasma_sc=FALSE
                  end if
               else
                  plasma_sc=FALSE
               end if
               if (plasma_sc == FALSE) then
                  sector=lookup_sector(x2,x1)
                  assert(sc_check(sector))
                  plasma_sc_ptr=sector_type_pointer[sector][sc_plasma]
                  assert(sc_plasma_check(plasma_sc_ptr))
                  plasma_sc=TRUE
               end if
               vc_set(v_bdy,zero,zero,zero)
               ne=zero
               do js=1,ns
                  if (group_map[2,js,ixpt] != int_undef) then
                     grp=group_map[2,js,ixpt]
                     is_seg=so_base(grp)+i_seg-1
                     source_current[is_seg]=flux2[j2,js,ixpt]
                     so_tot_curr(grp)+=source_current[is_seg]
                     if (update == FALSE) then
                        source_segment_ptr[is_seg]=sector
                     else
                        assert(source_segment_ptr[is_seg] == sector)
                     end if
                  end if
                  isp=sp_lookup(uedge_species[js])
                  if (sp_check(isp)) then
                     vc_set(v_isp,vr2[j2,js,ixpt],vphi2[j2,js,ixpt],
     $                      vz2[j2,js,ixpt])
                     vc_xvt(v_bdy,v_isp,sp_z(isp)*ni2[j2,js,ixpt],v_bdy)
                     ne+=sp_z(isp)*ni2[j2,js,ixpt]
                  end if
               end do
@#if !OLD_UEDATA
               if (ne > zero) then
                  vc_scale(one/ne,v_bdy,v_bdy)
               end if
               assert(source_num_parameters[grp] > 0) // Should be 3 !
               if (i_seg == 1) 
     $              source_parameters_data_base[grp]=so_params_data_size
               so_params_data_size+=source_num_parameters[grp]
               if (so_params_data_size > so_params_data_dim) then
                  var_realloc(source_parameters_data,so_params_data_dim,
     $                 so_params_data_size)
                  so_params_data_dim=so_params_data_size
               end if
               do iparam=1,source_num_parameters[grp]
                  if (so_params_list(iparam,grp) 
     $                 == so_param_e_ion_delta) then
                     if (vc_abs(v_bdy) > zero || te2[j2,ixpt] > zero) then
                        so_params_data(iparam,is_seg,grp)
     $                    =const(3.0)*ti2[j2,ixpt]+half*te2[j2,ixpt]
                     else
                        so_params_data(iparam,is_seg,grp)=zero
                     end if
                  else if (so_params_list(iparam,grp) 
     $                    == so_param_e_ion_sheath) then
                     if (vc_abs(v_bdy) > zero || te2[j2,ixpt] > zero) then
                        so_params_data(iparam,is_seg,grp)
     $                       =te2[j2,ixpt]*phi_sheath(vc_args(v_bdy),
     $                  ti2[j2,ixpt],te2[j2,ixpt])
                     else
                        so_params_data(iparam,is_seg,grp)=zero
                     end if
                  else if (so_params_list(iparam,grp) 
     $                    == so_param_e_ion_mult) then
                     if (vc_abs(v_bdy) > zero || te2[j2,ixpt] > zero) then
                        so_params_data(iparam,is_seg,grp)=zero
                     else
                         so_params_data(iparam,is_seg,grp)=one
                      end if
                   end if
                end do
@#endif
            end do
         end if
      end do    // Over |ixpt|

      return
      end

@ Compute sheath potential.  Use a simple prescription based on the
one applied by EIRENE in the benchmark runs.

@<Functions...@>=
      function phi_sheath(vc_dummy(vi),ti,te)

      implicit_none_f77
      implicit_none_f90
      @<Memory allocation interface@>
      real phi_sheath                    // Function
      vc_decl(vi)                        // Input
      real ti,te

      real ce                            // Local

      ce=sqrt(te/electron_mass)
      phi_sheath=-log(sqrt(two*PI)*vc_abs(vi)/ce)
@#if 0
      inc_ion_energy=const(3.0)*ti+(half+phi_sheath)*te
@#endif

      return
      end

@ Read in snapshot particles from file.

@<Functions...@>=
      subroutine nc_read_snapshot(have_snapshot_file)
      implicit_none_f77
      sn_common
      rf_common
      mp_common
      implicit_none_f90
      integer have_snapshot_file     // Output
      integer fileid            // Local
      character*FILELEN tempfile
      nc_decls
      mp_decls
      @<Memory allocation interface@>
      sn_ncdecl

      have_snapshot_file=FALSE
      if (mpi_master) then
         tempfile=filenames_array[snapshotfile]
         if (tempfile != char_undef) then
            call ncpopt(0)
            fileid=ncopen(tempfile,NC_NOWRITE,nc_stat)
            if (nc_stat == 0) then
               have_snapshot_file=TRUE
               call ncpopt(NC_VERBOSE+NC_FATAL)
               sn_ncread(fileid)
               call ncclose(fileid,nc_stat)
            end if
         end if
      end if
@#if MPI
      call MPI_bcast(have_snapshot_file,1,mpi_int,mpi_degas2_root,
     $     comm_world_dup,mpi_err)
@#endif
      if (have_snapshot_file == TRUE) then
         sn_mpibcast
      end if

      return
      end

@ Set up a source based on snapshot particles.

@#if GPI_WEIGHTING
@m nbins 16
@m ntest 3
@#endif

@<Functions...@>=
      subroutine set_snapshot_source(standalone)
      implicit_none_f77
      so_common
      sn_common
      mp_common
      implicit_none_f90

      integer standalone                                      // Input

      integer have_snapshot_file,new_seg_tot,ip,iparam,igrp,  // Local
     $        iseg,snapshot_reset
@#if GPI_WEIGHTING
/*
   For setting relative weights
*/
      integer ibin,itest
      integer binned_number[nbins][ntest],total_number[ntest]
      real rmin,rmax,rmaj,avg_weight,total_weight
      real binned_weight[nbins],binned_test_weight[nbins][ntest],
     $     total_test_weight[ntest]
      data rmin/dconst(0.82)/,rmax/dconst(0.98)/
@#endif

      @<Memory allocation interface@>

      call nc_read_snapshot(have_snapshot_file)
      if ((have_snapshot_file == FALSE) || (sn_number_particles <= 0)) return
/*
   Check to see if this is a continuation of a previous time step invoked
   via subroutine interface (i.e., via |xgc_flighttest|).  If so, |so_grps|
   has already been incremented and most of the |so_grps| array entries
   already set.  All of the source segments in this group are to be 
   overwritten.  The lines of code involved have been written to 
   work for either value of |snapshot_reset|.
*/
      snapshot_reset=FALSE
      do igrp=1,so_grps
         if (so_type(igrp) == so_snapshot) then
/*
   The following code will assume that this is the last group.
   Put this assert in here as a reminder in case some other 
   consideration suggests that it be otherwise.
*/
            assert(igrp == so_grps)
            snapshot_reset=TRUE
         end if
      end do

      if (snapshot_reset == FALSE) then
         var_realloc(source_base_ptr,so_grps,so_grps+1)
         var_realloc(source_num_segments,so_grps,so_grps+1)
         var_realloc(source_type,so_grps,so_grps+1)
         var_realloc(source_geometry,so_grps,so_grps+1)
         var_realloc(source_num_flights,so_grps,so_grps+1)
         var_realloc(source_num_checkpoints,so_grps,so_grps+1)
         var_realloc(source_species,so_grps,so_grps+1)
         var_realloc(source_root_species,so_grps,so_grps+1)
         var_realloc(source_time_variation,so_grps,so_grps+1)

         var_realloc(source_num_gparameters,so_grps,so_grps+1)
         var_realloc(source_num_parameters,so_grps,so_grps+1)
         var_realloc(source_gparameters_base,so_grps,so_grps+1)
         var_realloc(source_parameters_base,so_grps,so_grps+1)
         var_realloc(source_parameters_data_base,so_grps,so_grps+1)
         var_realloc(source_num_giparameters,so_grps,so_grps+1)
         var_realloc(source_num_iparameters,so_grps,so_grps+1)
         var_realloc(source_giparameters_base,so_grps,so_grps+1)
         var_realloc(source_iparameters_base,so_grps,so_grps+1)
         var_realloc(source_iparameters_data_base,so_grps,so_grps+1)

         var_realloc(source_total_current,so_grps,so_grps+1)
         var_realloc(source_weight_norm,so_grps,so_grps+1)
         var_realloc(source_scale_factor,so_grps,so_grps+1)

         so_grps++
         so_base(so_grps)=so_seg_tot+1
         so_type(so_grps)=so_snapshot
         so_t_varn(so_grps)=so_delta_fn
         so_geom(so_grps)=so_volume
@#if GPI_WEIGHTING
         so_nflights(so_grps)=16000000
@#else
         so_nflights(so_grps)=100
@#endif
         so_chkpt(so_grps)=0
         so_scale(so_grps)=one

         source_num_gparameters[so_grps]=0
         source_num_parameters[so_grps]=7
         source_gparameters_base[so_grps]=so_gparams_list_size
         source_parameters_base[so_grps]=so_params_list_size
         source_parameters_data_base[so_grps]=so_params_data_size
         source_num_giparameters[so_grps]=0
         source_num_iparameters[so_grps]=6
         source_giparameters_base[so_grps]=so_giparams_list_size
         source_iparameters_base[so_grps]=so_iparams_list_size
         source_iparameters_data_base[so_grps]=so_iparams_data_size

         so_params_list_size+=source_num_parameters[so_grps]
         if (so_params_list_size > so_params_list_dim) then
            var_realloc(source_parameters_list,so_params_list_dim,
     $           so_params_list_size)
            so_params_list_dim=so_params_list_size
         end if
         so_params_list(1,so_grps)=so_param_pt_t
         so_params_list(2,so_grps)=so_param_pt_v1
         so_params_list(3,so_grps)=so_param_pt_v2
         so_params_list(4,so_grps)=so_param_pt_v3
         so_params_list(5,so_grps)=so_param_lc_x1
         so_params_list(6,so_grps)=so_param_lc_x2
         so_params_list(7,so_grps)=so_param_lc_x3

         so_iparams_list_size+=source_num_iparameters[so_grps]
         if (so_iparams_list_size > so_iparams_list_dim) then
            var_realloc(source_iparameters_list,so_iparams_list_dim,
     $           so_iparams_list_size)
            so_iparams_list_dim=so_iparams_list_size
         end if
         so_iparams_list(1,so_grps)=so_iparam_pt_sp
         so_iparams_list(2,so_grps)=so_iparam_pt_test
         so_iparams_list(3,so_grps)=so_iparam_lc_cell
         so_iparams_list(4,so_grps)=so_iparam_lc_zone
         so_iparams_list(5,so_grps)=so_iparam_pt_type
         so_iparams_list(6,so_grps)=so_iparam_pt_author
      end if

      new_seg_tot=so_base(so_grps)-1+sn_number_particles
      if (standalone == TRUE) then
/*
   If this routine is called from preprocessing setup routine
   (e.g., |defineback|), the source segment arrays are growing
   in chunks of |mem_inc|.  In this case, we need to use the
   |var_reallocc| macro to redimension for the snapshot segments.
*/
         var_reallocc(source_segment_ptr,so_seg_tot,new_seg_tot)
         var_reallocc(source_current,so_seg_tot,new_seg_tot)
         var_reallocc(source_segment_rel_wt,so_seg_tot,new_seg_tot)
         var_reallocc(source_segment_prob_alias,so_seg_tot,new_seg_tot)
         var_reallocc(source_segment_ptr_alias,so_seg_tot,new_seg_tot)
      else
/*
   Otherwise, the routine is being called {\em after} the background
   netCDF file has been read in.  In this case, the source segment
   arrays are precisely |so_seg_tot| long so that we need to use
   |var_realloc| to redimension.
*/
         var_realloc(source_segment_ptr,so_seg_tot,new_seg_tot)
         var_realloc(source_current,so_seg_tot,new_seg_tot)
         var_realloc(source_segment_rel_wt,so_seg_tot,new_seg_tot)
         var_realloc(source_segment_prob_alias,so_seg_tot,new_seg_tot)
         var_realloc(source_segment_ptr_alias,so_seg_tot,new_seg_tot)
      end if

      so_params_data_size=source_parameters_data_base[so_grps]
     $     +source_num_parameters[so_grps]*sn_number_particles
//      so_params_data_size+=source_num_parameters[so_grps]*sn_number_particles
      if (so_params_data_size > so_params_data_dim) then
         var_realloc(source_parameters_data,so_params_data_dim,
     $               so_params_data_size)
         so_params_data_dim=so_params_data_size
      end if

      so_iparams_data_size=source_iparameters_data_base[so_grps]
     $     +source_num_iparameters[so_grps]*sn_number_particles
//      so_iparams_data_size+=source_num_iparameters[so_grps]*sn_number_particles
      if (so_iparams_data_size > so_iparams_data_dim) then
         var_realloc(source_iparameters_data,so_iparams_data_dim,
     $               so_iparams_data_size)
         so_iparams_data_dim=so_iparams_data_size
      end if

      so_nseg(so_grps)=sn_number_particles

      so_tot_curr(so_grps)=zero
      iseg=so_base(so_grps)-1
@#if GPI_WEIGHTING
      do ibin=1,nbins
         binned_weight[ibin]=zero
         do itest=1,ntest
            binned_number[ibin][itest]=0
            binned_test_weight[ibin][itest]=zero
         end do
      end do
      total_weight=zero	
      do itest=1,ntest
         total_number[itest]=0
         total_test_weight[itest]=zero
      end do
@#endif
      do ip=1,sn_number_particles
         iseg++
         source_segment_ptr[iseg]=ip
         source_current[iseg]=sn_particles_float[ip][sn_float_pt_w]
@#if GPI_WEIGHTING
/*
   Bin snapshot particle weights in one centimeter wide bins using major
   radius.  This will be used subsequently to set the relative weights
   for sampling with the objective of forcing the sampled number of particles,
   summed over all species, to be flat with major radius.  Use the 
   |rel_wt| entry to hold the bin number temporarily for convenience.
*/
         rmaj=sqrt(sn_particles_float[ip][sn_float_lc_x1]**2
     $             + sn_particles_float[ip][sn_float_lc_x2]**2)
         assert((rmaj > rmin) && (rmaj < rmax))
	 ibin=int((rmaj-rmin)*const(1.,2))+1
	 assert((ibin >=1) && (ibin <= nbins))
	 binned_weight[ibin]+=sn_particles_float[ip][sn_float_pt_w]
	 total_weight+=sn_particles_float[ip][sn_float_pt_w]
         itest=sn_particles_int[ip][sn_int_pt_test]-1
         binned_test_weight[ibin][itest]+=sn_particles_float[ip][sn_float_pt_w]
         total_test_weight[itest]+=sn_particles_float[ip][sn_float_pt_w]
         binned_number[ibin][itest]++
         total_number[itest]++
         source_segment_rel_wt[iseg]=areal(ibin)
@#endif
         so_tot_curr(so_grps)+=sn_particles_float[ip][sn_float_pt_w]
/*
   Write the loop like this to be sure we get them all.
*/
         do iparam=1,source_num_parameters[so_grps]
            if (so_params_list(iparam,so_grps) == so_param_pt_t) then
               so_params_data(iparam,iseg,so_grps)
     $              =sn_particles_float[ip][sn_float_pt_t]
/*
   Was unable to satisfy this in initial application to the XGC0 coupling.
   Attempt to relax it to a comparison with the |epsilon| parameter defined
   in sysdep.hweb.
*/
               if ((ip == 1) && mpi_master) then
                  if ((abs(so_params_data(iparam,iseg,so_grps)
     $                 -so_time_initial))/(max(so_time_initial,epsilon))
     $                 > epsilon) write(stderr,*) 
     $            ' Warning: snapshot particle time does not match so_time_initial'
               end if
            else if (so_params_list(iparam,so_grps) == so_param_pt_v1) then
               so_params_data(iparam,iseg,so_grps)
     $              =sn_particles_float[ip][sn_float_pt_v1]
            else if (so_params_list(iparam,so_grps) == so_param_pt_v2) then
               so_params_data(iparam,iseg,so_grps)
     $              =sn_particles_float[ip][sn_float_pt_v2]
            else if (so_params_list(iparam,so_grps) == so_param_pt_v3) then
               so_params_data(iparam,iseg,so_grps)
     $              =sn_particles_float[ip][sn_float_pt_v3]
            else if (so_params_list(iparam,so_grps) == so_param_lc_x1) then
               so_params_data(iparam,iseg,so_grps)
     $              =sn_particles_float[ip][sn_float_lc_x1]
            else if (so_params_list(iparam,so_grps) == so_param_lc_x2) then
               so_params_data(iparam,iseg,so_grps)
     $              =sn_particles_float[ip][sn_float_lc_x2]
            else if (so_params_list(iparam,so_grps) == so_param_lc_x3) then
               so_params_data(iparam,iseg,so_grps)
     $              =sn_particles_float[ip][sn_float_lc_x3]
            else
               assert(' Inconsistent number of snapshot parameters' == ' ')
            end if
         end do

         do iparam=1,source_num_iparameters[so_grps]
            if (so_iparams_list(iparam,so_grps) == so_iparam_pt_sp) then
               so_iparams_data(iparam,iseg,so_grps)
     $              =sn_particles_int[ip][sn_int_pt_sp]
            else if (so_iparams_list(iparam,so_grps) == so_iparam_pt_test) then
               so_iparams_data(iparam,iseg,so_grps)
     $              =sn_particles_int[ip][sn_int_pt_test]
            else if (so_iparams_list(iparam,so_grps) == so_iparam_lc_cell) then
               so_iparams_data(iparam,iseg,so_grps)
     $              =sn_particles_int[ip][sn_int_lc_cell]
            else if (so_iparams_list(iparam,so_grps) == so_iparam_lc_zone) then
               so_iparams_data(iparam,iseg,so_grps)
     $              =sn_particles_int[ip][sn_int_lc_zone]
            else if (so_iparams_list(iparam,so_grps) == so_iparam_pt_type) then
               so_iparams_data(iparam,iseg,so_grps)
     $              =sn_particles_int[ip][sn_int_pt_type]
            else if (so_iparams_list(iparam,so_grps) == so_iparam_pt_author) then
               so_iparams_data(iparam,iseg,so_grps)
     $              =sn_particles_int[ip][sn_int_pt_author]
            end if
         end do

      end do
      assert(iseg == new_seg_tot)
      so_seg_tot=new_seg_tot
@#if GPI_WEIGHTING
/*
   The relative weight is just the fraction in each bin.
   The sampling probability is inversely proportional to
   this weight, however.  So, the regions with the smallest
   weight have their probabilities enhanced.  On the other
   hand, the stat weight of these particles is smaller.
*/
      assert(total_weight == so_tot_curr(so_grps))
      avg_weight=total_weight/areal(nbins)      
      do ibin=1,nbins
         binned_weight[ibin]/=avg_weight
      end do
      do iseg=so_base(so_grps),so_seg_tot
         ibin=int(source_segment_rel_wt[iseg])
	 assert((ibin >=1) && (ibin <= nbins))
	 source_segment_rel_wt[iseg]=binned_weight[ibin]
      end do
      open(unit=diskout,file='snapshot_rel_wts',status='unknown')
      write(diskout,*) ' Total D = ',total_number[1],
     $                 ' Total D2 = ', total_number[2],
     $                 ' Total D2+ = ',total_number[3]
      write(diskout,'(a,1p,e12.5)') ' Total weight = ',total_weight
      write(diskout,'(1p,3(a,e12.5,2x))') ' D:  ',total_test_weight[1],
     $                 ' D2:  ',total_test_weight[2],
     $                 ' D2+:  ',total_test_weight[3]
      write(diskout,'(a)') ' bin  R(m)        D         D2         D2+     RelWt           D_wt          D2_wt         D2p_wt'
      do ibin=1,nbins
         write(diskout,'(i3,2x,f6.2,2x,3(i9,2x),4(1p,e12.5,2x))') ibin,
     $          rmin+areal(ibin)*const(1.,-2),
     $          (binned_number[ibin][itest],itest=1,ntest),
     $          binned_weight[ibin],
     $          (binned_test_weight[ibin][itest],itest=1,ntest)
      end do
      close(unit=diskout)
@#endif
/* 
   Reset the seed string to avoid random number overlap 
   between consecutive runs.
*/
      so_seed_decimal=sn_seed_decimal
/*
   Done with these and need to free them since they will be 
   allocated from scratch at the start of |do_flights_master|
   and |do_flights_slave|.
*/
      var_free(sn_particles_float)
      var_free(sn_particles_int)

      return
      end

@ Allocate and initialize background arrays. This routine also checks for
overlap between the test and background species (i.e., for BGK neutrals).
If present, vacuum zones are relabeled as plasma zones to permit 
collisions in them.
@<Functions...@>=
      subroutine setup_back_arrays(geom_modified)

      implicit_none_f77
      rc_common
      zn_common
      bk_common
      pr_common
      implicit_none_f90

      integer i,bgk,geom_modified
      zn_decl(zone)

      @<Memory allocation interface@>

      bk_num=pr_background_num
/*
   This is the test used in |do_flights_master|. We need to store
   the background values in the vacuum zones if and only if these
   reactions are present in this problem.
*/
      bgk=FALSE
      do i=1,pr_reaction_num
         if (rc_reaction_type(pr_reaction(i)) == 'bgk_elastic') bgk=TRUE
      end do

      geom_modified=FALSE
      if (bgk == TRUE && zone_type_num[zn_vacuum] > 0) then
         do zone=1,zn_num
            if (zn_type(zone) == zn_vacuum) then
               zn_type_set(zone,zn_plasma)
               geom_modified=TRUE
            end if
         end do
         zone_type_num[zn_vacuum]=0
      end if
      
      var_alloc(background_n)
      var_alloc(background_v)
      var_alloc(background_temp)

      call zero_back_arrays

      return
      end

@ Zero background arrays.
@<Functions...@>=
      subroutine zero_back_arrays

      implicit_none_f77
      bk_common
      zn_common
      implicit_none_f90

      zn_decl(zone)
      bk_decl(back)

      do zone=1,zn_num
         if (zn_type(zone) == zn_plasma) then
            do back=1,bk_num
               bk_n(back,zone)=zero
               bk_temp(back,zone)=zero
               vc_set(bk_v(back,zone),zero,zero,zero)
            end do
         end if
      end do

      return
      end


@ Test species corresponding to background. Uses the fact that all charge in
a species arises from electrons along with the |species_add_check| function
to find the first entry the test list which matches the background species
with no electrons in its elements list.

@<Functions...@>=
      function neutralize_species(sp_dummy(s))
      implicit_none_f77
      el_common                          // Common
      sp_common
      pr_common
      implicit_none_f90
      st_decls
      integer neutralize_species         // Function
      sp_decl(s)                         // Input

      integer i,num_elec,num1,num2       // Local
      sp_decl(e_sp)
      sp_decl(test_sp)
      sp_decl(list1[sp_ncomp_max])
      sp_decl(list2[sp_ncomp_max])

      
      external species_add_check         // External
      logical species_add_check

      num_elec=0
      do i=1,sp_ncomp(s)
         if (el_z(sp_el(s,i)) == -1) then
            num_elec+=sp_count(s,i)
         end if
      end do

      list1[1]=s
      num1=1
      num2=1
      e_sp=sp_lookup('e')
      do i=1,abs(num_elec)
         if (num_elec < 0) then
            list1[i+1]=e_sp
            num1++
         else
            list2[i+1]=e_sp
            num2++
         end if
      end do


      do i=1,pr_test_num
         test_sp=pr_test(i)
         list2[1]=test_sp
         if (species_add_check(num1,sp_args(list1),num2,sp_args(list2))) go to break
      end do
      assert("No matching neutral species" == " ")
break: continue

      neutralize_species=test_sp

      return
      end

@ Generic routine for setting up or updating source sampling arrays.

@<Functions...@>=

      subroutine init_wt_alias(uedge)

      implicit_none_f77
      so_common
      implicit_none_f90

      integer uedge

      so_decl(grp)

      integer i
@#if GPI_WEIGHTING      
/*
   The relative weights of the snapshot source segments
   have already been set, so bypass them here.
*/
      assert((so_grps == 2) && (so_type(2) == so_snapshot))
      do i=1,so_nseg(1)
         source_segment_rel_wt[i]=one
      end do
@#else
      do i=1,so_seg_tot
         source_segment_rel_wt[i]=one
      end do
@#endif
      do grp=1,so_grps
         call set_prob_alias(so_nseg(grp),
     $        source_current[so_base(grp)],
     $        source_segment_rel_wt[so_base(grp)],
     $        source_segment_ptr[so_base(grp)],
     $        source_segment_prob_alias[so_base(grp)],
     $        source_segment_ptr_alias[so_base(grp)],so_wt_norm(grp))
      end do

      if (uedge == TRUE) call write_old_sources 

      return
      end

@ Set Probability Aliases Used for Sampling. This implementation follows
the description of the sampling algorithm described in Sec. 3.4.1 (and
Exercise 7) of Knuth. He refers to the originator, A. J. Walker,
[{\em Electronics Letters} {\bf 10}, 8 (1974), 127-128; {\em ACM Trans.
Math. Software} {\bf 3} (1977), 253-256].

However, this procedure necessarily involves a nested do-loop over the
entire source array, i.e., it entails on the order of $n^{2}$ steps.
For very large sources (e.g., snapshot), the time required by this
routine can exceed that for the main run.  As an alternative, we have
implemented a basic sampling scheme for $n > $ |n_max|.  In this case,
the |pa| array just has a cumulative probability and the |ya| is filled
with |int_undefined|.  The latter is used as the signal to the sampling
routine that this alternative method has been employed.

@m n_max 100000

@<Functions...@>=
      subroutine set_prob_alias(n,so,wt,x_ptr,pa,ya,wtnorm)
      define_dimen(temp_ind,n)
      define_varp(prob,FLOAT,temp_ind)
      define_varp(ia,INT,temp_ind)

      implicit_none_f77
      implicit_none_f90

      integer n                      // Input
      real so[n],wt[n]
      integer x_ptr[n]

      real pa[n]                     // Output
      real wtnorm
      integer ya[n]

      integer i,j,inew               // Local
      real sum,sum1,probnew

      @<Memory allocation interface@>       

c      real prob(n)
c      integer ia(n)
      declare_varp(prob)
      declare_varp(ia)
      
      sum=zero
      sum1=zero
      do i=1,n
         if (wt[i] > zero) then
            sum=sum+so[i]/wt[i]
            sum1=sum1+so[i]
         end if
      end do

      wtnorm=sum/sum1

      if (n > n_max) then
/*
  Set up basic sampling scheme.
*/
         pa[1]=zero
         ya[1]=int_unused
         do i=2,n
            pa[i]=pa[i-1]+so[i-1]/wt[i-1]
            ya[i]=int_unused
         end do
/*
   If we put this factor into the above loop, get significant
   roundoff accumulation.
*/
         do i=1,n
            pa[i]/=sum
         end do
/*
   Just check that the total still sums to 1.
*/
         assert(abs((pa[n]+so[n]/(sum*wt[n]))-one) < epsilon)
         return
      else
/*
   Use the alias method.
*/
         var_alloc(prob)
         var_alloc(ia)

         do i=1,n
            if (wt[i] > zero) then
               prob[i]=so[i]/(sum*wt[i])
            else
               prob[i]=zero
            end if
            ia[i]=i
         end do
/*  
   The sort routine should place the entries in |prob| in order
   of increasing magnitude. The entries in |ia| should follow suit.
   Note: we've added 1 to the indices of the |pa| and |ya| arrays
   so that they range from 1 to |n|, rather than 0 to |n-1| as in
   Knuth. There is a corresponding shift used in the sampling.
 */
         call sort2(n,prob,ia)
         do i=n,1,-1
            pa[ia[1]]=areal(n)*prob[1]
            ya[ia[1]]=x_ptr[ia[i]]
            probnew=prob[i]-(one/areal(n) - prob[1])
            inew=ia[i]
            if (i > 2) then
               do j=1,i-2
                  if (probnew < prob[j+1]) then
                     prob[j]=probnew
                     ia[j]=inew
                     goto 10
                  end if
                  prob[j]=prob[j+1]
                  ia[j]=ia[j+1]
               end do
               prob[i-1]=probnew
               ia[i-1]=inew
   10          continue
            else if (i == 2) then
               prob[1]=probnew
               ia[1]=inew
            end if
         end do

         var_free(prob)
         var_free(ia)
      end if

      return
      end

@ Compare latest source currents with those last used to compute the
sampling arrays. If changes are not too large, account for them with a
weight factor. Otherwise, recompute the sampling arrays.

@<Functions...@>=
      subroutine update_wt_alias(old_current,old_rel_wt,old_tot_curr)

      implicit_none_f77
      so_common                                          // Common
      implicit_none_f90

      real old_current[*],old_rel_wt[*],old_tot_curr[*]  // Input

      integer i_seg,initialize,write_file                // Local
      so_decl(grp)
      
      write_file=FALSE
      do grp=1,so_grps

         so_wt_norm(grp)=zero
         initialize=FALSE
         do i_seg=so_base(grp),so_base(grp)+so_nseg(grp)-1
            if (old_current[i_seg] > zero) then
               source_segment_rel_wt[i_seg]=old_rel_wt[i_seg] 
     $              * source_current[i_seg]/ old_current[i_seg]
            else
               assert(source_current[i_seg] == zero)
            end if

            if (source_segment_rel_wt[i_seg] > so_rel_wt_max 
     $           || source_segment_rel_wt[i_seg] < so_rel_wt_min) then
               initialize=TRUE
               go to break
            end if
            so_wt_norm(grp)+=source_current[i_seg]
     $           / (so_tot_curr(grp)*source_segment_rel_wt[i_seg])
         end do
         if (so_wt_norm(grp) > so_wt_norm_max 
     $        || so_wt_norm(grp) < so_wt_norm_min)
     $        initialize=TRUE
break: continue

         if (initialize == TRUE) then
            write(stdout,*) ' Initializing sampling arrays for group ',grp
            write_file=TRUE
            do i_seg=so_base(grp),so_base(grp)+so_nseg(grp)-1
               source_segment_rel_wt[i_seg]=one
            end do
            call set_prob_alias(so_nseg(grp),
     $           source_current[so_base(grp)],
     $           source_segment_rel_wt[so_base(grp)],
     $           source_segment_ptr[so_base(grp)],
     $           source_segment_prob_alias[so_base(grp)],
     $           source_segment_ptr_alias[so_base(grp)],so_wt_norm(grp))

         end if
      end do

      if (write_file == TRUE) call write_old_sources

      return
      end

@* References.

\bibliographystyle{report}
\bibliography{../../degas}

@* INDEX.

