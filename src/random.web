% $Id: 9a20baad1bb958b4b4dea7158606b05b73346a78 $
\Title{Random numbers}


@* Introduction.

\ID{$Id: 9a20baad1bb958b4b4dea7158606b05b73346a78 $}

Random number routines for degas.  We attempt to satisfy four objectives
with these routines: (1) they should produce high-quality random numbers
uniformly distributed in $(0,1)$; (2) they should be fast; (3) they
should be portable; (4) it should be easy to run many independent
sequences of random numbers.

The methods used here are described in D. E. Knuth, {\it Art of Computer
Programming} (3rd edition, Addison-Wesley, 1998), Vol. 2, {\it
Seminumerical Algorithms}, Chapter 3, Random Numbers.  The basic method
is given by the routine |ran_array| in Section 3.6 and converted to
floating method according to the Exercise 3.6-10.  The Fortran version
of this routine is available at
\begin{center}
\verb+http://www-cs-faculty.stanford.edu/~knuth/programs/frngdb.f+
\end{center}
The method uses the recurrence
\begin{equation}\label{recursion}
X_n=(X_{n-l}+X_{n-k})\bmod 1,
\end{equation}
where $X_n$ are multiples of $2^{-e}$.

The following changes have been made to Knuth's version:
\begin{itemize}
\item In order to allow separate threads of random numbers to be
generated, the {\it state} of the random number generator is passing to
the random number routines via the argument list (instead of being
stored in a common block).
\item The number of significant bits, $e$ has been reduced from $52$ to
$47$ to accomodate the precision of Cray computers.
\item We add $2^{-(e+1)}$ to the random numbers returned by |random| and
|random_array|.  This centers the distribution of random numbers between
$0$ and $1$ and ensures that the numbers lie strictly between $0$ and
$1$.  The latter property means, for example, that we can safely take
the $\log$ of the random numbers.
\item |random_array| can return any number of random numbers.  (Knuth's
|ran_array| was coded to return at least $k$ random numbers.)
\item The {\it lags} $(k,l)$ are chosen to be $(63,100)$ instead of
$(37,100)$.  Because $63+37=100$, this generates the sequence in reverse
(with an alternating sign change).  The larger value of $k$ allows better
vectorization (since the 63 numbers can be generated in parallel).
\item We follow the suggestion of Exercise 3.6-15 using only $k$ numbers
out of each batch of $p=1009$.
\end{itemize}

The state of the random number generator is defined by $k$ $e$-bit
numbers.  If we disallow the state where the least-significant bit of
all these $k$ numbers is zero, the period of equation
\ref{recursion} is $2^{e-1}(2^k-1)\approx 8.9\times10^{43}$.  All the
bits of the random numbers are ``good'' (in contrast to linear
congruential random generators where the less significant bits are less
random).  Employing the method of using only $k$ out of $p$ random
numbers, we have a method with no known defects.  It is also fairly fast
since it involves only floating-point addition.

In order to start this random number generator, we need to specify its
inital state.  Knuth includes an algorithm to do this which accepts a
single integer seed, which can take on approximately $10^9$ different
values and computes an inital state of the random number generator, in
such a way that a particular seeds is guaranteed to produce at least
$2^{70}$ different states before ``colliding'' with those produces by a
different seed.

We don't use this method here because (1) it's rather slow (100 times
slower than the method we use), and (2) $10^9$ possible seeds seems to
be rather restrictive in parallel applications which may need to consume
many possible seeds in a given run.

The total number of allowable states this random generator can take is
$2^{k(e-1)}(2^k-1)$.  Thus a single sequence generated by equation
\ref{recursion} covers a tiny fraction $2^{-(e-1)(k-1)} \approx
10^{-1371}$ of allowable states.  If we just picked two inital states
``randomly,'' it would be highly unlikely that they would belong to
the same sequence.  In fact, we would have to pick about $10^{685}$
initial states before having an appreciable probably of a collision.

We therefore adopt a strategy where we use a conventional linear
congruential random generator to initialize equation \ref{recursion}
\begin{equation} \label{linear}
T(x)\equiv (a_1x+c_1) \bmod 2^{112},
\end{equation}
We choose $a_1=31167285\times2^{64}+6364136223646793005$, $c_1=1$.  The
multiplier $a_1$ is obtained by concatenating two ``good'' multipliers
$31167285 \bmod 2^{48}$ and $6364136223646793005 \bmod 2^{64}$ given in
lines 23 amd 26 of Knuth, Section 3.3.4, Table 1.  This multiplier will
give good results in the spectral test ensuring good converage in
multidimensional space.  The state is obtained from the high $e$ bits of
$k$ consecutive numbers from equation \ref{linear}.  Actually we place
the most significant (i.e., the ``most random'') bits from equation
\ref{linear} into the least significant bits of the state vector where
they can the most good (since they will result in carries into the more
significant bits).  (See the implementation of |random_init_d2| for
details.)  A $k+1$st number is also used to randomly set one of the
least significant bits in the state vector to 1 in the (unlikely) event
that they are all zero.

A second state vector can likewise be generated using the next $k+1$
numbers from equation \ref{linear}.  Since \ref{linear} is a high
quality random number generator in its own right, this will be no
correlations between the two resulting sequences.  Furthermore, the
discussion above implies that we are nearly guaranteed that the
sequences will have no common points in $k$-dimensional space.

In order to obtain a potentially large set of independent random numbers
we advance equation \ref{linear} forward
\begin{equation}\label{stepper}
L(n_0,n_1,n_2) = g_0 n_0 + g_1 n_1 + g_2 n_2
\end{equation}
steps, where $g_0=k+1=101$, $g_1=375549701083$, and
$g_2=1396411663216078567733$.  $g_0$ is the number of random numbers
used by |random_init_d2|.  The other numbers are chosen such that
$$
\frac{g_1}{g_0} \approx \frac{g_2}{g_1} \approx
\biggl(\frac{2^{112}}{1000 g_0}\biggr)^{1/3}
\approx 3.7\times 10^9 > 2^{31}.
$$
This means that with $n_0$, $n_1$, $n_2$ varying between 0 and a billion
we only use $0.1\%$ (another of Knuth's recommendation) of the numbers
with no recycling.  Since the coeffients, $g_0$, $g_1$, and $g_2$, are
relatively prime, it wouldn't be a big deal to go beyond these limits.

All these routines assume that the machine can handle real quantities
with at least 48 bits of precision.  On most machines this means |double
precision|.  One 


@I macros.hweb

@* External interface to random.

If you're using FWEB, the argument |seed| here always refers to an
eight-element integer array which should be declared by
|rn_seed_decl(seed)|.  |seed| should not be altered by the user.
Similarly the state of the random number generator is stored in
|rn_args(tag)|, where |tag| is an arbitrary tag.  This should not be
altered by the user.  |rn_decl(tag)| declares |rn_args(tag)| and, in a
top-level routine, allocates space for them.

If you're not using FWEB, then replace |rn_args(tag)| by the argument
pair |ran_index,ran_array| and then declare the seed and the state as
follows.

@a
@#if 0
/* |ran_s|, |ran_c|, and |ran_k| are defined in: */

      include 'random.h'

/* Seeds are specified by an argument, |seed|, which should be declared
as: */

      integer seed(ran_s)

/* The external respresentation of the seed is via a string of decimal
digits.  This should be declared as: */

      character*(ran_c) string

/* The state of the random number generator is stored in two variables
which are passed as arguments: |ran_index| and |ran_array|.  These
should be declared as: */

      integer ran_index
      double precision ran_array(ran_k)

/* Finally, you may need to declare the external routines |random| and
|srandom|: */

      double precision random
      real srandom
      external random,srandom

/* In the above, you will need to change |double precision| to |real| on
the Crays. */
@#endif

@ The routines for initializing the seed are:

|call set_random_seed(time,seed)| set the |seed| from an 8-element
integer |time| array.  Typically, |time| is set from |call
date_time(time)| or using the Fortran 90 routine |call
date_and_time(values=time)|.

|call decimal_to_seed(decimal,seed)| initializes the |seed| array from a
decimal number in the character variable |decimal|.  Only the digits in
|decimal| are used, so |'1999/07/30-18:55:33'| is the same is
|'19990730185533'|.  There is no limit on the length of |decimal|.

|call string_to_seed(string,seed)| initializes the |seed| array from an
arbitray ASCII string |string| using a checksum algorithm.  Only the
printable characters in |string| are used.  There is no limit on the
length of |string|.

|call seed_to_decimal(seed,decimal)| converted the |seed| array to a
canonical printable representation in the character variable |decimal|
which should be at least |ran_c=34| characters long.

Possible ways of setting |seed| are:

@a
@#if 0
      include 'random.h'
      integer seed(ran_s)
      integer time(8)
      character*(ran_c) string

/* Set it based on the time of day */
      call date_and_time(values=time)
      call set_random_seed(time,seed)

/* Set it during debugging */
      call decimal_to_seed('0',seed)

/* Set it from a decimal number */
      call decimal_to_seed('Run number: 12987',seed)

/* Set it from an ASCII string */
      call string_to_seed('Pellet injection, case A',seed)

/* In all cases you should write out the seed */
      call seed_to_decimal(seed,string)
      print *,string
@#endif

@ Routines for advancing the seed.  These are needed when independent
random number sequences are required.

|call next_seed(n,seed)| advances the seed $n$ steps forward.  This
allows independent threads of random numbers to be initialized.  This
just invokes |call next_seed3(n,0,0,seed)|.

|call next_seed3(n0,n1,n2,seed)| advances the seed $(n_0,n_1,n_2)$ steps
forward in 3-dimensional space.  The steps along each axis can be up to
at least $10^9$ allowing for a total of $10^{27}$ independent threads to
be initialized.  |next_seed3| might be useful for selecting the seeds
for a three-dimension domain decomposition.

@ Routines for initializing the state for random number generator and
for returning random numbers.

|call random_init_d2(seed,rn_args(tag))| which initializes the random
number generator from |seed|.

|x = random(rn_args(tag))| which returns the next random number in |x|.
|x| is a |double precision| random number uniformly distributed in $(0,1)$.

|call random_array(y,n,rn_args(tag))| which returns the next |n|
random numbers in the |double precision| array |y|.

|sx = srandom(rn_args(tag))| which returns the next random number in |sx|.
|sx| is a |real| random number uniformly distributed in $(0,1)$.

|call srandom_array(sy,n,rn_args(tag))| which returns the next |n|
random numbers in the |real| array |sy|.

The random numbers returned by |random| and |random_array| are of the
form $(i+\frac12)/2^{47}$ for $0\le i < 2^{47}$.  The period of each
thread is about $8.9\times10^{43}$.  Except for the Crays, the random
numbers returned by |srandom| and |srandom_array| are of the form
$(i+\frac12)/2^{23}$ for $0\le i < 2^{23}$, with the same period.  On
the Crays, |srandom| and |srancom_array| are identical to |random| and
|random_array|.

@* Typical calling sequence.  The following is a more-or-less realistic
exampleof using these routines in an MPI code.  It compute $\pi$ by
generating random points in a unit square and counting the number that
lie in a circle of radius 1 within this square.

This example uses the Fortran 90 subroutine |date_and_time|.  This is
present in some recent Fortran 77 implementations (specifically, for Sun
and Digital Unix).  If it is not available initialize the random seed in
some other way.

@a
@#if 0
      program pirandom

* Compute pi by counting the number of randomly generated point lying
* in a circle.  See Gropp et al., ``Using MPI'', Section 3.7.

* MPI declarations
      include 'mpif.h'
      integer id, ierr, len, numprocs
      character*(mpi_max_processor_name) hostname

* Declarations for random numbers
      include 'random.h'
      integer seed(ran_s)
      character*(ran_c) string
      integer ran_index
      double precision ran_array(ran_k)

* For |date_and_time| routine
      character cdate*8,ctime*10,czone*5
      integer time(8)

* A place to store random numbers
      integer m
      parameter (m=1000)
      double precision z(m)

* Other local vaiables
      double precision  pi
      integer iterations
      integer a,sum,tot,i,j

* Set iteration count (each iteration computes $m/2$ points)
      iterations = 10000

* Initialize MPI
      call mpi_init(ierr)
      call mpi_comm_rank(mpi_comm_world, id, ierr)
      call mpi_comm_size(mpi_comm_world, numprocs, iierr)

* Determine and print the seed
      if (id .eq. 0) then
         call date_and_time(cdate,ctime,czone,time)
         call set_random_seed(time,seed)
         call seed_to_decimal(seed,string)
         print *,'An inefficient way to compute pi via Monte Carlo'
         print *,'Seed is set to ',string
      endif

* Tell everyone the value of seed
      call mpi_bcast(seed,ran_s,mpi_integer,0,mpi_comm_world,ierr)

* Advance the seed according to the MPI process number
      call next_seed(id,seed)

* Initialize the random number generator
      call random_init_d2(seed,ran_index,ran_array)
      
* Determine the number of points lying inside a circle of radius 1
      a=0
      do i=(iterations*id)/numprocs,(iterations*(id+1))/numprocs-1
         call random_array(z,m,ran_index,ran_array)
         do j=1,m,2
            if (z(j)**2 + z(j+1)**2 .lt. 1.0d0) then
               a=a+1
            end if
         end do
      end do

* Print some dignostic information
      call mpi_get_processor_name(hostname,len,ierr)
      print *,'Process ',id,' running on ',hostname(1:len),' gives ',a

* Assemble the results onto process 0
      call mpi_reduce(a,sum,1,mpi_integer,mpi_sum,0,mpi_comm_world,ierr)

* Node 0 prints the answer.
      tot=iterations*m/2
      if (id .eq. 0) then
         pi=(4.0d0*sum)/tot
         print *, 'pi is approximately ',4*sum,'/',tot,' = ',pi
      endif

* Terminate MPI
      call mpi_finalize(ierr)

      stop
      end
@#endif

@ The unnamed module.

@a
      @<Functions and Subroutines@>

@ Define constants used in the basic random number generator.  |ran_k|
is defined in the header file to be 100.

@m FILE 'random.web'

@m ran_l 63                     // Set $l$
@m ran_p 1009                   // We use $k$ out of $p$ numbers
@m ran_e 47                     // Bits of precision with double precision
@m ran_es 23                    // Bits of precision with single precision

@m rand_center(x) x+ran_ulp2    // Center returned numbers in $(0,1)$
@#if !HIPREC                    // Likewise for |single_precision|
@m rand_center_s(x) (int(ran_mult*x)+0.5)*ran_ulps
@#endif


@i random.hweb

@* Functions to return random numbers.  We calculate the random numbers
in batches, placing the results into the array |ran_array|.  The routine
to return a single random number, |random|, can then merely return the
next array element.  It calls the routine to calculate the next batch if
necessary.  |ran_index| points to the next element of |ran_array| to be
used.  |ran_max| points to the first invalid element of |ran_array|.
|ran_index| and |ran_array| together describe the state of the random
number generator.  The header file packages these together into a single
argument |rn_args(x)|. |srandom| is an entry point providing a single
precision result.

@<Functions...@>=
      function random(rn_dummy(x))
      implicit_none_f77
      implicit_none_f90
      real ran_ulp2
      parameter (ran_ulp2=two^(-ran_e-1))
@#if !HIPREC
      single_precision ran_ulps
      real ran_mult
      parameter (ran_ulps=2.0^(-ran_es),ran_mult=two^ran_es)
@#endif
      real random               // Function
      single_precision srandom   // Entry
      rn_decl(x)                // RNG state
      external rand_batch       // External

@#if HIPREC
      entry srandom(rn_dummy(x))
@#endif

      if (rn_index(x) >= ran_k) then
         call rand_batch(rn_args(x))
      end if
      random=rand_center(rn_array(x)[rn_index(x)])
@#if HIPREC
      srandom=random
@#endif
      rn_index(x)=rn_index(x)+1

      return
      
@#if !HIPREC
      entry srandom(rn_dummy(x))

      if (rn_index(x) >= ran_k) then
         call rand_batch(rn_args(x))
      end if
      srandom=rand_center_s(rn_array(x)[rn_index(x)])
      rn_index(x)=rn_index(x)+1

      return
@#endif
      end

@ Here is a version of |random| which fills an array.  This is perhaps
more efficient than separate calls to |random|.  |srandom_array| is an
entry point providing a single precision result.

@<Functions...@>=
      subroutine random_array(y,n,rn_dummy(x))
      implicit_none_f77
      implicit_none_f90
      real ran_ulp2
      parameter (ran_ulp2=two^(-ran_e-1))
@#if !HIPREC
      single_precision ran_ulps
      real ran_mult
      parameter (ran_ulps=2.0^(-ran_es),ran_mult=two^ran_es)
@#endif
      integer n                 // Input
      real y(0:n-1)           // Output
@#if !HIPREC
      single_precision ys(0:n-1) // Output
@#endif
      rn_decl(x)             // RNG state
      integer i,k,j             // Local
      external rand_batch     // External
      
@#if HIPREC
      entry srandom_array(y,n,rn_dummy(x))
@#endif

      if (n<=0) return
      k=min(n,ran_k-rn_index(x))
      do i=0,k-1
         y[i]=rand_center(rn_array(x)[i+rn_index(x)])
      end do
      rn_index(x)+=k
      do j=k,n-1,ran_k
         call rand_batch(rn_args(x))
         do i=j,min(j+ran_k,n)-1
            y[i]=rand_center(rn_array(x)[i-j+rn_index(x)])
         end do
         rn_index(x)+=min(ran_k,n-j)
      end do
      return

@#if !HIPREC
      entry srandom_array(ys,n,rn_dummy(x))

      if (n<=0) return
      k=min(n,ran_k-rn_index(x))
      do i=0,k-1
         ys[i]=rand_center_s(rn_array(x)[i+rn_index(x)])
      end do
      rn_index(x)+=k
      do j=k,n-1,ran_k
         call rand_batch(rn_args(x))
         do i=j,min(j+ran_k,n)-1
            ys[i]=rand_center_s(rn_array(x)[i-j+rn_index(x)])
         end do
         rn_index(x)+=min(ran_k,n-j)
      end do
      return
@#endif

      end
      
@* Calculate the next batch.  The fills the next $k$ elements of
|rn_array(x)|.  This uses an local array |w| to skip over $p-k$
elements.  For the implementation given here to work, we require
$p\ge2k$, which is, of course, satisfied for the parameters we use here.

On some machines it is better to implement the operation of taking the
fractional part with a conditional.  Both of these methods are
equivalent since $0\le y<2$.

@#if USEINT
  @m ran_assign(x,y)
      tmp=y;
      x=tmp-int(tmp) @;
@#else
  @m ran_assign(x,y)
      tmp=y;
      if (tmp>=one) then;
         x=tmp-one;
      else;
         x=tmp;
      end if @;
@#endif

@<Functions...@>=
      subroutine rand_batch(rn_dummy(x))
      implicit_none_f77
      implicit_none_f90
      rn_decl(x)                // RNG state
      integer i                 // Local
      real w[0:ran_p-ran_k-1]
      real tmp

/* Sanity check on |rn_index(x)|. */
      assert(rn_index(x) == ran_k)

      do i=0,ran_l-1
         ran_assign(w[i],rn_array(x)[i]+rn_array(x)[i+ran_k-ran_l])
      end do
      do i=ran_l,ran_k-1
         ran_assign(w[i],rn_array(x)[i]+w[i-ran_l])
      end do
      do i=ran_k,ran_p-ran_k-1
         ran_assign(w[i],w[i-ran_k]+w[i-ran_l])
      end do
      do i=ran_p-ran_k,ran_p-ran_k+ran_l-1
         ran_assign(rn_array(x)[i-ran_p+ran_k],
     $        w[i-ran_k]+w[i-ran_l])
      end do
      do i=ran_p-ran_k+ran_l,ran_p-1
         ran_assign(rn_array(x)[i-ran_p+ran_k],
     $        w[i-ran_k]+rn_array(x)[i-ran_p+ran_k-ran_l])
      end do

      rn_index(x)=0

      return
      end

@* Initializing the random number sequence.

This initializes the random number array using the high 47 bits of
successive numbers from a linear congruential generator defined by
equation \ref{linear}.

The 112-bit numbers can be represented as an array of 8 14-bit integers
which allows the multiplications and additions necessary to perform
112-bit multiplies to be carried out on 32-bit machines.  (We don't use
15-bit integers since it is then necessary to do the multiplies more
carefully.)

@ Here is |random_init_d2|.  Note that this routine was originally
named |random_init|, but that name now conflicts with a Fortran
intrinsic function.  This routine iterates $T$ 100 times.  We might use the
101st iterate to turn on one of the least-significant bits in the
unlikely event that they are all zero.  We set |rn_array(x)| from the
|ran_e| most significant bits of |s|.  We place the most significant
(i.e., the most random) byte of |s| in the least significant position in
|rn_array(x)| where it can do the most good; and so on with the other
bytes; finally we place the five most significant bits from the least
significant byte in the five most significant bit positions in
|rn_array(x)|.

The main loop here does not vectorize.  It's possible to remedy this by
first jumping forward by multiples of ten using the tenth power of $T$
and then initalizing the other elements in a parallel fashion.  This
results in a modest speed up on vector machines but slows down the
running time on other machines; so we choose not to do this here.

@m ran_set(i)
      rn_array(x)[i]=(((s[7]*ran_del+s[6])*ran_del+s[5])*ran_del+int(s[4]/512))*512*ran_del @;

@<Functions...@>=
      subroutine random_init_d2(seed,rn_dummy(x))
      implicit_none_f77
      implicit_none_f90
      integer b
      real ran_del,ran_ulp
      parameter (b=2^14,ran_del=two^(-14),ran_ulp=two^(-ran_e))
      integer a0,a1,a2,a3,a4,a5,a6,c0 // The base $2^{14}$ representation of $a_1$ and $c_1$
      parameter (a0=15661,a1=678,a2=724,a3=5245,a4=13656,a5=11852,a6=29)
      parameter (c0=1)
      rn_seed_decl(seed)        // Input
      rn_decl(x)                // Output
      integer i,j,s[0:ran_s-1]  // Local
      logical odd               // At least one seed is odd so far
      integer z[0:ran_s-1],t

      do i=0,ran_s-1
         assert(0<=seed[i] && seed[i]<b)
         s[i]=seed[i]
      end do

      odd = mod(s[7],2) != 0
      ran_set(0)

      do j=1,ran_k-1
         @<Step the linear congruential generator forward one step@>
         odd = odd || (mod(s[7],2) != 0);
         ran_set(j)
      end do
      
      rn_index(x)=ran_k

/* If the least significant bit of all the seeds is zero, then randomly
set one of them to one.  This is {\it very} unlikely to happen. */

      if (odd) return

      @<Step the linear congruential generator forward one step@>
      j=int((s[ran_s-1]*ran_k)/b)
      rn_array(x)[j]+=ran_ulp

      return
      end

@ Here we step the linear congruential generator forward one step.  We
open code this to improve the speed somewhat.  (We use the fact that the
highest byte of $a$ zero as are all but the lowest byte of $c$.)

@<Step the linear congruential generator forward one step@>=
      z[0]=c0+a0*s[0]
      z[1]=a0*s[1]+a1*s[0]
      z[2]=a0*s[2]+a1*s[1]+a2*s[0]
      z[3]=a0*s[3]+a1*s[2]+a2*s[1]+a3*s[0]
      z[4]=a0*s[4]+a1*s[3]+a2*s[2]+a3*s[1]+a4*s[0]
      z[5]=a0*s[5]+a1*s[4]+a2*s[3]+a3*s[2]+a4*s[1]+a5*s[0]
      z[6]=a0*s[6]+a1*s[5]+a2*s[4]+a3*s[3]+a4*s[2]+a5*s[1]+a6*s[0]
      z[7]=a0*s[7]+a1*s[6]+a2*s[5]+a3*s[4]+a4*s[3]+a5*s[2]+a6*s[1]

      t=0
      do i=0,ran_s-1
         t=int(t/b)+z[i]
         s[i]=mod(t,b)
      end do

@ Here's the vectorizing version of |random_init_d2|.  It's commented out
since it's of marginal utility and it's more complicated.

@m ran_k1 10                    // Factor $k=k_1 k_2$.
@m ran_k2 10

@<Functions...@>=
@#if 0
      subroutine random_init_d2(seed,rn_dummy(x))
      implicit_none_f77
      implicit_none_f90
      integer b
      real ran_del,ran_ulp
      parameter (ran_del=two^(-14),ran_ulp=two^(-ran_e),b=2^14)
      rn_seed_decl(seed)        // Input
      rn_decl(x)                // Output
      integer i,j,k,s[0:ran_s-1,0:ran_k1-1] // Local
      logical odd[0:ran_k1-1]               // At lease one seed is odd so far
      integer z[0:ran_s-1,0:ran_k1-1],t[0:ran_k1-1]
      integer a0,a1,a2,a3,a4,a5,a6,c0       // The base $2^{14}$ representation of $a_1$ and $c_1$
      data a0,a1,a2,a3,a4,a5,a6,c0/15661,678,724,5245,13656,11852,29,1/
      integer ak2[0:ran_s-1],ck2[0:ran_s-1] // $T^{k_2}$
      data ak2/11273,6813,10723,15580,4310,5243,1020,6133/
      data ck2/13766,11135,9779,14128,13492,4815,11925,2137/

      do i=0,ran_s-1
         assert(0<=seed[i] && seed[i]<b)
         s[i,0]=seed[i]
      end do
      
      do k=1,ran_k1-1
         do i=0,ran_s-1
            s[i,k]=s[i,k-1]
         end do
         call rand_axc(ak2,s[0,k],ck2)
      end do

      do k=0,ran_k1-1
         odd[k] = (mod(s[7,k],2) != 0)
         rn_array(x)[k*ran_k2]=(((s[7,k]*ran_del+s[6,k])*ran_del+s[5,k])*ran_del+int(s[4,k]/512))*512*ran_del
      end do

      do j=1,ran_k2-1
         do k=0,ran_k1-1
            z[0,k]=c0+a0*s[0,k]
            z[1,k]=a0*s[1,k]+a1*s[0,k]
            z[2,k]=a0*s[2,k]+a1*s[1,k]+a2*s[0,k]
            z[3,k]=a0*s[3,k]+a1*s[2,k]+a2*s[1,k]+a3*s[0,k]
            z[4,k]=a0*s[4,k]+a1*s[3,k]+a2*s[2,k]+a3*s[1,k]+a4*s[0,k]
            z[5,k]=a0*s[5,k]+a1*s[4,k]+a2*s[3,k]+a3*s[2,k]+a4*s[1,k]+a5*s[0,k]
            z[6,k]=a0*s[6,k]+a1*s[5,k]+a2*s[4,k]+a3*s[3,k]+a4*s[2,k]+a5*s[1,k]+a6*s[0,k]
            z[7,k]=a0*s[7,k]+a1*s[6,k]+a2*s[5,k]+a3*s[4,k]+a4*s[3,k]+a5*s[2,k]+a6*s[1,k]
            t[k]=0
         end do

         do i=0,ran_s-1
            do k=0,ran_k1-1
               t[k]=int(t[k]/b)+z[i,k]
               s[i,k]=mod(t[k],b)
            end do
         end do

         do k=0,ran_k1-1
            odd[k] = odd[k] || (mod(s[7,k],2) != 0)
            rn_array(x)[k*ran_k2+j]=(((s[7,k]*ran_del+s[6,k])*ran_del+s[5,k])*ran_del+int(s[4,k]/512))*512*ran_del
         end do
      end do
         
      rn_index(x)=ran_k

/* If the least significant bit of all the seeds is zero, then randomly
set one of them to one.  This is {\it very} unlikely to happen. */

      do k=0,ran_k1-1
         if (odd[k]) return
      end do

      call rand_axc(ak2,s[0,0],ck2)
      j=int((s[ran_s-1,0]*ran_k)/b)
      rn_array(x)[j]+=ran_ulp

      return
      end
@#endif

@* Initializing the seed.

Set the seed from an decimal string.  |seed| is initialized to
zero. Digits 0--9 cause the operation |seed=10*seed+digit|.  Other
characters are ignored.

@<Functions...@>=
      subroutine decimal_to_seed(decimal,seed)
      implicit_none_f77
      implicit_none_f90
      character*(*) decimal
      rn_seed_decl(seed)
      external rand_axc
      integer i,ten[0:ran_s-1],c[0:ran_s-1],ch
      data ten/10,7*0/
      
      do i=0,ran_s-1
         seed[i]=0
         c[i]=0
      end do
      
      do i=1,len(decimal)
         ch=ichar(decimal(i:i))
         if (ch >= ichar('0') && ch <= ichar('9')) then
            c[0]=ch-ichar('0')
            call rand_axc(ten,seed,c)
         end if
      end do
         
      return
      end

@ Set the seed from an arbitrary ASCII string.  Only printable
characters are considered.  Each such character causes the operation
|seed=rotr(seed)+char|, where |rotr| is a circular right shift by one
bit; this is the operation carried out by the BSD sum utility.

@<Functions...@>=
      subroutine string_to_seed(string,seed)
      implicit_none_f77
      implicit_none_f90
      integer b
      parameter (b=2^14)
      character*(*) string
      rn_seed_decl(seed)
      external rand_axc
      integer t,i,k,unity[0:ran_s-1],c[0:ran_s-1],ch
      data unity/1,7*0/
      
      do i=0,ran_s-1
         seed[i]=0
         c[i]=0
      end do
      
      do i=1,len(string)
         ch=ichar(string(i:i))
         if (ch > ichar(' ') && ch < 127) then
            t=mod(seed[0],2)*(b/2)
            do k=0,ran_s-1
               seed[k]=int(seed[k]/2)
               if (k < ran_s-1) then
                  seed[k]+=mod(seed[k+1],2)*(b/2)
               else
                  seed[k]+=t
               end if
            end do
            c[0]=ch
            call rand_axc(unity,seed,c)
//       else the character is whitespace and we skip it.
         end if
      end do
         
      return
      end

@ Choose random seed depending on time.  |time| is the 8-element time
returned by |date_time| (it can also be obtained in Fortran 90 with
|call date_and_time(values=time)|).  The seed is set to
|yyyymmddzzzzhhmmssmmm| where |yyyy| is the year, etc.  The first digit
of |zzzz| is 1 is the zone offset is negative.

@m SP $UNQUOTE(' ')

@<Functions...@>=
      subroutine set_random_seed(time,seed)
      implicit_none_f77
      implicit_none_f90
      integer time[8]           // Input
      rn_seed_decl(seed)        // Output
      character*26 c            // Local
      integer t[8]
      external decimal_to_seed
                                // make sure time is in range
      t[1]=mod(mod(time[1],1000000000)+1000000000,1000000000)
      t[2]=mod(mod(time[2],100)+100,100)
      t[3]=mod(mod(time[3],100)+100,100)
      t[4]=((1-sign(1,time[4]))/2)*1000+mod(abs(time[4]),1000)
      t[5]=mod(mod(time[5],100)+100,100)
      t[6]=mod(mod(time[6],100)+100,100)
      t[7]=mod(mod(time[7],100)+100,100)
      t[8]=mod(mod(time[7],1000)+1000,1000)
      c=' '
      write(c(1:17),'(i9.9,2i2.2,i4.4)') t[1],t[2],t[3],t[4]
      write(c(18:26),'(3i2.2,i3.3)') t[5],t[6],t[7],t[8]
      call decimal_to_seed(c,seed)

      return
      end

@* Convert a seed to its decimal equivalent.

|decimal| should be at least 34 characters long; otherwise the high
digits are lost.  Internal conversion is done to a base of 10000.

@<Functions...@>=
      subroutine seed_to_decimal(seed,decimal)
      implicit_none_f77
      implicit_none_f90
      integer pow,decbase,b
      parameter (pow=4,decbase=10^pow,b=2^14)
      character*(*) decimal
      rn_seed_decl(seed)
      integer z[0:ran_s-1],i,t,j,k
      character*36 str
      
      k=-1
      do i=0,ran_s-1
         z[i]=seed[i]
         assert(0<=z[i] && z[i]<b)
         if (z[i]>0) k=i
      end do
      
      str=' '

 /* $2^{112} < 10^{36}$ */
      
      i=9
loop: continue
      i--
      t=0
      do j=k,0,-1
         z[j]=z[j]+t*b
         t=mod(z[j],decbase)
         z[j]=int(z[j]/decbase)
      end do
      if (z[max(0,k)]==0) k=k-1
      j=pow*(i+1)
      if (k>=0) then
         str(j-(pow-1):j)='0000'
      else
         str(j-(pow-1):j)='   0'
      end if
loop1: continue
      if (t==0) goto skip
      str(j:j)=char(ichar('0')+mod(t,10))
      j=j-1
      t=int(t/10)
      goto loop1
skip: continue
      if (k>=0) goto loop

      k=min(j+1,len(str))

      if (len(decimal)>=len(str(k:))) then
         decimal=str(k:)
      else
         decimal = str(len(str(k:))-len(decimal)+1:)
      end if
      
      return
      end

@* Routines to step the seed forward.

|rand_next_seed| steps the seed $y$ forward $n$ multiples of the
generator specified by |ax| and |cx|.  $n$ is decomposed in binary and
$y$ is stepped forward by powers of 2.  We do this by composing equation
(\ref{linear}) with itself to give
$$
T^2(x) \equiv (a_2 x + c_2) \bmod 2^{112}.
$$
where $a_2=a_1^2 \bmod 2^{112}$ and $c_1= (a_1+1)c_1 \bmod 2^{112}$.
The time is proportional to $\log n$.

@<Functions...@>=
      subroutine rand_next_seed(n,ax,cx,y)
      implicit_none_f77
      implicit_none_f90
      integer n,ax[0:ran_s-1],cx[0:ran_s-1] // Input
      rn_seed_decl(y)           // Input/Output
      external rand_axc
      integer a[0:ran_s-1],c[0:ran_s-1],
     $     z[0:ran_s-1],t[0:ran_s-1],m,i
      data z/ran_s*0/

      if (n == 0) return
      assert(n>0)

      m = n
      do i=0,ran_s-1
         a[i]=ax[i]
         c[i]=cx[i]
      end do

loop: continue
      if (mod(m,2) > 0) then
         call rand_axc(a,y,c)
      end if
      m = int(m/2)
      if (m == 0) return
      do i=0,ran_s-1
         t[i]=c[i]
      end do
      call rand_axc(a,c,t) /* $c'=(a+1)c$ */
      do i=0,ran_s-1
         t[i]=a[i]
      end do
      call rand_axc(t,a,z) /* $a'=a^2$ */
      goto loop

      end


@ |next_seed3| steps the seed forward by $L(n_0,n_1,n_2)$ steps from
equation \ref{stepper}.  In this routine |afk| and |cfk| are precomputed
coefficients for equation \ref{linear} iterated $g_k$ times (i.e.,
forwards) and |abk| and |cbk| are precomputed coefficients for equation
\ref{linear} iterated $-g_k$ times (i.e., backwards).  This routine
works but invoking |rand_next_seed| with the appropriate coefficients for
each of the $n_k$.

|next_seed| is an entry point where only $n_0$ is passed.

@<Functions...@>=
      subroutine next_seed3(n0,n1,n2,seed)
      implicit_none_f77
      implicit_none_f90
      integer n0,n1,n2          // Input
      rn_seed_decl(seed)        // Input/Output
      external rand_next_seed
      integer af0[0:ran_s-1],cf0[0:ran_s-1]
      integer ab0[0:ran_s-1],cb0[0:ran_s-1]
      integer af1[0:ran_s-1],cf1[0:ran_s-1]
      integer ab1[0:ran_s-1],cb1[0:ran_s-1]
      integer af2[0:ran_s-1],cf2[0:ran_s-1]
      integer ab2[0:ran_s-1],cb2[0:ran_s-1]
      data af0/ 15741,  8689,  9280,  4732, 12011,  7130,  6824, 12302/
      data cf0/ 16317, 10266,  1198,   331, 10769,  8310,  2779, 13880/
      data ab0/  9173,  9894, 15203, 15379,  7981,  2280,  8071,   429/
      data cb0/  8383,  3616,   597, 12724, 15663,  9639,   187,  4866/
      data af1/  8405,  4808,  3603,  6718, 13766,  9243, 10375, 12108/
      data cf1/ 13951,  7170,  9039, 11206,  8706, 14101,  1864, 15191/
      data ab1/  6269,  3240,  9759,  7130, 15320, 14399,  3675,  1380/
      data cb1/ 15357,  5843,  6205, 16275,  8838, 12132,  2198, 10330/
      data af2/   445, 10754,  1869,  6593,   385, 12498, 14501,  7383/
      data cf2/  2285,  8057,  3864, 10235,  1805, 10614,  9615, 15522/
      data ab2/   405,  4903,  2746,  1477,  3263, 13564,  8139,  2362/
      data cb2/  8463,   575,  5876,  2220,  4924,  1701,  9060,  5639/

      if (n2>0) then
         call rand_next_seed(n2,af2,cf2,seed)
      else if (n2<0) then
         call rand_next_seed(-n2,ab2,cb2,seed)
      end if

      if (n1>0) then
         call rand_next_seed(n1,af1,cf1,seed)
      else if (n1<0) then
         call rand_next_seed(-n1,ab1,cb1,seed)
      end if

      entry next_seed(n0,seed)

      if (n0>0) then
         call rand_next_seed(n0,af0,cf0,seed)
      else if (n0<0) then
         call rand_next_seed(-n0,ab0,cb0,seed)
      end if

      return
      end

@ A utility routine.   Implement |x=a*x+c|.

@<Functions...@>=
      subroutine rand_axc(a,x,c)
      implicit_none_f77
      implicit_none_f90
      integer b
      parameter (b=2^14)
      integer a[0:ran_s-1],c[0:ran_s-1] // Input
      integer x[0:ran_s-1]      // Input/output
      integer z[0:ran_s-1],i,j,t // Local
      
      do i=0,ran_s-1
         z[i]=c[i]
      end do

/* These |do| loops were originally |do i=0,ran_s-1; do j=0,i| and the
assiment of |z| above was inside the outer loop.  The order of the |do|
loops has been interchanged, so that the inner one can vectorize.  */
      do j=0,ran_s-1
         do i=j,ran_s-1
            z[i]+=a[j]*x[i-j]
         end do
      end do
      
      t=0
      do i=0,ran_s-1
         t=int(t/b)+z[i]
         x[i]=mod(t,b)
      end do
      
      return
      end

@* INDEX.

