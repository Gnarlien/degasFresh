% $Id: c987a3c576d89e2a4e640bac5b51d6070e349234 $
\Title{postdetector}

@* Compute detector signals in a post-processing mode.  

This code uses the |gpi_views| subroutine,
e.g., as in the example |gpicamera.web| file to compute
the end points of the chord representing each camera pixel
as well as the contributions of each zone to that chord's signal.  
Since the |gpi_views|
subroutine depends on data specific to the GPI application,
it cannot be easily adapted to other situations. 
This version has
been generalized in that it handles both
D$_{2}$ (with photons coming from D, D$_{2}$, and D$_{2}^{+}$) and
He puffed gases and has been adapted to multiple GPI applications.

By default, |postdetector| runs with output summed over source groups. 
Output from an individual source group can be obtained by specifying
its number on the command line:
\begin{verbatim}

postdetector 1
\end{verbatim}

The only problem specific information appearing in this file
are
the camera resolution and the target plane.  The
data for the latter are hardcoded here with the specific applications
identified with the |APP| macro.  In principle, these could be moved
to an input file.  However, the camera resolution must remain in macro
statements since the corresponding parameters appear in dimension
statements.  Note that all of the application specific information
must match that in the corresponding |gpi_views| routine (see, e.g.,
{\tt gpicamera.web}).  Note also that {\tt gpicamera.web} is
to be used with the |APP| = |NSTX| option here.  The other
values of |APP| are paired with corresponding variants
of the |detector_setup| routine in {\tt gpicamera.web} that
are {\em not} provided with DEGAS 2.

In addition to the total emission rate (i.e., the quantity to be
compared with the experimentally observed emission), various other
quantities are computed to facilitate checking the simulated 
camera geometry (e.g., the ``target'' $R$ and $Z$) and to
facilitate interpretation of the results (e.g., the ``effective
densities'').  Regarding the latter, no single quantity has been
identified as the most useful.  For examples, see
D. P. Stotler et al., Contrib. Plasma Phys. {\bf 44}, 294 (2004)
and J. R. Myra et al., Phys. Plasmas {\bf 18}, 012305 (2011).

These quantities and the corresponding file (or variable) names are:

\renewcommand{\arraystretch}{1.5}
\begin{tabular}{\vertbar c \vertbar p{3in} \vertbar c \vertbar} \hline
Name  &  Description  & Symbol \\ \hline
{\tt emtt} &  Total emission rate (W/(m$^{2}$ sr)) & $S$ \\
{\tt emsp} &  Emission rate by species {\tt p}  (W/(m$^2$ sr)) &  $S_{p}$  \\
{\tt tarr} &  Target major radius (m) & $R(j_{i})$ \\
{\tt tarz} &  Target vertical coordinate (m) & $Z(j_{i})$ \\
{\tt tate} &  Target electron temperature (eV) & $T_{e}(j_{i})$ \\
{\tt tane} &  Target electron density (m$^{-3}$) & $n_{e}(j_{i})$ \\
{\tt fwpa} &  Emission rate per atom (W) & $F(j_{i}) = S(j_{i}) / n_{1}(j_{i})$ \\
{\tt nef1} &  Effective test density 1 (m$^{-2}$ sr$^{-1}$) & $S / F(j_{i})$ \\
{\tt favg} &  Average emission rate per atom (W) &  $\langle F \rangle \equiv \langle S \rangle / \langle n_{1} \rangle$ \\
{\tt nef3} &  Effective test density 3 (m$^{-2}$ sr$^{-1}$) & $S / \langle F \rangle$ \\
{\tt fwps} &  Specific emission rate per atom (W) & $S_{1} / n_{1}(j_{i})$ \\
{\tt nsf1} &  Specific effective test density 1 (m$^{-2}$ sr$^{-1}$) & $S_{1} / F(j_{i})$ \\
{\tt nsf3} &  Specific effective test density 3 (m$^{-2}$ sr$^{-1}$) & $S_{1} / \langle F_{1} \rangle$ \\
{\tt tnsp} &  Target density of species p (m$^{-3}$) & $n_{p}(j_{i})$ \\
{\tt n2sp} &  Effective density 2 of species p (m$^{-2}$ sr$^{-1}$) & $n_{\rm eff2,p}$ \\
{\tt fasp} &  Average specific emission rate per species p (W) & $\langle F_{p} \rangle \equiv \langle S_{p} \rangle / \langle n_{p} \rangle$ \\ \hline
\end{tabular}

Where:
\begin{itemize}
\item  ``Species p'' refers to the p$^{\rm th}$ species in the problem species list.
\item  If the ``emission rate by species'' tally is present, the emission rate and 
derived quantities can be divided into contributions from the emitting species 
(e.g., D, D$_{2}^{+}$, D$_{2}$).  
One of these is designated as the ``principal'' emitter (``p=1'' e.g., D). 
\item  The function $F$ is the ``atomic physics'' function for the principal emitter, 
i.e., the emission rate per atom evaluated at the local electron density and temperature from 
the input atomic physics tables (i.e., the density of the excited state relative to 
ground multiplied by the Einstein coefficient and energy of the transition).
\item  The ``target'' quantities are set first by identifying the zone ($j_{i}$) 
along each chord ($i$) closest to the target plane and then utilizing the 
corresponding quantity for that zone.
\item  The ``average'' quantities (e.g., $\langle S \rangle$) are averaged along a 
viewing chord over zones within a specified distance (|d_l0| in the code; e.g., 5 cm) 
of the target plane.
\item The second effective density is the emitting particle's density integrated along
the entire viewing chord (i.e., computed just as is the total emission rate).
\item These four characters in the file name will be followed by a string of the form 
\verb+sg?+ where \verb+?+ represents the source group number, with \verb+sg0+ indicating
the sum over all groups (default).
\end{itemize}

\ID{$Id: c987a3c576d89e2a4e640bac5b51d6070e349234 $}

@m FILE 'postdetector.web'

@m MPI_messages 0
@m CHORD_DATA 0
@m chord_stride 5

@I macros.hweb
@I string.hweb
@I geomint.hweb
@I zone.hweb
@I background.hweb
@I problem.hweb
@I species.hweb
@I detector.hweb
@I tally.hweb
@I output.hweb
@I netcdf.hweb
@I sysdep.hweb
@I readfilenames.hweb
@I reaction.hweb
@I materials.hweb
@I mpi.hweb
@I postdetector.hweb

@ The main program.

@a
      program postdetector

      implicit_none_f77
      mp_common
      so_common
      implicit_none_f90

      integer nargs,o_grp
      character*LINELEN arg
      mp_decls
      sy_decls
      st_decls

      mpi_init

      if (mpi_master) call readfilenames
      call degas_init   // In |degasinit.web|

      if (mpi_master) then
/*
   This is not MPI-aware.  Instead, just need to extract the required
   data and broadcast it to the slaves.
*/
         call nc_read_output  // In |pmimatread.web|

         nargs=arg_count()
         if (nargs > 0) then
            assert(nargs == 1)
            call command_arg(nargs,arg)
            o_grp=read_integer(arg)
            assert(so_check(o_grp))
         else
            o_grp=0
         end if
         call fill_views_master(o_grp)
      else
         call fill_views_slave
      end if

      mpi_end

      stop
      end

      @<Functions and Subroutines@>

@ The master routine for evaluating the views.

@m NSTX      0   // Macro for application.  Could specify different 
@m CMOD_XPT  1   // |nx| and |ny| here if needed.
@m CMOD_MID  2
@m NSTX_2010 3
@m NSTX_ENDD 4

@m APP NSTX

@#if 0
@#if (APP == NSTX_2010)
@m nx 64
@m ny 80
@#elseif (APP == NSTX_ENDD)
@m nx 123   // Note that the actual camera pixel indices
@m ny 56    // do not begin at 1.
@#else   // C-Mod or old NSTX
@m nx 64
@m ny 64
@#endif
@#else
@m nx 5
@m ny 5
@#endif
@m nsd 3     // Maximum number of test species yielding photons

/*
   Remove characters causing file name problems
*/
@m name_clean(s,sp) sp=s;  
      ind_tmp=index(sp,'(');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='_';
      ind_tmp=index(sp,')');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='_';
      ind_tmp=index(sp,'|');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='_';
      ind_tmp=index(sp,'+');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='p' @;

@<Functions...@>=
      subroutine fill_views_master(o_grp)

      define_dimen(species_ind,nsd)

      define_varp(em_data,FLOAT,zone_ind)
      define_varp(em_sp_data,FLOAT,species_ind,zone_ind)
      define_varp(test_density,FLOAT,species_ind,zone_ind)
      define_varp(zone_frags,FLOAT,zone_ind)

      implicit_none_f77
      sp_common
      pr_common
      tl_common
      ou_common
      bk_common
      zn_common
      de_common
      mp_common
@#if !HDF4
      po_common
      rf_common
@#endif
      implicit_none_f90

      integer o_grp              // Input

      integer zone,test,ix,iy,inverted_iy,algorithm,nviews,nfrag,nparcel,
     $        nslaves,j,nstart,num,slave,send_data,iview,close_zone,
     $        nx_peak,iy_peak,is,total_tally,species_tally,itally,len,
     $        ns,ind_tmp,igrp,inum,ifrag,this_grp,view_ptr
      integer index_parameters[tl_index_max],target_map[nx][ny],
     $        target_map_slave[nx][ny]
      real em_temp,em_rate,halfwidth,signal,a0_p,a1_p,a2_p,dist,min_dist,
     $     opt,max_opt,em_avg,a0,a1,a2,a3,a3_p,phi,d_l0,d_opt,
     $     peak,cy_l,cy_r
      real x_array[nx],y_array[ny],signal_array[nx][ny],
     $     signal_array_slave[nx][ny],temp_array[nx][ny],
     $     target_r[nx][ny],target_z[nx][ny],target_n[nx][ny][nsd],
     $     w_per_atom[nx][ny],w_sp_per_atom[nx][ny],n_eff1[nx][ny],
     $     n_sp_eff1[nx][ny],n_eff2[nx][ny][nsd],
     $     n_eff2_slave[nx][ny][nsd],fwpa_avg[nx][ny],fwpa_avg_slave[nx][ny],
     $     n_eff3[nx][ny],n_sp_eff3[nx][ny],
     $     target_te[nx][ny],target_ne[nx][ny],
     $     signal_sp_array[nx][ny][nsd],fwpa_sp_avg[nx][ny][nsd],
     $     signal_sp_array_slave[nx][ny][nsd],fwpa_sp_avg_slave[nx][ny][nsd],
     $     profile[ny],n_eff2_sum[nsd],signal_sp[nsd],n_avg[nsd],
     $     em_sp_avg[nsd]
      character*sp_sy_len clean_sy
      character*1 s
      character*3 s_grp
      character*10 name_grp
      logical have_zone_frags
@#if CHORD_DATA
      real r_zone,phi_zone,chord_length
      character*2 ixlab,iylab
      vc_decl(chord_vec)
@#endif
@#if !HDF4
      integer e,fileid     
      character*FILELEN postdet_file
      po_ncdecl
      nc_decls
@#endif
      vc_decl(points[de_view_start:de_view_end])
      external extract_output_datum,gpi_views
      real extract_output_datum

      declare_varp(em_data)
      declare_varp(em_sp_data)
      declare_varp(test_density)
      declare_varp(zone_frags)
      
      @<Memory allocation interface@>
      st_decls
      vc_decls
      mp_decls
      zn_decls
      tl_decls
      
      var_alloc(em_data)
      var_alloc(em_sp_data)
      var_alloc(test_density)
      var_alloc(zone_frags)

      do zone=1,zn_num
         em_data[zone]=zero
         do is=1,nsd
            em_sp_data[zone][is]=zero
            test_density[zone][is]=zero
         end do
      end do
@#if !HDF4          // Use netCDF format      
      po_nx=nx
      po_ny=ny
      po_num_dep_vars=0
      var_realloca(po_xscale)
      var_realloca(po_yscale)
      var_realloca(po_image_data)
      var_realloca(po_image_labels)
      var_realloca(po_image_units)
      var_realloca(po_image_formats)
@#endif      
      total_tally=int_undef
      species_tally=int_undef
      do itally=1,tl_num
         len=string_length(tally_name[itally])
         if (len > 12) then
            if (tally_name[itally]SP(len-12:) == 'emission rate') total_tally=itally
         end if
         if (len > 23) then
            if (tally_name[itally]SP(len-23:) == 'emission rate by species') species_tally=itally
         end if
      end do
      assert(tl_check(total_tally))
      if (tl_check(species_tally)) then
         ns=pr_test_num-1  // Skip the ``geometry'' test species
      else
         ns=1    // Only interested in one species; assume it's the first.
      end if

      em_temp=zero
      do zone=1,zn_num
         if (zn_type(zone) == zn_plasma) then
            index_parameters[tl_index_zone]=zone
            if (o_grp == 0) then
               em_rate=extract_output_datum(index_parameters,1,
     $              out_post_all,o_mean,tally_name[total_tally])
               s_grp='sg0'
               name_grp='all groups'
            else
               em_rate=extract_output_datum(index_parameters,1,
     $              out_post_grp[o_grp][0][o_mean],o_mean,tally_name[total_tally])
               write(s_grp,'(a2,i1)') 'sg',o_grp
               write(name_grp,'(a8,i1)') 'src grp ',o_grp
            end if
            em_data[zone]=em_rate
            em_temp+=em_rate*zn_volume(zone)
            do test=2,pr_test_num    // Skip the ``geometry'' test species
               index_parameters[tl_index_test]=test
               is=test-1
               if (o_grp == 0) then
                  test_density[zone][is]=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,'neutral density')
               else
                  test_density[zone][is]=extract_output_datum(index_parameters,1,
     $                 out_post_grp[o_grp][0][o_mean],o_mean,
     $                 'neutral density')
               end if
               if (tl_check(species_tally)) then
                  if (o_grp == 0) then
                     em_rate=extract_output_datum(index_parameters,1,
     $                    out_post_all,o_mean,tally_name[species_tally])
                  else
                     em_rate=extract_output_datum(index_parameters,1,
     $                    out_post_grp[o_grp][0][o_mean],o_mean,tally_name[species_tally])
                  end if
                  em_sp_data[zone][is]=em_rate
               end if
            end do
         end if
      end do
@#if MPI
      call MPI_bcast(em_data,zn_num,mpi_real,mpi_degas2_root,comm_world_dup,mpi_err)
      call MPI_bcast(em_sp_data,zn_num*nsd,mpi_real,mpi_degas2_root,comm_world_dup,mpi_err)
      call MPI_bcast(test_density,zn_num*nsd,mpi_real,mpi_degas2_root,comm_world_dup,mpi_err)
      call MPI_bcast(ns,1,mpi_int,mpi_degas2_root,comm_world_dup,mpi_err)
@#endif
      if (em_temp > zero) then
         nviews=nx*ny
         have_zone_frags=.false.
         igrp=int_unused
         if (de_grps > 0) then
            do igrp=1,de_grps
               if (detector_num_views[igrp] == nviews) then
                  write(stdout,*) ' Using precomputed chord data for ',
     $                 detector_name[igrp]
                  have_zone_frags=.true.
                  this_grp=igrp
               end if
            end do
         end if
/*
   Copied this logic directly from |do_flights_master|.
*/
@#if MPI
         nslaves=mpi_size-1
/*
   With precomputed |zone_frags|, should just be running in serial mode.  
   However, extending the code would only entail broadcasting the flag
   and the |de| class.
*/
         if (have_zone_frags) then
            assert(' Not set up for MPI with precomputed zone_frags' == ' ')
         end if
@#else
         nslaves=0
@#endif
         nfrag=max(nviews/max(100,10*nslaves),1)  // Size of each chunk
         nparcel=(nviews+nfrag-1)/nfrag  // Number of chunks

@#if MPI
         do j=0,min(nparcel,nslaves)-1   // Send out the initial chunks
            nstart=j*nfrag
            num=min(nfrag,nviews-nstart)
            slave=j+1
@#if MPI_messages 
            write(stderr,*) 'Send initial batch of ', num, ' to slave ',slave
@#endif
            call slave_send_views(slave,nstart,num)
         end do
@#endif

         do j=min(nparcel,nslaves),nparcel-1  // Loop reading results and making additional requests
            nstart=j*nfrag
            num=min(nfrag,nviews-nstart)

@#if MPI
            if (nslaves > 0) then
               call slave_receive_flag(slave)
@#if MPI_messages
               write(stderr,*) 'Slave ',slave,' is done with a batch'
               write(stderr,*) 'Sending ',nfrag,' more to slave ',slave
@#endif 
               send_data=FALSE
               call slave_send_flag(slave,send_data)
               call slave_send_views(slave,nstart,num)
            else
               assert('Why is nslaves = 0 in an MPI run?' == ' ')
            end if
@#else
            @<Compute Signal@>
@#endif 

         end do

@#if MPI
         do j=0,min(nparcel,nslaves)-1   // Retrieve data from slaves this time
            call slave_receive_flag(slave)
            send_data=TRUE
            call slave_send_flag(slave,send_data)
            call slave_receive_data(slave,signal_array_slave,
     $           target_map_slave,fwpa_avg_slave,n_eff2_slave,signal_sp_array_slave,
     $           fwpa_sp_avg_slave)

            do iy=1,ny
               do ix=1,nx
                  if (signal_array_slave[ix][iy] != real_unused) then
                     signal_array[ix][iy]=signal_array_slave[ix][iy]
                     assert(target_map_slave[ix][iy] != int_unused)
                     target_map[ix][iy]=target_map_slave[ix][iy]
                     fwpa_avg[ix][iy]=fwpa_avg_slave[ix][iy]
                     do is=1,ns
                        assert(n_eff2_slave[ix][iy][is] != real_unused)
                        n_eff2[ix][iy][is]=n_eff2_slave[ix][iy][is]
                        signal_sp_array[ix][iy][is]=signal_sp_array_slave[ix][iy][is]
                        fwpa_sp_avg[ix][iy][is]=fwpa_sp_avg_slave[ix][iy][is]
                     end do
                  end if
               end do
            end do
            
         end do

         do j=0,nslaves-1     // Kill off slaves
            slave=j+1
            call slave_send_views(slave,0,0)
         end do
@#endif
      
         do ix=1,nx
            x_array[ix]=areal(ix-1)
         end do

         do iy=1,ny
@#if (APP == NSTX_2010 || APP == CMOD_MID)
            y_array[iy]=areal(iy-1)
@#else
            inverted_iy=ny-iy+1
            y_array[inverted_iy]=areal(iy-1)
@#endif
         end do

         call wrdatap(signal_array,x_array,y_array,1,nx,1,ny,
     $        'total emission rate '\/name_grp,'W/(m^2 sr)',
     $        'emtt'\/s_grp,'E11.3')

         if (ns > 1) then
            do is=1,ns
               do iy=1,ny
                  do ix=1,nx
                     temp_array[ix][iy]=signal_sp_array[ix][iy][is]
                  end do
               end do
               name_clean(sp_sy(pr_test(is+1)),clean_sy)   // see |geomtesta.web|
               assert(ns < 10)
               write(s,'(i1)') is
               call wrdatap(temp_array,x_array,y_array,1,nx,1,ny,
     $              'emission rate by '\/trim(clean_sy)\/' '\/name_grp,
     $              'W/(m^2 sr)','ems'\/s\/s_grp,'E11.3')
            end do
         end if

@#if 0
         nx_peak=33   // I.e., at cx = 32
         iy_peak=0
         peak=zero
         do iy=1,ny
            profile[iy]=signal_array[nx_peak][iy]
            if (profile[iy] > peak) then
               peak=profile[iy]
               iy_peak=iy
            end if
         end do
         assert(peak > zero)
         assert(iy_peak > 0)
         
         assert(half*peak > profile[1])
         cy_l=zero
         cy_r=zero
         do iy=1,ny
            if ((cy_l == zero) && (profile[iy] > half*peak)) then
               cy_l=y_array[iy-1]-(half*peak-profile[iy-1])
     $              /(profile[iy]-profile[iy-1])
            end if
            if ((cy_r == 0) && (cy_l > zero) && (profile[iy] < half*peak)) then
               cy_r=y_array[iy-1]-(half*peak-profile[iy-1])
     $              /(profile[iy]-profile[iy-1])
            end if
         end do
         open(unit=diskout,file='detectorprofile.txt',status='unknown')
         write(diskout,*) ' At cx = ',x_array[nx_peak],', peak = ',peak,
     $        ', at cy = ',y_array[iy_peak]
         write(diskout,*) ' Half peak at cy = ',cy_l,', and ',cy_r,
     $        ', FWHM = ',cy_r-cy_l
         write(diskout,*) 'iy   profile'
         do iy=1,ny
            write(diskout,*) y_array[iy],profile[iy]
         end do
         close(unit=diskout)
@#endif
         do iy=1,ny
            do ix=1,nx
               if (zn_check(target_map[ix][iy])) then
                  zone=target_map[ix][iy]
                  target_r[ix][iy]=sqrt(zone_center[zone][1]**2
     $                 +zone_center[zone][2]**2)
                  target_z[ix][iy]=zone_center[zone][3]
                  target_te[ix][iy]=bk_temp(1,zone)/electron_charge
                  target_ne[ix][iy]=bk_n(1,zone)
                  do is=1,ns
                     target_n[ix][iy][is]=test_density[zone][is]
                  end do
                  if (test_density[zone][1] > zero) then
                     w_per_atom[ix][iy]=em_data[zone]/test_density[zone][1]
/*
   This is just the emission by the principal species in the multi-species case.
   Skip the other permutations.
*/
                     w_sp_per_atom[ix][iy]=em_sp_data[zone][1]/test_density[zone][1]
                  else
                     w_per_atom[ix][iy]=zero
                     w_sp_per_atom[ix][iy]=zero
                  end if
               else
                  target_r[ix][iy]=zero
                  target_z[ix][iy]=zero
                  target_te[ix][iy]=zero
                  target_ne[ix][iy]=zero
                  do is=1,ns
                     target_n[ix][iy][is]=zero
                  end do
                  w_per_atom[ix][iy]=zero
                  w_sp_per_atom[ix][iy]=zero
               end if
               if (w_per_atom[ix][iy] > zero) then
                  n_eff1[ix][iy]=signal_array[ix][iy]/w_per_atom[ix][iy]
               else
                  n_eff1[ix][iy]=zero
               end if
               if (w_sp_per_atom[ix][iy] > zero) then
                  n_sp_eff1[ix][iy]=signal_sp_array[ix][iy][1]/w_sp_per_atom[ix][iy]
               else
                  n_sp_eff1[ix][iy]=zero
               end if
               if (fwpa_avg[ix][iy] > zero) then
                  n_eff3[ix][iy]=signal_array[ix][iy]/fwpa_avg[ix][iy]
               end if
               if (fwpa_sp_avg[ix][iy][1] > zero) then
                  n_sp_eff3[ix][iy]=signal_sp_array[ix][iy][1]/fwpa_sp_avg[ix][iy][1]
               else
                  n_sp_eff3[ix][iy]=zero
               end if
            end do
         end do
      end if

      call wrdatap(target_r,x_array,y_array,1,nx,1,ny,
     $     'target major radius','m','tarr'\/s_grp,'E11.3')
      call wrdatap(target_z,x_array,y_array,1,nx,1,ny,
     $     'target vertical coord','m','tarz'\/s_grp,'E11.3')
      call wrdatap(target_te,x_array,y_array,1,nx,1,ny,
     $     'target electron temperature','eV','tate'\/s_grp,'E11.3')
      call wrdatap(target_ne,x_array,y_array,1,nx,1,ny,
     $     'target electron density','m^-3','tane'\/s_grp,'E11.3')
      call wrdatap(w_per_atom,x_array,y_array,1,nx,1,ny,
     $     'emission rate per atom '\/name_grp,'W','fwpa'\/s_grp,'E11.3')
      call wrdatap(n_eff1,x_array,y_array,1,nx,1,ny,
     $     'effective test density 1 '\/name_grp,'m^-2 sr^-1',
     $     'nef1'\/s_grp,'E11.3')
      call wrdatap(fwpa_avg,x_array,y_array,1,nx,1,ny,
     $     'avg emission rate per atom '\/name_grp,'W',
     $     'favg'\/s_grp,'E11.3')
      call wrdatap(n_eff3,x_array,y_array,1,nx,1,ny,
     $     'effective test density 3 '\/name_grp,'m^-2 sr^-1',
     $     'nef3'\/s_grp,'E11.3')

      if (tl_check(species_tally)) then
         call wrdatap(w_sp_per_atom,x_array,y_array,1,nx,1,ny,
     $        'specific emission rate per atom '\/name_grp,'W',
     $        'fwps'\/s_grp,'E11.3')
         call wrdatap(n_sp_eff1,x_array,y_array,1,nx,1,ny,
     $        'specific effective test density 1 '\/name_grp,'m^-2 sr^-1',
     $        'nsf1'\/s_grp,'E11.3')
         call wrdatap(n_sp_eff3,x_array,y_array,1,nx,1,ny,
     $        'specific effective test density 3 '\/name_grp,'m^-2 sr^-1',
     $        'nsf3'\/s_grp,'E11.3')
      end if

      do is=1,ns
         name_clean(sp_sy(pr_test(is+1)),clean_sy) 
         write(s,'(i1)') is
         do iy=1,ny
            do ix=1,nx
               temp_array[ix][iy]=target_n[ix][iy][is]
            end do
         end do
         call wrdatap(temp_array,x_array,y_array,1,nx,1,ny,
     $        'target density of '\/trim(clean_sy)\/' '\/name_grp,'m^-3',
     $        'tns'\/s\/s_grp,'E11.3')
         do iy=1,ny
            do ix=1,nx
               temp_array[ix][iy]=n_eff2[ix][iy][is]
            end do
         end do
         call wrdatap(temp_array,x_array,y_array,1,nx,1,ny,
     $        'effective density 2 of '\/trim(clean_sy)\/' '\/name_grp,
     $        'm^-2 sr^-1','n2s'\/s\/s_grp,'E11.3')
         do iy=1,ny
            do ix=1,nx
               temp_array[ix][iy]=fwpa_sp_avg[ix][iy][is]
            end do
         end do
         call wrdatap(temp_array,x_array,y_array,1,nx,1,ny,
     $        'avg specific emission rate per '\/trim(clean_sy)\/' '\/name_grp,
     $        'W','fas'\/s\/s_grp,'E11.3')
      end do

      var_free(em_data)
      var_free(em_sp_data)
      var_free(test_density)
      var_free(zone_frags)
@#if !HDF4
      var_reallocb(po_xscale)
      var_reallocb(po_yscale)
      var_reallocb(po_image_data)
      var_reallocb(po_image_labels)
      var_reallocb(po_image_units)
      var_reallocb(po_image_formats)
      e=index(filenames_array[outputfile],'.nc')-1
      assert(e > 0)
      postdet_file=filenames_array[outputfile]SP(:e)\/'_post.nc'
      
      fileid = nccreate(postdet_file,NC_CLOBBER,nc_stat)
      po_ncdef(fileid)
      call ncendef(fileid,nc_stat)
      po_ncwrite(fileid)
      call ncclose(fileid,nc_stat)
      var_free(po_xscale)
      var_free(po_yscale)
      var_free(po_image_data)
      var_free(po_image_labels)
      var_free(po_image_units)
      var_free(po_image_formats)
@#endif

      return
      end

@* Compute signal.  This code is repeated in the master and slave |fill_views|
routines.

@<Compute Signal@>=
/*
   Specific parameters for this application
*/
@#if (APP == NSTX)
      a0=-const(3.60752)  // Coefficients of the camera's ``target plane''
      a1=const(2.11865)
      a2=const(3.17544)
      a3=-one
      phi=const(6.146,1)*PI/const(1.8,2)  // Toroidal shift to my system
      d_l0=const(5.,-2)     // Range for averaging about target plane
      d_opt=const(2.5,-1)   // Range for searching for a close zone
@#elif (APP == CMOD_MID)
      a0=-sin(const(-18.48)*PI/const(1.8,2))  // A vertical plane at this
      a1=cos(const(-18.48)*PI/const(1.8,2))   // toroidal angle
      a2=zero
      a3=zero
      phi=zero           // No additional toroidal shift needed
      d_l0=const(5.,-2) 
      d_opt=const(3.0,-1)
@#elif (APP == CMOD_XPT)
      a0=-sin(const(33.0)*PI/const(1.8,2))  // Again, a vertical plane
      a1=cos(const(33.0)*PI/const(1.8,2))  
      a2=zero
      a3=zero
      phi=zero      
      d_l0=const(5.,-2) 
      d_opt=const(3.0,-1)
@#elif (APP == NSTX_2010)
      a0=-const(3.58653)  // Coefficients of the camera's ``target plane''
      a1=const(2.08796)
      a2=const(3.18466)
      a3=-one
      phi=const(6.146,1)*PI/const(1.8,2)  // Toroidal shift to my system
      d_l0=const(5.,-2)     // Range for averaging about target plane
      d_opt=const(2.5,-1)   // Range for searching for a close zone
@#elif (APP == NSTX_ENDD)
      a0=-sin(const(155.0)*PI/const(1.8,2))  // Again, a vertical plane
      a1=cos(const(155.0)*PI/const(1.8,2))  
      a2=zero
      a3=zero
      phi=zero      
      d_l0=const(5.,-2) 
      d_opt=const(3.0,-1)
@#else
      assert('Target plane parameters not specified' == ' ')
@#endif
/*
   Rotate Ricky's ``target plane'' to my coordinate system.  The ``p''
   denotes ``prime''.
*/
      a0_p=a0*cos(phi)+a1*sin(phi)
      a1_p=a1*cos(phi)-a0*sin(phi)
      a2_p=a2
      a3_p=a3
      do iview=nstart,nstart+num-1
         if (mod(iview+1,nx) != 0) then
            iy=(iview+1)/nx+1
            ix=(iview+1)-(iy-1)*nx
         else
            iy=(iview+1)/nx
            ix=nx
         end if
         if (have_zone_frags) then
            assert((this_grp >= 1) && (this_grp <= de_grps))
            do zone=1,zn_num
               zone_frags[zone]=zero
            end do
            view_ptr=de_view_pointer(iview+1,this_grp)
            do inum=1,de_zone_frags_num[view_ptr]
               ifrag=de_zone_frags_start[view_ptr] + (inum-1)
               zone=de_zone_frags_zones[ifrag]
               assert(zn_check(zone))
               zone_frags[zone]=de_zone_frags[ifrag]
            end do
         else
            call gpi_views(ix,nx,iy,ny,
     $           vc_args(points[de_view_start]),halfwidth,
     $           algorithm,zone_frags)
         end if
@#if CHORD_DATA
         if ((mod(ix,chord_stride) == 0) && (mod(iy,chord_stride) == 0)) then
            write(ixlab,'(i2.2)') ix
            write(iylab,'(i2.2)') iy
            open(unit=diskout,file='gpi_chord_'\/ixlab\/'_'\/iylab,status='unknown')
            write(diskout,*) '  zone  zone_frag   distance  R  phi  Z  em_data  densities'
         end if
@#endif
         signal=zero
         em_avg=zero
         do is=1,ns
            n_eff2_sum[is]=zero
            signal_sp[is]=zero
            n_avg[is]=zero
            em_sp_avg[is]=zero
         end do
         min_dist=const(1.,16)
         max_opt=const(1.,-16)
         close_zone=int_undef
         vc_copy(de_view_points[iview][de_view_start],points[de_view_start])
         do zone=1,zn_num
@#if CHORD_DATA
            if ((zone_frags[zone] > zero) 
     $         && (mod(ix,chord_stride) == 0) && (mod(iy,chord_stride) == 0))    then
               r_zone=sqrt(zone_center[zone][1]**2+zone_center[zone][2]**2)
               phi_zone=atan2(zone_center[zone][2],zone_center[zone][1])
               vc_difference(zone_center[zone],points[de_view_start],chord_vec)
               chord_length=vc_abs(chord_vec)
               write(diskout,
     $              '(2x,i7,2x,1p,e16.8,0p,4(2x,f11.8),1p,4(2x,e16.8))') 
     $              zone,zone_frags[zone]*zn_volume(zone),chord_length,
     $              r_zone,phi_zone,zone_center[zone][3],
     $              em_data[zone],(test_density[zone][is],is=1,ns)
            end if
@#endif
            signal+=em_data[zone]*zone_frags[zone]*zn_volume(zone)
            do is=1,ns
               n_eff2_sum[is]+=test_density[zone][is]*zone_frags[zone]*zn_volume(zone)
               signal_sp[is]+=em_sp_data[zone][is]*zone_frags[zone]*zn_volume(zone)
            end do
/*
   Hack to distill out zone closest to target plane.
*/
            dist=abs(a0_p*zone_center[zone][1]+a1_p*zone_center[zone][2]
     $              +a2_p*zone_center[zone][3]+a3_p)
     $            /sqrt(a0_p**2+a1_p**2+a2_p**2)
            if (dist != zero) then
               opt=zone_frags[zone]*zn_volume(zone)/dist
            else
/*
   In the C-Mod problems, can actually get |dist| = 0.  Use a finite
   length for computing |opt| to distinguish these in-target-plane zones.
*/
               opt=zone_frags[zone]*zn_volume(zone)/const(1.,-8)
            end if
@#if 0
            if ((zone_frags[zone] > zero) && (dist < min_dist)) then
@#endif
            if ((opt > max_opt) && (dist <= d_opt)) then
               max_opt=opt
               min_dist=dist
               close_zone=zone
            end if
/*
   Sums restricted to region around target plane.
*/
            if (dist <= d_l0) then
               em_avg+=em_data[zone]*zone_frags[zone]*zn_volume(zone)
               do is=1,ns
                  n_avg[is]+=test_density[zone][is]*zone_frags[zone]*zn_volume(zone)
                  em_sp_avg[is]+=em_sp_data[zone][is]*zone_frags[zone]*zn_volume(zone)
               end do
            end if
         end do
@#if CHORD_DATA
      if ((mod(ix,chord_stride) == 0) && (mod(iy,chord_stride) == 0))
     $         close(unit=diskout)
@#endif
@#if (APP == NSTX_2010 || APP == NSTX_ENDD || CMOD_MID)
         inverted_iy=iy
@#else
         inverted_iy=ny-iy+1
@#endif
/*
   Have a case now in which a chord does not reach the target plane.
   Will let |close_zone| remain |int_undef| and then assign zero
   values to the associated target parameters.
*/
@#if 0
         assert(close_zone != int_undef)
         assert(min_dist < const(1.,16))
@#endif
         target_map[ix][inverted_iy]=close_zone
         signal_array[ix][inverted_iy]=signal
         if (n_avg[1] > zero) then
            fwpa_avg[ix][inverted_iy]=em_avg/n_avg[1]
         else
            fwpa_avg[ix][inverted_iy]=zero
         end if
         do is=1,ns
            n_eff2[ix][inverted_iy][is]=n_eff2_sum[is]
            signal_sp_array[ix][inverted_iy][is]=signal_sp[is]
            if (n_avg[is] > zero) then
               fwpa_sp_avg[ix][inverted_iy][is]=em_sp_avg[is]/n_avg[is]
            else
               fwpa_sp_avg[ix][inverted_iy][is]=zero
            end if
         end do

      end do

@ Slave version for filling views.

@<Functions...@>=
@#if MPI
      subroutine fill_views_slave

      define_varp(em_data,FLOAT,zone_ind)
      define_varp(em_sp_data,FLOAT,species_ind,zone_ind)
      define_varp(test_density,FLOAT,species_ind,zone_ind)
      define_varp(zone_frags,FLOAT,zone_ind)

      implicit_none_f77
      mp_common
      zn_common
      de_common
      implicit_none_f90

      integer iy,ix,tag,num,nstart,iview,is,ns,algorithm,close_zone,zone,
     $        inverted_iy,done_flag,send_data,inum,ifrag,this_grp,view_ptr
      integer target_map[nx][ny]
      real halfwidth,signal,a0_p,a1_p,a2_p,dist,min_dist,a0,a1,
     $     a2,a3,phi,d_l0,d_opt,a3_p,em_avg,opt,max_opt
      real signal_array[nx][ny],n_eff2[nx][ny][nsd],fwpa_avg[nx][ny],
     $     signal_sp_array[nx][ny][nsd],fwpa_sp_avg[nx][ny][nsd],
     $     n_eff2_sum[nsd],signal_sp[nsd],n_avg[nsd],em_sp_avg[nsd]
      logical have_zone_frags
@#if CHORD_DATA
      real r_zone,phi_zone,chord_length
      character*2 ixlab,iylab
      vc_decl(chord_vec)
@#endif
      vc_decl(points[de_view_start:de_view_end])

      declare_varp(em_data)
      declare_varp(em_sp_data)
      declare_varp(test_density)
      declare_varp(zone_frags)
      
      @<Memory allocation interface@>
      vc_decls
      mp_decls
      zn_decls

      var_alloc(em_data)
      var_alloc(em_sp_data)
      var_alloc(test_density)
      var_alloc(zone_frags)

      call MPI_bcast(em_data,zn_num,mpi_real,mpi_degas2_root,comm_world_dup,mpi_err)
      call MPI_bcast(em_sp_data,zn_num*nsd,mpi_real,mpi_degas2_root,comm_world_dup,mpi_err)
      call MPI_bcast(test_density,zn_num*nsd,mpi_real,mpi_degas2_root,comm_world_dup,mpi_err)
      call MPI_bcast(ns,1,mpi_int,mpi_degas2_root,comm_world_dup,mpi_err)

      do iy=1,ny
         do ix=1,nx
            signal_array[ix][iy]=real_unused
            target_map[ix][iy]=int_unused
            fwpa_avg[ix][iy]=real_unused
            do is=1,ns
               n_eff2[ix][iy][is]=real_unused
               signal_sp_array[ix][iy][is]=real_unused
               fwpa_sp_avg[ix][iy][is]=real_unused
            end do
         end do
      end do

loop: continue
      tag=100
      call MPI_recv(num,1,mpi_int,mpi_degas2_root,tag,comm_world_dup,mpi_status,mpi_err)
      if (num == 0) goto break
      tag++
      call MPI_recv(nstart,1,mpi_int,mpi_degas2_root,tag,comm_world_dup,mpi_status,mpi_err)
/*
   See comment in master routine.
*/
      have_zone_frags=.false.
      @<Compute Signal@>

      done_flag=TRUE
      tag=200
      call MPI_send(done_flag,1,mpi_int,mpi_degas2_root,tag,comm_world_dup,mpi_err)

      tag=300
      call MPI_recv(send_data,1,mpi_int,mpi_degas2_root,tag,comm_world_dup,mpi_status,mpi_err)
      if (send_data == FALSE) then
         goto loop
      else if (send_data == TRUE) then
         
         tag=400

         call MPI_send(signal_array,nx*ny,mpi_real,mpi_degas2_root,tag,comm_world_dup,mpi_err)
         tag=401
         call MPI_send(target_map,nx*ny,mpi_int,mpi_degas2_root,tag,comm_world_dup,mpi_err)
         tag=402
         call MPI_send(fwpa_avg,nx*ny,mpi_real,mpi_degas2_root,tag,comm_world_dup,mpi_err)
         tag=403
         call MPI_send(n_eff2,nx*ny*nsd,mpi_real,mpi_degas2_root,tag,comm_world_dup,mpi_err)
         tag=404
         call MPI_send(signal_sp_array,nx*ny*nsd,mpi_real,mpi_degas2_root,tag,comm_world_dup,mpi_err)
         tag=405
         call MPI_send(fwpa_sp_avg,nx*ny*nsd,mpi_real,mpi_degas2_root,tag,comm_world_dup,mpi_err)
         do iy=1,ny
            do ix=1,nx
               signal_array[ix][iy]=real_unused
               target_map[ix][iy]=int_unused
               fwpa_avg[ix][iy]=real_unused
               do is=1,ns
                  n_eff2[ix][iy][is]=real_unused
                  signal_sp_array[ix][iy][is]=real_unused
                  fwpa_sp_avg[ix][iy][is]=real_unused
               end do
            end do
         end do

         goto loop
      else
         assert('Illegal value of send_data' == ' ')
      end if

break: continue

      var_free(em_data)
      var_free(em_sp_data)
      var_free(test_density)
      var_free(zone_frags)
      return
      end
@#else
      subroutine fill_views_slave
// dummy
      return
      end
@#endif

@ Send data to slave.

@<Functions...@>=
@#if MPI
      subroutine slave_send_views(slave,nstart,num)
      implicit_none_f77
      mp_common
      implicit_none_f90
      mp_decls
      integer slave,nstart,num
      integer tag
      @<Memory allocation interface@>

      tag=100
      call MPI_send(num,1,mpi_int,slave,tag,comm_world_dup,mpi_err)
      if (num == 0) goto break
      tag++
      call MPI_send(nstart,1,mpi_int,slave,tag,comm_world_dup,mpi_err)

break: continue
      return
      end
@#endif

@ Receive notice from a slave indicating that it is done with current batch.

@<Functions...@>=
@#if MPI
      subroutine slave_receive_flag(slave)
      implicit_none_f77
      mp_common
      implicit_none_f90
      mp_decls
      integer slave
      integer tag,done_flag
      @<Memory allocation interface@>

      tag=200
      call MPI_recv(done_flag,1,mpi_int,MPI_ANY_SOURCE,tag,comm_world_dup,mpi_status,mpi_err)
      slave=mpi_status(MPI_SOURCE)
      assert(done_flag == TRUE)
      return
      end
@#endif

@ Send a flag to a slave instructing it to send back data from its flights.

@<Functions...@>=
@#if MPI
      subroutine slave_send_flag(slave,send_data)
      implicit_none_f77
      mp_common
      implicit_none_f90
      mp_decls
      integer slave,send_data         // Input
      integer tag                     // Local
      @<Memory allocation interface@>

      tag=300
      call MPI_send(send_data,1,mpi_int,slave,tag,comm_world_dup,mpi_err)

      return
      end
@#endif

@ Receive data from flights run by a slave.

@<Functions...@>=
@#if MPI
      subroutine slave_receive_data(slave,signal_array,target_map,fwpa_avg,n_eff2,
     $                              signal_sp_array,fwpa_sp_avg)
      implicit_none_f77
      mp_common
      implicit_none_f90
      mp_decls
      integer slave
      integer target_map[nx][ny]
      real signal_array[nx][ny],fwpa_avg[nx][ny],n_eff2[nx][ny][nsd],
     $     signal_sp_array[nx][ny][nsd],fwpa_sp_avg[nx][ny][nsd]
      integer tag
      @<Memory allocation interface@>

      tag=400
      call MPI_recv(signal_array,nx*ny,mpi_real,MPI_ANY_SOURCE,tag,
     $     comm_world_dup,mpi_status,mpi_err)
      tag=401
      call MPI_recv(target_map,nx*ny,mpi_int,MPI_ANY_SOURCE,tag,
     $     comm_world_dup,mpi_status,mpi_err)
      tag=402
      call MPI_recv(fwpa_avg,nx*ny,mpi_real,MPI_ANY_SOURCE,tag,
     $     comm_world_dup,mpi_status,mpi_err)
      tag=403
      call MPI_recv(n_eff2,nx*ny*nsd,mpi_real,MPI_ANY_SOURCE,tag,
     $     comm_world_dup,mpi_status,mpi_err)
      tag=404
      call MPI_recv(signal_sp_array,nx*ny*nsd,mpi_real,MPI_ANY_SOURCE,
     $     tag,comm_world_dup,mpi_status,mpi_err)
      tag=405
      call MPI_recv(fwpa_sp_avg,nx*ny*nsd,mpi_real,MPI_ANY_SOURCE,
     $     tag,comm_world_dup,mpi_status,mpi_err)

      return
      end
@#endif

@ Rearrange 2D array prior to writing.  This configuration is specific
to the 2004 NSTX Gas Puff Imaging experiments.

@<Functions...@>=
      subroutine wrdatap(pb2dat,xdat,ydat,kxmin,kx,kymin,ky,clabel,cunits,
     $                  cfilrt,cformt)
      implicit_none_f77
      implicit_none_f90

      integer kxmin,kx,ky,kymin     // Input
      character*(*) cunits,clabel,cfilrt,cformt
      real xdat[kx],ydat[ky],pb2dat[kx][ky]

      integer ix,iy,ixprime,iyprime                // Local
      real xprime[ny],yprime[nx],pb2prime[ny][nx]

      assert(kx == nx)
      assert(ky == ny)
@#if (APP == NSTX)
      assert(kx == ky)
/*
   The required mapping is equivalent to |rowflip(transpose(q))| in
   Transform.  Namely, swap |ix| and |iy|, and then invert the
   horizontal coordinate.  Note that we just assume that the
   dimensions are the same in both directions.
*/
      do iy=kymin,ky
         do ix=kxmin,kx
            ixprime=iy
            iyprime=kx-ix+1
            pb2prime[ixprime][iyprime]=pb2dat[ix][iy]
         end do
      end do
/*
   Apply equivalent transformations to the scales.
*/
      do ix=kxmin,kx
         xprime[ix]=ydat[ix]
      end do

      do iy=kymin,ky
         ixprime=ky-iy+1
         yprime[iy]=xdat[ixprime]
      end do
/*
   Call |wrdata| with the revised arrays
*/
      call wrdata(pb2prime,xprime,yprime,kxmin,kx,kymin,ky,clabel,cunits,
     $                  cfilrt,cformt)
@#else
      call wrdata(pb2dat,xdat,ydat,kxmin,kx,kymin,ky,clabel,cunits,
     $                  cfilrt,cformt)
@#endif

      return
      end

@ Write 2D array to HDF file.  Borrowed this from the H collisional
radiative code, irls.

@<Functions...@>=
      subroutine wrdata(pb2dat,xdat,ydat,kxmin,kx,kymin,ky,clabel,cunits,
     $                  cfilrt,cformt)
      implicit_none_f77
@#if !HDF4
      po_common
@#endif
      implicit_none_f90

      integer kxmin,kx,ky,kymin     // Input
      character*(*) cunits,clabel,cfilrt,cformt
      real xdat[kx],ydat[ky],pb2dat[kx][ky]
@#if HDF4
      integer icount,iret,ix,iy,irank              // Local
      integer*4 idim[2]
      single_precision zdatic,zmax,zmin
      single_precision zxdat[kx],zydat[ky],zdata[kx*ky]

      integer dssdast,dssdims,dssdisc,dssrang,dspdata
      external dssdast,dssdims,dssdisc,dssrang,dspdata,xerrab
/*
   Set dimension sizes
*/
      irank=2
      idim[1]=kx-kxmin+1
      idim[2]=ky-kymin+1
/*
   Determine maximum and minimum; assign data to 1-D work array.
*/
      zmax=-const(1.,20)
      zmin=const(1.,20)
      icount=0

      do iy=kymin,ky
         zydat[iy]=single(ydat[iy])
         do ix=kxmin,kx
            zxdat[ix]=single(xdat[ix])
            icount++
            zdatic=pb2dat[ix][iy]
            zmax=max(zmax,zdatic)
            zmin=min(zmin,zdatic)
            zdata[icount]=zdatic
         end do
      end do
/*
   HDF set calls
*/
      iret=dssdims(irank,idim)
      assert(iret == 0)
      iret=dssdisc(1,idim[1],zxdat)
      assert(iret == 0)
      iret=dssdisc(2,idim[2],zydat)
      assert(iret == 0)
      iret=dssdast(clabel,cunits,cformt,'cartesian')
      assert(iret == 0)

      iret=dssrang(zmax,zmin)
      assert(iret == 0)
/*
   Write 2-D data
*/
      iret=dspdata(cfilrt\/'.hdf',2,idim,zdata)
      assert(iret == 0)
@#else                               // !HDF
      integer ix,iy,jx,jy            // Local
      
      @<Memory allocation interface@>

      assert(po_nx == kx-kxmin+1)
      assert(po_ny == ky-kymin+1)
      po_num_dep_vars++
      var_realloca(po_xscale)
      var_realloca(po_yscale)
      var_realloca(po_image_data)
      var_realloca(po_image_labels)
      var_realloca(po_image_units)
      var_realloca(po_image_formats)
/*
   Define associated scales starting at |kymin|?
      (set auxiliary info: units, format, etc.)
*/
      po_image_labels[po_num_dep_vars]=clabel
      po_image_units[po_num_dep_vars]=cunits
      po_image_formats[po_num_dep_vars]=cformt
      do iy=kymin,ky
         jy=iy-kymin+1
         po_yscale[po_num_dep_vars][jy]=areal(iy)
         do ix=kxmin,kx
            jx=ix-kxmin+1
            po_xscale[po_num_dep_vars][jx]=areal(jx)
            po_image_data[po_num_dep_vars][jy][jx]=pb2dat[ix][iy]
         end do
      end do
@#endif      
      return
      end

@* INDEX.
