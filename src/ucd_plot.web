% $Id: f91865da21ef0b3294e96d13a1a2041d97ee7e86 $
\Title{ucd\_plot}

@* Create a SILO file for plotting using the polygon netCDF file. 
An unstructured (ucd) mesh is created from the |g2| class. 
This program is analogous to and 
in many ways similar to |geomtesta|.  The principal difference is that the area
(or volume) ``visualized'' with |geomtesta| is specified on input; 
in |ucd_plot|,
it is the entire problem, as described by the polygon netCDF file.  As such,
this program is only applicable to 2-D problems.  The big advantage of 
|ucd_plot| over |geomtesta| is that the output data in the SILO file are
effectively represented on the actual DEGAS2 grid, rather than 
an approximated, pixelated
representation.

The SILO library is required to run |ucd_plot|; there is no HDF4 counterpart.
Moreover, visualization of the resulting files has been performed only
with the VisIt package (see \href{https://wci.llnl.gov/codes/visit/home.html}{https://wci.llnl.gov/codes/visit/home.html}).  The particular method used by |ucd_plot| to 
build the unstructured mesh relies on a simplified representation
for the mesh that is not documented in the SILO library and may be
peculiar to VisIt.

The command line invoking |ucd_plot| is:

\begin{verbatim}
ucd_plot poly.nc file_list
\end{verbatim}
where |poly.nc| is the polygon netCDF file for the present
geometry as written by |definegeometry2d| is a mandatory
argument.  Note that only |definegeometry2d| presently generates
this file.  

Due to a problem with the VTK renderer, convex
polygons will not be handled correctly in VisIt.  In
particular, ``pseudocolor'' plots will have regions that
appear to be masked by the concave
polygons.  Two workarounds are available:
\begin{itemize}
  \item Use either |triangulate_polygon| or |triangulate_to_zones|
in |definegeometry2d| (as opposed to |breakup_polygon|); all
polygons will then be represented as triangles in the
polygon netCDF file.
  \item If the only convex polygons in your geometry are solid
zones, and they are the last zone(s) in the geometry, you can
enable the section of code below labeled ``Convex Polygon Hack''.
\end{itemize}
This is a known problem with VisIt / VTK and may be fixed at
some point.

The output of the routine is a SILO format file in the same
directory and with the same name as the run's primary output netCDF file, 
but with a
\verb+.silo+ extension instead of \verb+.nc+.

The second argument is optional and contains a list
of one or more text files with external data to be plotted.
Each of these text files can have keywords ``name'', ``format'' (as
in a Fortran output specification; not used here, though), ``units'' to provide
additional information on the data.  If provided the name will be
used to name the variable.  If not, the name will be
|ext_var_n| where |n| is the number of the file in the list of
external files.  All other lines in the file should be in the
form:
\begin{verbatim}
zone    data
\end{verbatim}
where |zone| is an integer between 1 and |zn_num| (inclusive) and
|data| is the (real) data value.  One way to generate such files
within DEGAS 2 would be to use |outputbrowser| to write out
zone based data (e.g., for a tally unique to the problem at hand)
to a file and then edit the file to these specifications.

Here is an explicit example:
\begin{verbatim}
name neu_ob
units m^-3
        1     8.57659E+14 
        2     6.70615E+14 
        3     7.16331E+14 
        4     6.29992E+14 
        5     5.83773E+14 
\end{verbatim}

This technique can also be used for time dependent data.  If one 
were looping through a sequence of time intervals, data from each
step could be stored in text files of this format.  In SILO mode, 
time dependent data should be stored in separate SILO files, one
per time step.  The convention used here is to append to
the variable ``name'' an integer designation for the time step
preceded by a \$ sign, e.g., \verb+density_$00100+ for the density
at time step 100.  The code will interpret the presence of
the \$ sign as indicating time dependent data and use the 
following integer in naming the SILO file. 

\ID{$Id: f91865da21ef0b3294e96d13a1a2041d97ee7e86 $}

@m FILE 'ucd_plot.web'

@I macros.hweb
@I string.hweb
@I sysdep.hweb
@I netcdf.hweb
@I readfilenames.hweb
@I geometry2d.hweb
@I zone.hweb
@I sector.hweb
@I species.hweb
@I background.hweb
@I problem.hweb
@I output.hweb
@I detector.hweb
@I mpi.hweb

@ The Main Program.

@a
      program ucd_plot

      implicit_none_f77
      mp_common
      implicit_none_f90
      mp_decls

      integer nargs,poly_nc_fileid,ext_file_unit
      character*FILELEN polygon_nc_file,ext_file_list

      @<Memory allocation interface@>
      sy_decls
      st_decls
      nc_decls

@#if MPI
      mpi_init
@#endif
      call readfilenames
      call degas_init
      call nc_read_output

      nargs=arg_count()
      if (nargs < 1) then
         assert('Command line must specify the name of the polygon netCDF file' == ' ')
      end if
      call command_arg(1,polygon_nc_file)

      poly_nc_fileid=ncopen(polygon_nc_file,NC_NOWRITE,nc_stat)
      if (nc_stat != 0) then
         assert('That polygon netCDF file cannot be opened!' == ' ')
      end if

      if (nargs == 2) then
         call command_arg(2,ext_file_list)
         ext_file_unit=diskin
         open(unit=ext_file_unit,file=ext_file_list,
     $        status='old',form='formatted')
      else
         ext_file_unit=int_unused
      end if

      call make_plots(poly_nc_fileid,ext_file_unit)

@#if MPI
      mpi_end
@#endif
      stop
      end

      @<Functions and Subroutines@>

@ Generate the SILO file and requisite data.

/*
   Remove characters causing file name problems
*/
@m name_clean(s,sp) sp=s;  
      ind_tmp=index(sp,'(');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='_';
      ind_tmp=index(sp,')');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='_';
      ind_tmp=index(sp,'|');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='_';
      ind_tmp=index(sp,'+');
      if (ind_tmp > 0) sp(ind_tmp:ind_tmp)='p' @;

@<Functions...@>=
      subroutine make_plots(poly_nc_fileid,ext_file_unit)

      define_dimen(ext_file_ind,n_ext_file)
      define_dimen(node_ind,num_nodes)
      define_dimen(poly_points_ind,num_poly_points)

      define_varp(polygon_data,FLOAT,g2_poly_ind)
      define_varp(zone_data,FLOAT,zone_ind)
      define_varp(ext_filenames,CHAR,filenames_size,ext_file_ind)
      define_varp(nodes,FLOAT,g2_xz_ind,node_ind)
      define_varp(node_x,FLOAT,node_ind)
      define_varp(node_z,FLOAT,node_ind)
      define_varp(boundary_nodes,INT,node_ind)
      define_varp(poly_pointlist,INT,poly_points_ind)

      implicit_none_f77
      sp_common
      pr_common
      tl_common
      ou_common
      bk_common
      zn_common
      de_common
      rf_common
      sc_common
      g2_common
      implicit_none_f90

      integer nargs,poly_nc_fileid,ipoly,zone,num_nodes,num_points,mesh_sense,
     $        i,j,this_node,sector,num_poly_points,i_this,dbfile,ret,ret2,
     $        nshapetypes,ndims,n_ext_file,ext_file_unit,length,beg,e,p,iview,
     $        test,back,ifile,itxt,open_stat,ind_tmp,iv,last_plasma_polygon,
     $        dbfile_td,inum,ifrag
      integer shapesize[1],shapecounts[1],shapetype[1],this_polygon[0:g2_num_points-1],
     $        index_parameters[tl_index_max]
      logical dbfile_td_open
      real max_v,ha_temp,density,ha_rate,pressure,halpha_tot,zone_frag
      character*FILELEN polygon_nc_file,silo_file,zonelist,mesh_name,ext_silo_file
      character*4 ivlab
      character*1 ind_sy[3]
      character*3 iflab
      character*3 vtag,auth
      character*tl_tag_length vname
      character*sp_sy_len clean_sy
      character*LINELEN line,ext_var_name,ext_var_units,ext_var_format
      data ind_sy /'1','2','3'/

      external extract_output_datum
      real extract_output_datum

      vc_decl(yhat)
      vc_decl(test_vec_1)
      vc_decl(test_vec_2)
      vc_decl(test_vec_3)
      vc_decl(node_vec)

      declare_varp(polygon_data)
      declare_varp(zone_data)
      declare_varp(ext_filenames)
      declare_varp(nodes)
      declare_varp(node_x)
      declare_varp(node_z)
      declare_varp(boundary_nodes)
      declare_varp(poly_pointlist)

      @<Memory allocation interface@>
      sy_decls
      vc_decls
      g2_ncdecl
      nc_decls
      st_decls
      tl_decls
      zn_decls

      include 'silo.inc'

      e=index(filenames_array[outputfile],'.nc')-1
      assert(e > 0)
      silo_file=filenames_array[outputfile]SP(:e)\/'_ucd.silo'
      ret=dbcreate(trim(silo_file),string_length(silo_file),
     $     DB_CLOBBER,DB_LOCAL,DB_F77NULL,0,silo_format,dbfile)
      assert((ret != -1) && (dbfile != -1))
      dbfile_td_open=.false.

      num_nodes=0
      num_poly_points=0
      var_alloc(nodes)
      var_alloc(boundary_nodes)
      var_alloc(poly_pointlist)
      var_alloc(zone_data)
/*
   Check the end of the file for additional (external) zone based
   data in text files.
*/
      n_ext_file=0
      var_alloc(ext_filenames)
      if (ext_file_unit != int_unused) then
loop: continue
         if (read_string(ext_file_unit,line,length)) then
            assert(length<=len(line))
            length=parse_string(line(:length))
            p=0
            assert(next_token(line,beg,e,p))
            n_ext_file++
            var_realloca(ext_filenames)
            ext_filenames[n_ext_file]=line(beg:e)
            go to loop
         end if
         close(unit=ext_file_unit)
      end if
/*
   Set up and write unstructured mesh to SILO file.
*/
      g2_ncread(poly_nc_fileid)
/*
   {\bf Convex Polygon Hack}
   As described in the preamble, if the only convex polygons in 
   your geometry are solid zones, and they are the last zone(s) 
   in the geometry, you can enable this section of code by
   changing \verb+if 0+ to \verb+if 1+ and recompiling
   the code.  This will skip the solid zones when creating the
   ucd mesh.
*/
@#if 1
      last_plasma_polygon=0
      do ipoly=1,g2_num_polygons
         zone=g2_polygon_zone[ipoly]
         if (last_plasma_polygon == 0) then
            if ((zn_type(zone) != zn_plasma) && (zn_type(zone) != zn_vacuum)) then
               last_plasma_polygon=ipoly-1
               assert(last_plasma_polygon > 0)
            end if
         else
            assert((zn_type(zone) != zn_plasma) && (zn_type(zone) != zn_vacuum))
         end if
      end do
      g2_num_polygons=last_plasma_polygon  // Reset for convenience 
@#endif
      var_alloc(polygon_data)

      vc_set(yhat,zero,one,zero)
      do ipoly=1,g2_num_polygons
/*
   Use the first two segments to determine the orientation of the
   zone.
*/
         vc_set(test_vec_1,g2_polygon_xz[ipoly][1][g2_x]
     $      -g2_polygon_xz[ipoly][0][g2_x],zero,
     $      g2_polygon_xz[ipoly][1][g2_z]-g2_polygon_xz[ipoly][0][g2_z])
         vc_set(test_vec_2,g2_polygon_xz[ipoly][2][g2_x]
     $        -g2_polygon_xz[ipoly][1][g2_x],zero,
     $        g2_polygon_xz[ipoly][2][g2_z]-g2_polygon_xz[ipoly][1][g2_z])
         vc_cross(test_vec_1,test_vec_2,test_vec_3)
         if (vc_product(test_vec_3,yhat) > zero) then
            mesh_sense=1    // clockwise
         else if(vc_product(test_vec_3,yhat) < zero) then
            mesh_sense=2    // counter-clockwise
         else
            assert('Mesh cell degenerate' == ' ')
         end if
/*
   One the tricks used in setting up meshes for XGC0 is to encode
   triangles into the Sonnet mesh by making the last two points
   the same.  Reduce the number of points in the polygon by one if 
   they are the same.
*/
         num_points=g2_polygon_points(ipoly)
         if ((g2_polygon_xz[ipoly][num_points-1][g2_x] == g2_polygon_xz[ipoly][num_points][g2_x])
     $     && (g2_polygon_xz[ipoly][num_points-1][g2_z] == g2_polygon_xz[ipoly][num_points][g2_z]))
     $        num_points=num_points-1
/*
   The convention in |definegeometry2d| is that the zero-th and n-th point
   are the same.  Hence, the range for this loop.
*/
         do i=0,num_points-1
            this_node=0
            if (num_nodes > 0) then
               do j=1,num_nodes
                  if ((nodes[j][g2_x] == g2_polygon_xz[ipoly][i][g2_x])
     $                 && (nodes[j][g2_z] == g2_polygon_xz[ipoly][i][g2_z]))
     $                 then
                     this_node=j
                  end if
               end do
            end if
            if (this_node == 0) then
               num_nodes++
               var_realloca(nodes)
               var_realloca(boundary_nodes)
               nodes[num_nodes][g2_x]=g2_polygon_xz[ipoly][i][g2_x]
               nodes[num_nodes][g2_z]=g2_polygon_xz[ipoly][i][g2_z]
/*
   Determine whether or not this node lies on a ``boundary''.  Since
   we have access to all of the geometry data, this amounts to searching
   through the wall, target, and exit sectors to see if it matches
   one of their points.
*/
               vc_set(node_vec,nodes[num_nodes][g2_x],zero,nodes[num_nodes][g2_z])           
               boundary_nodes[num_nodes]=0   // Not on boundary
               do sector=1,nsectors
                  if 
     $         (((sc_target_check(sector_type_pointer[sector][sc_target])) 
     $       || (sc_wall_check(sector_type_pointer[sector][sc_wall])) 
     $       || (sc_exit_check(sector_type_pointer[sector][sc_exit])))
     $       && ((vc_equal(node_vec,sector_points[sector][sc_neg]))
     $           || (vc_equal(node_vec,sector_points[sector][sc_pos])))) then
                        boundary_nodes[num_nodes]=1   // Is on boundary
                  end if
               end do
               this_node=num_nodes
            end if
            this_polygon[i]=this_node
         end do     // Over |i|
/*
   Add the nodes for |this_polygon| to the global list of
   points for all polygons.  Here we make use of SILO's UCD mesh
   feature in which we tell it that the polygons all have zero
   points and use the first entry in the points list to contain
   the number of points, hence the $+1$.
*/
         num_poly_points++
         var_realloca(poly_pointlist)
         poly_pointlist[num_poly_points]=num_points
         do i=0,num_points-1
            num_poly_points++
            var_realloca(poly_pointlist)
            if (mesh_sense == 1) then
               i_this=num_points-1-i    // Reverse clockwise polygons
            else
               i_this=i
            end if
            poly_pointlist[num_poly_points]=this_polygon[i_this]
         end do
      end do
      var_reallocb(nodes)
      var_reallocb(boundary_nodes)
      var_reallocb(poly_pointlist)

      nshapetypes=1
      ndims=2
      shapesize[1]=0
      shapecounts[1]=g2_num_polygons
      shapetype[1]=DB_ZONETYPE_POLYGON
      zonelist='polygon_zonelist'

      ret=dbputzl2(dbfile,trim(zonelist),string_length(zonelist),g2_num_polygons,
     $     ndims,poly_pointlist,num_poly_points,1,0,0,shapetype,shapesize,shapecounts,
     $     nshapetypes,DB_F77NULL,ret2)
      assert((ret != -1) && (ret2 != -1))
      mesh_name='polygon_mesh'
/*
   SILO expects the $x$, $y$, and $z$ coordinates of the nodes in separate arrays.
   For the moment at least, define these now from |nodes|.  Could later 
   replace it in all of the above with |node_x| and |node_z|.
*/
      var_alloc(node_x)
      var_alloc(node_z)
      do i=1,num_nodes
         node_x[i]=nodes[i][g2_x]
         node_z[i]=nodes[i][g2_z]
      end do
/*
   This is presently hardcoded for 2-D; may be able to do 3-D eventually.
*/
      ret=dbputum(dbfile,trim(mesh_name),string_length(mesh_name),ndims,node_x,
     $            node_z,DB_F77NULL,"x",1,"z",1,DB_F77NULLSTRING,0,silo_precision,
     $            num_nodes,g2_num_polygons,
     $            trim(zonelist),string_length(zonelist),DB_F77NULLSTRING,0,
     $            DB_F77NULL,ret2)
      assert((ret != -1) && (ret2 != -1))
/*
   START WRITING DATA.  PRESENTLY CRIBBED FROM GEOMTESTA.

   This is just Charles' original ``zone function''.  I believe the
   purpose was to use (most of) an 8-bit palette to color the
   zones with a minimum chance of color matching between adjacent
   zones (i.e., suspect that $97 / 252$ is related to the golden
   mean).
*/
      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         polygon_data[i]=areal(3+mod(97*zone,255-3))
      end do
      call write_silo_data('zone_function',polygon_data,' ','E11.3',dbfile,mesh_name)

      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         polygon_data[i]=areal(zone)
      end do
      call write_silo_data('zone_number',polygon_data,' ','E11.3',dbfile,mesh_name)

      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         polygon_data[i]=zn_volume(zone)
      end do
      call write_silo_data('zone_volume',polygon_data,'m**3','E11.3',dbfile,mesh_name)

      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         polygon_data[i]=areal(zn_type(zone))
      end do
      call write_silo_data('zone_type',polygon_data,' ','E11.3',dbfile,mesh_name)
@#if 1
      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         if (zn_type(zone) == zn_plasma) then
            polygon_data[i]=bk_n(1,zone)             // BACKGROUND DENSITY
         else
            polygon_data[i]=zero
         end if
      end do
      call write_silo_data('electron_density',polygon_data,'m**-3','E11.3',dbfile,mesh_name)

      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         if (zn_type(zone) == zn_plasma) then
            polygon_data[i]=bk_n(2,zone)             // BACKGROUND DENSITY
         else
            polygon_data[i]=zero
         end if
      end do
      call write_silo_data('ion_density',polygon_data,'m**-3','E11.3',dbfile,mesh_name)

      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         if (zn_type(zone) == zn_plasma) then         // BACKGROUND TEMPERATURE
            polygon_data[i]=bk_temp(1,zone)/electron_charge
         else
            polygon_data[i]=zero
         end if
      end do
      call write_silo_data('electron_temperature',polygon_data,'eV','E11.3',dbfile,mesh_name)

      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         if (zn_type(zone) == zn_plasma) then         // BACKGROUND TEMPERATURE
            polygon_data[i]=bk_temp(2,zone)/electron_charge
         else
            polygon_data[i]=zero
         end if
      end do
      call write_silo_data('ion_temperature',polygon_data,'eV','E11.3',dbfile,mesh_name)

      do j=1,3
         max_v=zero
         do i=1,g2_num_polygons
            zone=g2_polygon_zone[i]
            if (zn_type(zone) == zn_plasma) then         // ION VELOCITY
               polygon_data[i]=bk_v(2,zone)[j]
               max_v=max(max_v,abs(polygon_data[i]))
            else
               polygon_data[i]=zero
            end if
         end do
         if (max_v > zero) then
            call write_silo_data('ion_velocity_'\/ind_sy[j],polygon_data,
     $           'm/s','E11.3',dbfile,mesh_name)
         end if
      end do
@#endif
@#if 0                      // Plots of |de_zone_frags|
      do j=1,4
         if (j==1) then
            iview=1
            ivlab='1'
         else if (j==2) then
            iview=4
            ivlab='4'
         else if (j==3) then
            iview=6
            ivlab='6'
         else
            iview=9
            ivlab='9'
         end if
         do i=1,g2_num_polygons
            zone=g2_polygon_zone[i]
            if ((zn_type(zone) == zn_plasma || zn_type(zone) == zn_vacuum)
     $           && ((zone >= de_zone_frags_min_zn[iview])
     $           && (zone <= de_zone_frags_max_zn[iview]))) then
               assert(de_zone_frags_num[iview] > 0)
               zone_frag=zero
               do inum=1,de_zone_frags_num[iview]
                  ifrag=de_zone_frags_start[iview] + (inum-1)
                  if (zone == de_zone_frags_zones[ifrag]) then
                     zone_frag=de_zone_frags[ifrag]
                     go to break
                  end if
               end do
break:         continue  
               polygon_data[i]=zone_frag
            else
               polygon_data[i]=zero
            end if
         end do
         call write_silo_data('zone_frag_view_'\/trim(ivlab),polygon_data,
     $        ' ','E11.3',dbfile,mesh_name)
      end do
@#endif
@#if 1
      assert(output_old_file == TRUE)
      do j=2,pr_test_num
         index_parameters[tl_index_test]=j
         ha_temp=zero
         do i=1,g2_num_polygons
            zone=g2_polygon_zone[i]
            if (zn_type(zone) == zn_plasma || zn_type(zone) == zn_vacuum) then
               index_parameters[tl_index_zone]=zone
               density=extract_output_datum(index_parameters,1,
     $              out_post_all,o_mean,'neutral density')
               polygon_data[i]=density           // NEUTRAL DENSITY
               ha_temp+=density*zn_volume(zone)
            else
               polygon_data[i]=zero
            end if
         end do
         name_clean(sp_sy(pr_test(j)),clean_sy)
         call write_silo_data('sp'\/trim(clean_sy)\/'_density',polygon_data,
     $        'm**-3','E11.3',dbfile,mesh_name)

         do i=1,g2_num_polygons
            zone=g2_polygon_zone[i]
            if (zn_type(zone) == zn_plasma || zn_type(zone) == zn_vacuum) then
               index_parameters[tl_index_zone]=zone
               density=extract_output_datum(index_parameters,1,
     $              output_all,o_var,'neutral density')
               polygon_data[i]=density           // NEUTRAL DENSITY REL. STD. DEV.
            else
               polygon_data[i]=zero
            end if
         end do

         call write_silo_data('sp'\/trim(clean_sy)\/'_density_rsd',polygon_data,
     $        ' ','E11.3',dbfile,mesh_name)
/*
   Add corresponding dump of snapshot estimator version of neutral density; if present
   in time dependent case.
*/
         if (string_lookup('neutral density - snapshot',tally_name,tl_num) > 0) then
            ha_temp=zero
            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma || zn_type(zone) == zn_vacuum) then
                  index_parameters[tl_index_zone]=zone
                  density=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,'neutral density - snapshot')
                  polygon_data[i]=density           // SNAPSHOT NEUTRAL DENSITY
                  ha_temp+=density*zn_volume(zone)
               else
                  polygon_data[i]=zero
               end if
            end do
            name_clean(sp_sy(pr_test(j)),clean_sy)
            call write_silo_data('sp'\/trim(clean_sy)\/'_density_snap',polygon_data,
     $           'm**-3','E11.3',dbfile,mesh_name)

            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma || zn_type(zone) == zn_vacuum) then
                  index_parameters[tl_index_zone]=zone
                  density=extract_output_datum(index_parameters,1,
     $                 output_all,o_var,'neutral density - snapshot')
                  polygon_data[i]=density           // SNAPSHOT NEUTRAL DENSITY REL. STD. DEV.
               else
                  polygon_data[i]=zero
               end if
            end do

            call write_silo_data('sp'\/trim(clean_sy)\/'_density_snap_rsd',polygon_data,
     $           ' ','E11.3',dbfile,mesh_name)
         end if
/*
   End snapshot density.
*/
         if (tl_check(string_lookup('neutral velocity vector',tally_name,tl_num))) then
            vname='neutral velocity vector'
            vtag='vel'
         else 
            assert(tl_check(string_lookup('neutral flux vector',tally_name,tl_num)))
            vname='neutral flux vector'
            vtag='flx'
         end if
         do iv=1,3                                     // Component
            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma || zn_type(zone) == zn_vacuum) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,iv,
     $                 out_post_all,o_mean,trim(vname))
                  polygon_data[i]=ha_rate
               else
                  polygon_data[i]=zero
               end if
            end do
            call write_silo_data(trim(clean_sy)\/vtag\/ind_sy[iv],polygon_data,
     $           'm/s','E11.3',dbfile,mesh_name)
         end do

         if (string_lookup('neutral pressure',tally_name,tl_num) > 0) then
            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma || zn_type(zone) == zn_vacuum) then
                  index_parameters[tl_index_zone]=zone
                  pressure=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,'neutral pressure')
                  polygon_data[i]=pressure/const(1.3332,-1)  // NEUTRAL PRESSURE
               else
                  polygon_data[i]=zero
               end if
            end do
            call write_silo_data('sp'\/trim(clean_sy)\/'_pressure',polygon_data,
     $           'mTorr','E11.3',dbfile,mesh_name)
         end if

      end do
@#endif
@#if 0
/*
   This is provisional. Could just test for the presence of the tally
   and leave this in here permanently.
*/
      j=2                                // Usually the atom species
      index_parameters[tl_index_test]=j
      do k=1,so_type_num+pr_reaction_num+pr_pmi_num
         index_parameters[tl_index_test_author]=k
         ha_temp=zero
         do i=1,g2_num_polygons
            zone=g2_polygon_zone[i]
            if (zn_type(zone) == zn_plasma || zn_type(zone) == zn_vacuum) then
               index_parameters[tl_index_zone]=zone
               density=extract_output_datum(index_parameters,1,
     $              out_post_all,o_mean,'neutral density by author')
               polygon_data[i]=density               // NEUTRAL DENSITY BY AUTHOR
               ha_temp+=density*zn_volume(zone)
            else
               polygon_data[i]=zero
            end if
         end do
         if (ha_temp > zero) then
            write(auth,'(a1,i2.2)') 'a',k
            call write_silo_data('sp'\/trim(sp_sy(pr_test(j)))\/'_density '\/auth,
     $           polygon_data,'m**-3','E11.3',dbfile,mesh_name)
         end if
      end do

@#endif
@#if 1
      do i=1,g2_num_polygons
         polygon_data[i]=zero
      end do

      do test=1,pr_test_num
         if (((sp_sy(pr_test(test)) == 'H')                  // NEUTRAL H-ALPHA
     $        || (sp_sy(pr_test(test)) == 'D')
     $        || (sp_sy(pr_test(test)) == 'T'))
     $        && string_lookup(trim(sp_sy(pr_test(test)))\/'alpha emission rate',tally_name,tl_num) > 0) then
            ha_temp=zero
            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 trim(sp_sy(pr_test(test)))\/'alpha emission rate')
     $                 /(const(1.8881944)*electron_charge)
                  polygon_data[i]+=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
@#if 0
               else if (zn_type(zone) == zn_solid) then  // Can plot solid
                  polygon_data[i]=-one                    // regions 
@#endif
               else
                  polygon_data[i]=zero
               end if
            end do
         end if
      end do

      halpha_tot=zero
      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         halpha_tot+=polygon_data[i]*zn_volume(zone)
      end do

      if (halpha_tot > zero) then
         call write_silo_data('H_alpha_rate',polygon_data,
     $        'photons / (m**3 s)','E11.3',dbfile,mesh_name)
      end if

      do i=1,g2_num_polygons
         polygon_data[i]=zero
      end do

      do test=1,pr_test_num
         if (string_lookup('Dalpha emission rate by species',tally_name,tl_num) > 0) then
            name_clean(sp_sy(pr_test(test)),clean_sy)
            ha_temp=zero
            index_parameters[tl_index_test]=test
            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'Dalpha emission rate by species')
     $                 /(const(1.8881944)*electron_charge)
                  polygon_data[i]=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
               else
                  polygon_data[i]=zero
               end if
            end do
         end if
         halpha_tot=zero
         do i=1,g2_num_polygons
            zone=g2_polygon_zone[i]
            halpha_tot+=polygon_data[i]*zn_volume(zone)
         end do

         if (halpha_tot > zero) then
            call write_silo_data('H_alpha_rate_'\/trim(clean_sy),polygon_data,
     $        'photons / (m**3 s)','E11.3',dbfile,mesh_name)
         end if
      end do
@#endif
@#if 1
      do i=1,g2_num_polygons
         polygon_data[i]=zero
      end do

      do test=1,pr_test_num
         if (((sp_sy(pr_test(test)) == 'H')                  // NEUTRAL H BALMER BETA
     $        || (sp_sy(pr_test(test)) == 'D')
     $        || (sp_sy(pr_test(test)) == 'T'))
     $        && string_lookup('D beta emission rate',tally_name,tl_num) > 0) then
            ha_temp=zero
            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'D beta emission rate')
     $                 /(const(2.549)*electron_charge)
                  polygon_data[i]+=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
@#if 0
               else if (zn_type(zone) == zn_solid) then  // Can plot solid
                  polygon_data[i]=-one                    // regions 
@#endif
               else
                  polygon_data[i]=zero
               end if
            end do
         end if
      end do

      halpha_tot=zero
      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         halpha_tot+=polygon_data[i]*zn_volume(zone)
      end do

      if (halpha_tot > zero) then
         call write_silo_data('Balmer_beta_rate',polygon_data,
     $        'photons / (m**3 s)','E11.3',dbfile,mesh_name)
      end if

      do i=1,g2_num_polygons
         polygon_data[i]=zero
      end do

      do test=1,pr_test_num
         if (string_lookup('D beta emission rate by species',tally_name,tl_num) > 0) then
            name_clean(sp_sy(pr_test(test)),clean_sy)
            ha_temp=zero
            index_parameters[tl_index_test]=test
            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'D beta emission rate by species')
     $                 /(const(2.549)*electron_charge)
                  polygon_data[i]=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
               else
                  polygon_data[i]=zero
               end if
            end do
         end if
         halpha_tot=zero
         do i=1,g2_num_polygons
            zone=g2_polygon_zone[i]
            halpha_tot+=polygon_data[i]*zn_volume(zone)
         end do

         if (halpha_tot > zero) then
            call write_silo_data('Balmer_beta_rate_'\/trim(clean_sy),polygon_data,
     $        'photons / (m**3 s)','E11.3',dbfile,mesh_name)
         end if
      end do
@#endif
@#if 1
      do i=1,g2_num_polygons
         polygon_data[i]=zero
      end do

      do test=1,pr_test_num
         if (((sp_sy(pr_test(test)) == 'He')          // NEUTRAL He 5877 line
     $        && string_lookup('He 5877 emission rate',tally_name,tl_num) > 0)) then
            ha_temp=zero
            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,
     $                 'He 5877 emission rate')
     $                 /(const(2.109566)*electron_charge)
                  polygon_data[i]+=ha_rate
                  ha_temp+=ha_rate*zn_volume(zone)
@#if 0
               else if (zn_type(zone) == zn_solid) then  // Can plot solid
                  polygon_data[i]=-one                    // regions 
@#endif
               else
                  polygon_data[i]=zero
               end if
            end do
         end if
      end do

      halpha_tot=zero
      do i=1,g2_num_polygons
         zone=g2_polygon_zone[i]
         halpha_tot+=polygon_data[i]*zn_volume(zone)
      end do

      if (halpha_tot > zero) then
         call write_silo_data('He_5877_rate',polygon_data,
     $        'photons / (m**3 s)','E11.3',dbfile,mesh_name)
      end if
@#endif

      if ((pr_reaction_num > 0) 
     $     && (string_lookup('ion source rate',tally_name,tl_num) > 0)) then
         do back=1,pr_background_num
            name_clean(sp_sy(pr_background(back)),clean_sy)
            if (trim(clean_sy) != 'e') then     // ION SOURCE RATE
               index_parameters[tl_index_problem_sp]=pr_problem_sp_back(back)
               ha_temp=zero
               do i=1,g2_num_polygons
                  zone=g2_polygon_zone[i]
                  if (zn_type(zone) == zn_plasma) then
                     index_parameters[tl_index_zone]=zone
                     ha_rate=extract_output_datum(index_parameters,1,
     $                    out_post_all,o_mean,'ion source rate')
                     polygon_data[i]=ha_rate/zn_volume(zone)
                     ha_temp+=ha_rate
                  else
                     polygon_data[i]=zero
                  end if
               end do
               call write_silo_data(trim(clean_sy)\/'_Ion_Source_rate',polygon_data,
     $              'm**-3 s**-1','E11.3',dbfile,mesh_name)

               do i=1,g2_num_polygons
                  zone=g2_polygon_zone[i]
                  if (zn_type(zone) == zn_plasma) then
                     index_parameters[tl_index_zone]=zone
                     ha_rate=extract_output_datum(index_parameters,1,
     $                    output_all,o_var,'ion source rate')
                     polygon_data[i]=ha_rate
                  else
                     polygon_data[i]=zero
                  end if
               end do
               call write_silo_data(trim(clean_sy)\/'_Ion_Source_rate_rsd',polygon_data,
     $              ' ','E11.3',dbfile,mesh_name)

            end if
         end do

         do back=1,pr_background_num
            name_clean(sp_sy(pr_background(back)),clean_sy)
            if (trim(clean_sy) != 'e') then     // MOM. SOURCE RATE
               index_parameters[tl_index_problem_sp]=pr_problem_sp_back(back)
               do iv=1,3                                     // Component
                  ha_temp=zero
                  do i=1,g2_num_polygons
                     zone=g2_polygon_zone[i]
                     if (zn_type(zone) == zn_plasma) then
                        index_parameters[tl_index_zone]=zone
                        ha_rate=extract_output_datum(index_parameters,iv,
     $                       out_post_all,o_mean,'ion momentum source vector')
                        polygon_data[i]=ha_rate/zn_volume(zone)
                        ha_temp+=ha_rate
                     else
                        polygon_data[i]=zero
                     end if
                  end do
                  call write_silo_data(trim(clean_sy)\/'_Mom_'\/ind_sy[iv]\/'_Source_rate',
     $                 polygon_data,'N m**-3','E11.3',dbfile,mesh_name)
               end do

               do iv=1,3                                     // Component
                  do i=1,g2_num_polygons
                     zone=g2_polygon_zone[i]
                     if (zn_type(zone) == zn_plasma) then
                        index_parameters[tl_index_zone]=zone
                        ha_rate=extract_output_datum(index_parameters,iv,
     $                       output_all,o_var,'ion momentum source vector')
                        polygon_data[i]=ha_rate
                     else
                        polygon_data[i]=zero
                     end if
                  end do
                  call write_silo_data(trim(clean_sy)\/'_Mom_'\/ind_sy[iv]\/'_Source_rate_rsd',
     $                 polygon_data,' ','E11.3',dbfile,mesh_name)
               end do
            end if
         end do

         do back=1,pr_background_num                  // ENERGY SOURCE RATE
            name_clean(sp_sy(pr_background(back)),clean_sy)
            index_parameters[tl_index_problem_sp]=pr_problem_sp_back(back)
            ha_temp=zero
            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 out_post_all,o_mean,'ion energy source')
                  polygon_data[i]=ha_rate/zn_volume(zone)
                  ha_temp+=ha_rate
               else
                  polygon_data[i]=zero
               end if
            end do
            call write_silo_data(trim(clean_sy)\/'_Energy_Source_rate',polygon_data,
     $           'W m**-3','E11.3',dbfile,mesh_name)

            do i=1,g2_num_polygons
               zone=g2_polygon_zone[i]
               if (zn_type(zone) == zn_plasma) then
                  index_parameters[tl_index_zone]=zone
                  ha_rate=extract_output_datum(index_parameters,1,
     $                 output_all,o_var,'ion energy source')
                  polygon_data[i]=ha_rate
               else
                  polygon_data[i]=zero
               end if
            end do
            call write_silo_data(trim(clean_sy)\/'_Energy_Source_rate_rsd',polygon_data,
     $           ' ','E11.3',dbfile,mesh_name)
         end do

      end if
/*
  Read in and plot external zone-based data.
*/
      if (n_ext_file > 0) then
         do ifile=1,n_ext_file
            do i=1,zn_num
               zone_data[i]=zero
            end do
            open(unit=diskin,file=ext_filenames[ifile],
     $           status='old',form='formatted',iostat=open_stat)
            if (open_stat == 0) then
               assert(ifile < 1000)
               write(iflab,'(i3.3)') ifile
               ext_var_name='ext_var'\/iflab
               ext_var_units=' '
               ext_var_format='E11.3'
loop2: continue
               if (read_string(diskin,line,length)) then
                  assert(length<=len(line))
                  length=parse_string(line(:length))
                  p=0
                  assert(next_token(line,beg,e,p))
                  if (line(beg:e) == 'name') then
                     assert(next_token(line,beg,e,p))
                     ext_var_name=line(beg:e)
                  else if (line(beg:e) == 'units') then
                     assert(next_token(line,beg,e,p))
                     ext_var_units=line(beg:e)
                  else if (line(beg:e) == 'format') then
                     assert(next_token(line,beg,e,p))
                     ext_var_format=line(beg:e)
                  else
                     zone=read_int_soft_fail(line(beg:e))
                     if (zn_check(zone)) then
                        assert(next_token(line,beg,e,p))
                        zone_data[zone]=read_real(line(beg:e))
                     else
                        write(stderr,*) 'Improper zone number ',zone,
     $                       ' in external file ',ext_filenames[ifile]
                     end if
                  end if
                  go to loop2
               end if
               close(unit=diskin)
               do i=1,g2_num_polygons
                  zone=g2_polygon_zone[i]
                  polygon_data[i]=zone_data[zone]
               end do
               i=index(ext_var_name,'$')
               if (i > 0) then
                  if (dbfile_td_open) then
                     ret=dbclose(dbfile_td)
                     dbfile_td_open=.false.   // Not sure if I need this
                     assert(ret != -1)
                  end if
                  itxt=index(ext_filenames[ifile],'.txt')
                  ext_silo_file=ext_filenames[ifile]SP(:itxt)\/'silo'
                  ret=dbcreate(trim(ext_silo_file),string_length(ext_silo_file),
     $                 DB_CLOBBER,DB_LOCAL,DB_F77NULL,0,silo_format,dbfile_td)
                  assert((ret != -1) && (dbfile_td != -1))
                  dbfile_td_open=.true.
/*
   Write zone list and mesh to this file.
*/
                  ret=dbputzl2(dbfile_td,trim(zonelist),string_length(zonelist),g2_num_polygons,
     $                   ndims,poly_pointlist,num_poly_points,1,0,0,shapetype,shapesize,shapecounts,
     $                   nshapetypes,DB_F77NULL,ret2)
                  assert((ret != -1) && (ret2 != -1))
                  ret=dbputum(dbfile_td,trim(mesh_name),string_length(mesh_name),ndims,node_x,
     $                   node_z,DB_F77NULL,"x",1,"z",1,DB_F77NULLSTRING,0,silo_precision,
     $                   num_nodes,g2_num_polygons,
     $                   trim(zonelist),string_length(zonelist),DB_F77NULLSTRING,0,
     $                   DB_F77NULL,ret2)
                  assert((ret != -1) && (ret2 != -1))

                  call write_silo_data(trim(ext_var_name),polygon_data,
     $                 trim(ext_var_units),trim(ext_var_format),dbfile_td,mesh_name)
               else
                  call write_silo_data(trim(ext_var_name),polygon_data,
     $                 trim(ext_var_units),trim(ext_var_format),dbfile,mesh_name)
               end if
            else
               write (stderr,*) 'Cannot open external file ',
     $              ext_filenames[ifile],', error number ',open_stat
            end if
         end do
      end if

      ret=dbclose(dbfile)
      assert(ret != -1)
      if (dbfile_td_open) then
         ret=dbclose(dbfile_td)
         assert(ret != -1)
      end if
      var_free(nodes)
      var_free(node_x)
      var_free(node_z)
      var_free(boundary_nodes)
      var_free(poly_pointlist)
      var_free(polygon_data)
      var_free(zone_data)

      return
      end

@ Write data to the SILO file. 

@<Functions...@>=
      subroutine write_silo_data(var_name,polygon_data,cunits,cformt,dbfile,mesh_name)
      implicit_none_f77
      g2_common
      implicit_none_f90

      integer dbfile                                     // Input
      character*(*) var_name,cunits,cformt,mesh_name  
      real polygon_data[g2_num_polygons]

      real time_slice
      integer ret,ret2,var_opts,time_ind
      st_decls
      include 'silo.inc'

      ret=dbmkoptlist(1,var_opts)
      assert(ret != -1)
      if (len(cunits) > 0) then
         ret=dbaddcopt(var_opts,DBOPT_UNITS,cunits,len(cunits))
         assert(ret != -1)
      end if
      time_ind=index(var_name,'$')
      if (time_ind > 0) then
         time_slice=areal(read_integer(var_name(time_ind+1:)))
         ret=dbadddopt(var_opts,DBOPT_DTIME,time_slice)
         assert(ret != -1)
         var_name=var_name(:time_ind-1)
      end if
      ret=dbputuv1(dbfile,trim(var_name),string_length(var_name),
     $     trim(mesh_name),string_length(mesh_name),
     $     polygon_data,g2_num_polygons,DB_F77NULL,0,silo_precision,
     $     DB_ZONECENT,var_opts,ret2)
      assert((ret != -1) && (ret2 != -1))

      return
      end

@* INDEX.






