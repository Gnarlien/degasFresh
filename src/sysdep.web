% $Id: cecfc688e7eccc14a9c3c0a9bb3e28ba257bd283 $
\Title{system dependent routines}

@* Introduction.

\ID{$Id: cecfc688e7eccc14a9c3c0a9bb3e28ba257bd283 $}

System dependent routines for degas.

@m FILE 'sysdep.web'

@I macros.hweb
@I string.hweb

@ The unnamed module.

@#if SUN || SGI
@m CHARPOINTERBUG 1
@#else
@m CHARPOINTERBUG 0
@#endif

@#if IBM
@m FORTRANNAME(x) x
@#else
@m FORTRANNAME(x) x##_
@#endif

@a
      @<Functions and Subroutines@>
@#if IBM || LINUX || LINUX64 || MACOSX
@c
#include <stdio.h>
#include <strings.h>
#include <time.h>
#include <sys/time.h>
      @<C Functions@>
@#endif

@* Handling floating point errors.

This is from \verb&f77/f77_floatingpoint.h&.
@m SIGFPE_DEFAULT  %val(0)      // default exception handling
@m SIGFPE_IGNORE   %val(1)      // ignore exception
@m SIGFPE_ABORT    %val(2)      // abort on exception

@<Functions...@>=
@#if SUN && FORTRAN77
      subroutine float_abort
      integer ieeer             // Local
      integer ieee_handler     // External
      ieeer = ieee_handler( 'set', 'common', SIGFPE_ABORT )
      return
      end
@#endif

@ Get value of environmental variable.

@<Functions...@>=
@#if !IBM
      function get_env(var,val)
      implicit_none_f77
@#if (LINUX || LINUX64 || MACOSX) && NAGWARE
      use f90_unix
@#endif
      implicit_none_f90
      logical get_env           // Function
      character*(*) var         // Input
      character*(*) val         // Output
@#if CRAY
      integer length,ierr
@#endif

@#if CRAY
      call pxfgetenv(var,0,val,length,ierr)
      get_env= ierr == 0
@#else
      call getenv(var,val)
      get_env = val != ' '
@#endif
      return
      end
@#endif

@ C-wrapper routine for IBM.

@<C Functions@>=
@#if IBM
int FORTRANNAME(get_env)(var,val,var_len,val_len)
     char *var,*val;
     int var_len,val_len;
{
  char *var_a,*val_a;
  int i;

  var_a = (char *)malloc(var_len + 1);
  strncpy(var_a,var,var_len);
  var_a[var_len] = '\0';

  val_a = (char *)getenv(var_a);
  free(var_a);

  if (val_a == (char *)NULL)
    return FALSE;
  else {
    strncpy(val,val_a,val_len);
    FORTRANNAME(string_pad)(val,val_len);
    return TRUE;
  }
}

@#endif

@* Return date and time.  Returned elements are year, month,
day, minutes east of Greenwich, hour, minute, second, milliseconds.
@<Functions...@>=
@#if HP
@?nostandard system
@#endif
@#if FORTRAN90 || SUN || ALPHA  || ( (LINUX || LINUX64 || MACOSX) && INTEL )
      subroutine date_time(date_array)
      implicit_none_f77
      implicit_none_f90
      integer date_array[8]     // Output
      character*10 c(3)          // Local
      call date_and_time(c(1),c(2),c(3),date_array)
      return
      end
@#else
@#if !IBM
      subroutine date_time(date_array)
      implicit_none_f77
      integer date_array[8]     // Output
@#if CRAY || HP
      character*8 temp          // Local
@#else
      integer itemp[3]          // Local
@#endif
@#if ALPHA
      external idate
@#endif

/* Unknown zone and millisecs */
      date_array[4]=0
      date_array[8]=0
@#if CRAY
      call date(temp)
      read(temp,'(i2,1x,i2,1x,i2)')
     $     date_array[2],date_array[3],date_array[1]
      if (date_array[1]>90) then
         date_array[1]=date_array[1]+1900
      else
         date_array[1]=date_array[1]+2000
      end if
      call clock(temp)
      read(temp,'(i2,1x,i2,1x,i2)')
     $     date_array[5],date_array[6],date_array[7]
@#elif HP
      call idate(date_array[2],date_array[3],date_array[1])
      if (date_array[1]>90) then
         date_array[1]=date_array[1]+1900
      else
         date_array[1]=date_array[1]+2000
      end if
      call time(temp)
      read(temp,'(i2,1x,i2,1x,i2)')
     $     date_array[5],date_array[6],date_array[7]
@#elif SGI || ( (LINUX || LINUX64 ||MACOSX) && PGROUP )
      call idate(date_array[2],date_array[3],date_array[1])
      if (date_array[1]>90) then
         date_array[1]=date_array[1]+1900
      else
         date_array[1]=date_array[1]+2000
      end if
      call itime(date_array[5])
@#else
      call idate(itemp)
      date_array[1]=itemp[3]
      date_array[2]=itemp[2]
      date_array[3]=itemp[1]
      call itime(date_array[5])
@#endif

      return
      end
@#endif
@#endif

@ C function for time for IBM

@<C Functions@>=
@#if IBM
void
date_time(date_array)
     int *date_array;
{
  struct timeval *tp;
  struct tm *time;
  int s;

  tp=(struct timeval*)malloc(sizeof tp);
  s=gettimeofday(tp,NULL);
  time=localtime(&tp->tv_sec);
  free(tp);

  date_array[0] = time->tm_year+1900;
  date_array[1] = time->tm_mon+1;
  date_array[2] = time->tm_mday;
  date_array[3] = time->tm_hour;
  date_array[4] = time->tm_min;
  date_array[5] = time->tm_sec;

  return;
}

@#endif

@ Return wall clock time as the number of seconds since 00:00, January 1,
2000.  Use the standard rule for the Gregorian calendar---leap years every
multiple of 4, unless it's a multiple of 100 and not a muliple of 400.
Arithmetic is simplified by moving January and February to the previous
year.  The pattern of month lengths from March thru January is regular with
a 5-month period---31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31.  The 5-month
period is 153 days long.

@<Functions...@>=
      function wall_time(time)
      implicit_none_f77
      implicit_none_f90
      real wall_time         // Function
      integer time[8]
      integer y,m,d     // Local

      call date_time(time)
      y=time[1]+int((time[2]+9)/12)-1 // Move January and February to previous year
      m=mod(time[2]+9,12)             // March is now month 0
      d=365*y+int(y/4)-int(y/100)+int(y/400)+int((m+4)*153/5)+time[3]-730548 // January 1, 2000 is day 0
      wall_time=60*(60*(24*areal(d)+time[5])+time[6]-time[4])+time[7]+const(0.001)*time[8]

      return
      end

@ Return string representation of the date and time using ISO 8601 format:
YYYY-MM-DD hh-mm-ss.sss +ZZ:ZZ

@<Functions...@>=
      subroutine date_string(time,string)
      implicit_none_f77
      implicit_none_f90
      character*(*) string
      character*(30) temp
      integer time[8]
      
      write(temp,
     $     '(ss,i4.4,a1,i2.2,a1,i2.2,
     $     a1,i2.2,a1,i2.2,a1,i2.2,a1,i3.3,
     $     a1,sp,i3.2,ss,a1,i2.2)')
     $     time[1],'-',time[2],'-',time[3],
     $     ' ',time[5],':',time[6],':',time[7],'.',time[8],
     $     ' ',int(time[4]/60),':',abs(time[4]-int(time[4]/60)*60)
      
      string=temp

      return
      end

@ Return elapsed CPU time.

@<Functions...@>=
      function cpu_time()
      implicit_none_f77
      implicit_none_f90
      real cpu_time             // Function
@#if FORTRAN90
      integer count,rate
      call system_clock(count,rate)
      cpu_time=real(count)/real(max(1,rate))
@#else
@#if HP || IBM || ( (LINUX || LINUX64 || MACOSX) && NAGWARE )
      integer clock             // External
@#elif (LINUX || LINUX64 || MACOSX) && PGROUP
      integer mclock            // External
@#elif CRAY
      real second               // External
@#else
      single_precision tarray[2] // Local
      single_precision etime    // External
@#endif

@#if HP || IBM || ( (LINUX || LINUX64 || MACOSX) && NAGWARE)
      cpu_time=const(1.0,-6)*areal(clock())
@#elif (LINUX || LINUX64 || MACOSX) && PGROUP
      cpu_time=const(1.0,-2)*areal(mclock())
@#elif CRAY
      cpu_time=second()
@#else
      cpu_time=areal(etime(tarray))
@#endif
@#endif
      return
      end

@ Interface for |clock| for Linux.

@<C Functions@>=
@#if (LINUX || LINUX64 || MACOSX) && NAGWARE
int FORTRANNAME(clock)()
{
      return clock();
}
@#endif
      
@* Various system information.  Return process ID.

@<Functions...@>=
      function get_pid()
      implicit_none_f77
@#if (LINUX || LINUX64 || MACOSX) && NAGWARE
      use f90_unix
@#endif
      implicit_none_f90
      integer get_pid           // Function
@#if !( (LINUX || LINUX64 || MACOSX) && NAGWARE )
      integer getpid           // External
@#endif

      get_pid=getpid()

      return
      end

@ Return current working directory.

@<Functions...@>=
      subroutine get_cwd(cwd)
      implicit_none_f77
      implicit_none_f90
      character*(*) cwd         // Output
      integer getcwd            // External

@#if CRAY
      if (getcwd(cwd) <= 0) cwd='UNKNOWN'
@#elif SGI || HP || IBM
      if (getcwd(cwd) == 0) then
         cwd='UNKNOWN'
      else
         call string_pad(cwd)
      end if
@#else
      if (getcwd(cwd) != 0) cwd='UNKNOWN'
@#endif
      if (cwd == ' ') cwd='UNKNOWN'

      return
      end

@ Linux interface to getcwd
@<C Functions@>=
@#if (LINUX || LINUX64 || MACOSX) && NAGWARE
int FORTRANNAME(getcwd)(name,len)
char * name;
int len;
{
      if (getcwd(name,len))
         return(0);
      else
         return(1);
}
@#endif

@ Set working directory.  Returns |.true.| if successful.

@<Functions...@>=
      function set_cwd(dir)
      implicit_none_f77
      implicit_none_f90
      logical set_cwd
      character*(*) dir         // Input
      integer chdir             // External
@#if CRAY
      integer ierr
@#endif

@#if CRAY
      call pxfchdir(dir,0,ierr)
      set_cwd = ierr == 0
@#else
      set_cwd = chdir(dir) == 0
@#endif

      return
      end

@ Linux interface to chdir
@<C Functions@>=
@#if (LINUX || LINUX64 || MACOSX) && NAGWARE
int FORTRANNAME(chdir)(name,len)
char *name;
int len;
{
      char *namea;
      namea=(char *)malloc(len+1);
      strncpy(namea,name,len);
      namea[len]='\0';
      return chdir(namea);
}
@#endif

@ Get user name.

@<Functions...@>=
      subroutine user_name(user)
      implicit_none_f77
      implicit_none_f90
      character*(*) user       // Output
      logical get_env          // External
      external get_env

      if (!get_env('LOGNAME',user)) then
         if (!get_env('USER',user)) then
            user='UNKNOWN'
         end if
      end if

      return
      end

@ Return host name.

@#if HP || IBM
  @m hostnm gethostname
@#endif

@<Functions...@>=
      subroutine host_name(host)
      implicit_none_f77
      implicit_none_f90
      character*(*) host         // Output
@#if CRAY
      character dummy[4]        // Local
      integer junam, ierr, ilen, stat
@#else
      integer hostnm           // External
@#endif

@#if CRAY
      stat=0
      call pxfstructcreate('utsname',junam,ierr)
      stat=+abs(ierr)
      call pxfuname(junam,ierr)
      stat=+abs(ierr)
      ilen=0
      call pxfstrget(junam,'nodename',host,ilen,ierr)
      stat=+abs(ierr)
      call pxfstructfree(junam,ierr)
      if (stat!=0) host='UNKNOWN'
@#else
      if (hostnm(host) != 0) host='UNKNOWN'
@#if HP || IBM
      call string_pad(host)
@#endif
@#endif
      if (host==' ') host='UNKNOWN'

      return
      end

@ Linux interface to gethostname.
@<C Functions@>=
@#if (LINUX || LINUX64 || MACOSX) && NAGWARE
int FORTRANNAME(hostnm)(name,len)
char * name;
int len;
{
      return gethostname(name,len);
}
@#endif


@* Get command line arguments.  Return argument count in |arg_count()|.

@<Functions...@>=
      function arg_count()
      implicit_none_f77
@#if (LINUX || LINUX64 || MACOSX) && NAGWARE
      use f90_unix
@#endif
      implicit_none_f90
      integer arg_count         // Function
@#if CRAY
      external ipxfargc
      integer ipxfargc
@#else
@#if !( (LINUX || LINUX64 || MACOSX) && NAGWARE )
      integer iargc             // External
@#endif
@#endif

@#if CRAY
      arg_count=ipxfargc()
@#else
      arg_count=iargc()
@#endif
      return
      end

@ Return $i$th argument in |call command_arg(i,arg)|.

@<Functions...@>=
      subroutine command_arg(i,arg)
      implicit_none_f77
@#if (LINUX || LINUX64 || MACOSX) && NAGWARE
      use f90_unix
@#endif
      implicit_none_f90
      integer i                 // Input
      character*(*) arg         // Output
      integer j            // Local
@#if CRAY
      integer len,ierr
@#endif

      j=i
@#if HP
      call igetarg(j,arg,len(arg))
@#elif CRAY
      call pxfgetarg(j,arg,len,ierr)
@#else
      call getarg(j,arg)
@#endif

      return
      end

@* Memory allocation.  Allocate memory (Fortran 77 versions).

@#if CRAY
  @m mem_unit 1
@#else
  @m mem_unit 8
@#endif

@<Functions...@>=
@#if FORTRAN77
      function mem_alloc(size)
      implicit_none_f77
      address mem_alloc         // Function
      integer size              // Input
      integer*8 sizea             // Local
      real data
      pointer (ptr,data(*))
@#if DEBUG
      integer*8 i
@#endif
@#if !CRAY
      address malloc           // External
@#else
      integer stat              // Local
@#endif

      assert(size >= 0)

      if (size == 0) then
         mem_alloc=0
         return
      end if

@#if DEBUG
      sizea=size+2
@#else
      sizea=size
@#endif

@#if !CRAY
@#if IBM
      ptr=malloc(%val(mem_unit*sizea))
@#else
      ptr=malloc(mem_unit*sizea)
@#endif
      assert(ptr != 0)
@#else
      call hpalloc(ptr,mem_unit*sizea,stat,0)
      assert(stat == 0)
@#endif

@#if DEBUG
      do i=1,sizea
         data(i)=real_uninit
      end do

      mem_alloc=ptr+mem_unit
@#else
      mem_alloc=ptr
@#endif

      return
      end
@#endif /* FORTRAN77 */

@ Reallocate memory.

@<Functions...@>=
@#if FORTRAN77
      function mem_realloc(oldptr,oldsize,newsize)
      implicit_none_f77
      address mem_realloc       // Function
      address oldptr            // Input
      integer oldsize,newsize
      integer*8 newsizea,oldsizea // Local
      real odata,ndata
      pointer (optr,odata(*)),(nptr,ndata(*))
@#if DEBUG || !CRAY
      integer*8 i
@#endif
@#if !CRAY
      address malloc            // External
@#else
      integer stat              // Local
@#endif
      external mem_alloc        // External
      address mem_alloc

      assert(oldsize >=0 && newsize > 0)

      if (oldsize == 0) then
         mem_realloc = mem_alloc(newsize)
         return
      end if

@#if DEBUG
      optr=oldptr-mem_unit
      newsizea=newsize+2
      oldsizea=oldsize+2
      assert(odata(1) == real_uninit && odata(oldsizea) == real_uninit)
@#else
      optr=oldptr
      newsizea=newsize
      oldsizea=oldsize
@#endif

      if (oldsize == newsize) then
         mem_realloc=oldptr
         return
      end if

@#if !CRAY
@#if IBM
      nptr=malloc(%val(mem_unit*newsizea))
@#else
      nptr=malloc(mem_unit*newsizea)
@#endif
      if (nptr == 0) then
         print*,"memrealloc failed:",mem_unit*oldsizea,mem_unit*newsizea
      end if
      assert(nptr != 0)

      do i=1,min(newsizea,oldsizea)
         ndata(i)=odata(i)
      end do
      call free(optr)
@#else
      call hpclmove(optr,mem_unit*newsizea,stat,0)
      assert(stat == 0 || stat == 1)
      nptr = optr
@#endif

@#if DEBUG
      do i=min(newsizea,oldsizea),newsizea
         ndata(i)=real_uninit
      end do

      mem_realloc=nptr+mem_unit
@#else
      mem_realloc=nptr
@#endif

      return
      end
@#endif /* FORTRAN77 */

@ Free memory

@<Functions...@>=
@#if FORTRAN77
      subroutine mem_free(oldptr,size)
      implicit_none_f77
      address oldptr       // Input
      integer size
      integer*8 sizea             // Local
      real data
      pointer (optr,data(*))
@#if CRAY
      integer stat              // Local
@#endif

      assert(size >= 0)
      if (size == 0) return

@#if DEBUG
      optr=oldptr-mem_unit
      sizea = size + 2
      assert(data(1) == real_uninit && data(sizea) == real_uninit)
@#else
      optr=oldptr
      sizea = size
@#endif

@#if !CRAY
      call free(optr)
@#else
      call hpdeallc(optr,stat,0)
      assert(stat == 0)
@#endif

      return
      end
@#endif /* FORTRAN77 */

@* Fortran 90 memory allocation routines.  In Fortran 90 we need a
separate call for each type and rank of data.  So the basic routines are
named |mem_alloc|, |mem_realloc|, |mem_free|, with |_TYPE&RANK|, (e.g.,
|_r2| appended).  We can't conveniently implement guard cells (since we
can't do pointer arithmetic).

@#if FORTRAN90
@m array_num 300
@m mem_name_size 40
@m mem_common character(len=mem_name_size) mem_array_name(array_num);
      integer mem_array_bound(array_num);
      common/mem_common_c/ mem_array_name;
      common/mem_common_i/ mem_array_bound;
      save/mem_common_c/;
      save/mem_common_i/ @;
@#endif

@<Functions...@>=
@#if FORTRAN90
      block data mem_common_data
      mem_common
      data mem_array_name/array_num*' '/
      end
@#endif

@ Here are the routines to allocate memory.

@<Functions...@>=
@#if FORTRAN90
      function mem_alloc_c1(size,l1,u1,name) result(p)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1
      character(len=size), dimension(:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      assert(size > 0)
      if (u1 == l1-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1)
      assert(mem_alloc_check(name,u1))
      allocate(p(l1:u1))
@#if DEBUG
      p=char_uninit
@#endif
      return
      end function

      function mem_alloc_c2(size,l1,u1,l2,u2,name) result(p)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,l2,u2
      character(len=size), dimension(:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      assert(size > 0)
      if (u2 == l2-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2)
      assert(mem_alloc_check(name,u2))
      allocate(p(l1:u1,l2:u2))
@#if DEBUG
      p=char_uninit
@#endif
      return
      end function

      function mem_alloc_c3(size,l1,u1,l2,u2,l3,u3,name) result(p)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,l2,u2,l3,u3
      character(len=size), dimension(:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      assert(size > 0)
      if (u3 == l3-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2 && l3 <= u3)
      assert(mem_alloc_check(name,u3))
      allocate(p(l1:u1,l2:u2,l3:u3))
@#if DEBUG
      p=char_uninit
@#endif
      return
      end function

      function mem_alloc_c4(size,l1,u1,l2,u2,l3,u3,l4,u4,name) result(p)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,l2,u2,l3,u3,l4,u4
      character(len=size), dimension(:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      assert(size > 0)
      if (u4 == l4-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2 && l3 <= u3 && l4 <= u4)
      assert(mem_alloc_check(name,u4))
      allocate(p(l1:u1,l2:u2,l3:u3,l4:u4))
@#if DEBUG
      p=char_uninit
@#endif
      return
      end function

      function mem_alloc_i1(l1,u1,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1
      integer, dimension(:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u1 == l1-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1)
      assert(mem_alloc_check(name,u1))
      allocate(p(l1:u1))
@#if DEBUG
      p=int_uninit
@#endif
      return
      end function

      function mem_alloc_i2(l1,u1,l2,u2,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2
      integer, dimension(:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u2 == l2-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2)
      assert(mem_alloc_check(name,u2))
      allocate(p(l1:u1,l2:u2))
@#if DEBUG
      p=int_uninit
@#endif
      return
      end function

      function mem_alloc_i3(l1,u1,l2,u2,l3,u3,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3
      integer, dimension(:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u3 == l3-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2 && l3 <= u3)
      assert(mem_alloc_check(name,u3))
      allocate(p(l1:u1,l2:u2,l3:u3))
@#if DEBUG
      p=int_uninit
@#endif
      return
      end function

      function mem_alloc_i4(l1,u1,l2,u2,l3,u3,l4,u4,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4
      integer, dimension(:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u4 == l4-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2 && l3 <= u3 && l4 <= u4)
      assert(mem_alloc_check(name,u4))
      allocate(p(l1:u1,l2:u2,l3:u3,l4:u4))
@#if DEBUG
      p=int_uninit
@#endif
      return
      end function

      function mem_alloc_i5(l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,l5,u5
      integer, dimension(:,:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u5 == l5-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2 && l3 <= u3 && l4 <= u4 && l5 <= u5)
      assert(mem_alloc_check(name,u5))
      allocate(p(l1:u1,l2:u2,l3:u3,l4:u4,l5:u5))
@#if DEBUG
      p=int_uninit
@#endif
      return
      end function

      function mem_alloc_r1(l1,u1,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1
      real, dimension(:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u1 == l1-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1)
      assert(mem_alloc_check(name,u1))
      allocate(p(l1:u1))
@#if DEBUG
      p=real_uninit
@#endif
      return
      end function

      function mem_alloc_r2(l1,u1,l2,u2,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2
      real, dimension(:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u2 == l2-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2)
      assert(mem_alloc_check(name,u2))
      allocate(p(l1:u1,l2:u2))
@#if DEBUG
      p=real_uninit
@#endif
      return
      end function

      function mem_alloc_r3(l1,u1,l2,u2,l3,u3,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3
      real, dimension(:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u3 == l3-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2 && l3 <= u3)
      assert(mem_alloc_check(name,u3))
      allocate(p(l1:u1,l2:u2,l3:u3))
@#if DEBUG
      p=real_uninit
@#endif
      return
      end function

      function mem_alloc_r4(l1,u1,l2,u2,l3,u3,l4,u4,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4
      real, dimension(:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u4 == l4-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2 && l3 <= u3 && l4 <= u4)
      assert(mem_alloc_check(name,u4))
      allocate(p(l1:u1,l2:u2,l3:u3,l4:u4))
@#if DEBUG
      p=real_uninit
@#endif
      return
      end function

      function mem_alloc_r5(l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,name) result(p)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,l5,u5
      real, dimension(:,:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_alloc_check
      external mem_alloc_check
      mem_common

      if (u5 == l5-1) then
         nullify(p)
         return
      end if
      assert(l1 <= u1 && l2 <= u2 && l3 <= u3 && l4 <= u4 && l5 <= u5)
      assert(mem_alloc_check(name,u5))
      allocate(p(l1:u1,l2:u2,l3:u3,l4:u4,l5:u5))
@#if DEBUG
      p=real_uninit
@#endif
      return
      end function
@#endif /* FORTRAN90 */

@ Fortran 90 memory reallocation.

@<Functions...@>=
@#if FORTRAN90
      function mem_realloc_c1(p,size,l1,u1,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,nu
      character(len=size), dimension(:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
@#if CHARPOINTERBUG
      logical mem_alloc_check
      external mem_alloc_check
@#endif
      mem_common

      interface

         function mem_alloc_c1(size,l1,u1,name) result(p)
         implicit_none_f90
         integer, intent(in) :: size,l1,u1
         character(len=size), dimension(:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l1 <= nu )
@#if !CHARPOINTERBUG
      if (u1 == l1-1) then
         np ASSIGN mem_alloc_c1(size,l1,nu,name)
         return
      end if
@#endif
@#if CHARPOINTERBUG
      if (u1 >= l1) then
@#endif
      assert( lbound(p,1)==l1 && ubound(p,1)==u1 )
@#if CHARPOINTERBUG
      endif
@#endif

@#if CHARPOINTERBUG
      if (u1 == l1-1) then
         assert(mem_alloc_check(name,nu))
      else
@#endif
         assert(mem_realloc_check(name,u1,nu))
@#if CHARPOINTERBUG
      endif
@#endif
      if (u1 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:nu))
@#if DEBUG
      np = char_uninit
@#endif
@#if CHARPOINTERBUG
      if (u1 >= l1) then
@#endif
      np(:min(u1,nu)) = p(:min(u1,nu))
      deallocate(p)
@#if CHARPOINTERBUG
      endif
@#endif

      return
      end function

      function mem_realloc_c2(p,size,l1,u1,l2,u2,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,l2,u2,nu
      character(len=size), dimension(:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
@#if CHARPOINTERBUG
      logical mem_alloc_check
      external mem_alloc_check
@#endif
      mem_common

      interface

         function mem_alloc_c2(size,l1,u1,l2,u2,name) result(p)
         implicit_none_f90
         integer, intent(in) :: size,l1,u1,l2,u2
         character(len=size), dimension(:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l2 <= nu )
@#if !CHARPOINTERBUG
      if (u2 == l2-1) then
         np ASSIGN mem_alloc_c2(size,l1,u1,l2,nu,name)
         return
      end if
@#endif
@#if CHARPOINTERBUG
      if (u1 >= l1) then
@#endif
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2 )
@#if CHARPOINTERBUG
      endif
@#endif

@#if CHARPOINTERBUG
      if (u2 == l2-1) then
         assert(mem_alloc_check(name,nu))
      else
@#endif
         assert(mem_realloc_check(name,u2,nu))
@#if CHARPOINTERBUG
      endif
@#endif
      if (u2 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:nu))
@#if DEBUG
      np = char_uninit
@#endif
@#if CHARPOINTERBUG
      if (u1 >= l1) then
@#endif
      np(:,:min(u2,nu)) = p(:,:min(u2,nu))
      deallocate(p)
@#if CHARPOINTERBUG
      endif
@#endif

      return
      end function

      function mem_realloc_c3(p,size,l1,u1,l2,u2,l3,u3,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,l2,u2,l3,u3,nu
      character(len=size), dimension(:,:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
@#if CHARPOINTERBUG
      logical mem_alloc_check
      external mem_alloc_check
@#endif
      mem_common

      interface

         function mem_alloc_c3(size,l1,u1,l2,u2,l3,u3,name) result(p)
         implicit_none_f90
         integer, intent(in) :: size,l1,u1,l2,u2,l3,u3
         character(len=size), dimension(:,:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l3 <= nu )
@#if !CHARPOINTERBUG
      if (u3 == l3-1) then
         np ASSIGN mem_alloc_c3(size,l1,u1,l2,u2,l3,nu,name)
         return
      end if
@#endif
@#if CHARPOINTERBUG
      if (u1 >= l1) then
@#endif
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3 )
@#if CHARPOINTERBUG
      endif
@#endif

@#if CHARPOINTERBUG
      if (u3 == l3-1) then
         assert(mem_alloc_check(name,nu))
      else
@#endif
         assert(mem_realloc_check(name,u3,nu))
@#if CHARPOINTERBUG
      endif
@#endif
      if (u3 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:u2,l3:nu))
@#if DEBUG
      np = char_uninit
@#endif
@#if CHARPOINTERBUG
      if (u1 >= l1) then
@#endif
      np(:,:,:min(u3,nu)) = p(:,:,:min(u3,nu))
      deallocate(p)
@#if CHARPOINTERBUG
      endif
@#endif

      return
      end function

      function mem_realloc_c4(p,size,l1,u1,l2,u2,l3,u3,l4,u4,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,l2,u2,l3,u3,l4,u4,nu
      character(len=size), dimension(:,:,:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
@#if CHARPOINTERBUG
      logical mem_alloc_check
      external mem_alloc_check
@#endif
      mem_common

      interface

         function mem_alloc_c4(size,l1,u1,l2,u2,l3,u3,l4,u4,name) result(p)
         implicit_none_f90
         integer, intent(in) :: size,l1,u1,l2,u2,l3,u3,l4,u4
         character(len=size), dimension(:,:,:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l4 <= nu )
@#if !CHARPOINTERBUG
      if (u4 == l4-1) then
         np ASSIGN mem_alloc_c4(size,l1,u1,l2,u2,l3,u3,l4,nu,name)
         return
      end if
@#endif
@#if CHARPOINTERBUG
      if (u1 >= l1) then
@#endif
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4 )
@#if CHARPOINTERBUG
      endif
@#endif

@#if CHARPOINTERBUG
      if (u4 == l4-1) then
         assert(mem_alloc_check(name,nu))
      else
@#endif
         assert(mem_realloc_check(name,u4,nu))
@#if CHARPOINTERBUG
      endif
@#endif
      if (u4 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:u2,l3:u3,l4:nu))
@#if DEBUG
      np = char_uninit
@#endif
@#if CHARPOINTERBUG
      if (u1 >= l1) then
@#endif
      np(:,:,:,:min(u4,nu)) = p(:,:,:,:min(u4,nu))
      deallocate(p)
@#if CHARPOINTERBUG
      endif
@#endif

      return
      end function

      function mem_realloc_i1(p,l1,u1,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,nu
      integer, dimension(:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_i1(l1,u1,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1
         integer, dimension(:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l1 <= nu )
      if (u1 == l1-1) then
         np ASSIGN mem_alloc_i1(l1,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1 )

      assert(mem_realloc_check(name,u1,nu))
      if (u1 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:nu))
@#if DEBUG
      np = int_uninit
@#endif
      np(:min(u1,nu)) = p(:min(u1,nu))
      deallocate(p)

      return
      end function

      function mem_realloc_i2(p,l1,u1,l2,u2,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,nu
      integer, dimension(:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_i2(l1,u1,l2,u2,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1,l2,u2
         integer, dimension(:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l2 <= nu )
      if (u2 == l2-1) then
         np ASSIGN mem_alloc_i2(l1,u1,l2,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2 )

      assert(mem_realloc_check(name,u2,nu))
      if (u2 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:nu))
@#if DEBUG
      np = int_uninit
@#endif
      np(:,:min(u2,nu)) = p(:,:min(u2,nu))
      deallocate(p)

      return
      end function

      function mem_realloc_i3(p,l1,u1,l2,u2,l3,u3,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,nu
      integer, dimension(:,:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_i3(l1,u1,l2,u2,l3,u3,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1,l2,u2,l3,u3
         integer, dimension(:,:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l3 <= nu )
      if (u3 == l3-1) then
         np ASSIGN mem_alloc_i3(l1,u1,l2,u2,l3,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3 )

      assert(mem_realloc_check(name,u3,nu))
      if (u3 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:u2,l3:nu))
@#if DEBUG
      np = int_uninit
@#endif
      np(:,:,:min(u3,nu)) = p(:,:,:min(u3,nu))
      deallocate(p)

      return
      end function

      function mem_realloc_i4(p,l1,u1,l2,u2,l3,u3,l4,u4,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,nu
      integer, dimension(:,:,:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_i4(l1,u1,l2,u2,l3,u3,l4,u4,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4
         integer, dimension(:,:,:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l4 <= nu )
      if (u4 == l4-1) then
         np ASSIGN mem_alloc_i4(l1,u1,l2,u2,l3,u3,l4,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4 )

      assert(mem_realloc_check(name,u4,nu))
      if (u4 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:u2,l3:u3,l4:nu))
@#if DEBUG
      np = int_uninit
@#endif
      np(:,:,:,:min(u4,nu)) = p(:,:,:,:min(u4,nu))
      deallocate(p)

      return
      end function

      function mem_realloc_i5(p,l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,nu
      integer, dimension(:,:,:,:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_i5(l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,l5,u5
         integer, dimension(:,:,:,:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l5 <= nu )
      if (u5 == l5-1) then
         np ASSIGN mem_alloc_i5(l1,u1,l2,u2,l3,u3,l4,u4,l5,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4
     $     && lbound(p,5)==l5 && ubound(p,5)==u5 )

      assert(mem_realloc_check(name,u5,nu))
      if (u5 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:u2,l3:u3,l4:u4,l5:nu))
@#if DEBUG
      np = int_uninit
@#endif
      np(:,:,:,:,:min(u5,nu)) = p(:,:,:,:,:min(u5,nu))
      deallocate(p)

      return
      end function

      function mem_realloc_r1(p,l1,u1,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,nu
      real, dimension(:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_r1(l1,u1,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1
         real, dimension(:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l1 <= nu )
      if (u1 == l1-1) then
         np ASSIGN mem_alloc_r1(l1,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1 )

      assert(mem_realloc_check(name,u1,nu))
      if (u1 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:nu))
@#if DEBUG
      np = real_uninit
@#endif
      np(:min(u1,nu)) = p(:min(u1,nu))
      deallocate(p)

      return
      end function

      function mem_realloc_r2(p,l1,u1,l2,u2,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,nu
      real, dimension(:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_r2(l1,u1,l2,u2,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1,l2,u2
         real, dimension(:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l2 <= nu )
      if (u2 == l2-1) then
         np ASSIGN mem_alloc_r2(l1,u1,l2,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2 )

      assert(mem_realloc_check(name,u2,nu))
      if (u2 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:nu))
@#if DEBUG
      np = real_uninit
@#endif
      np(:,:min(u2,nu)) = p(:,:min(u2,nu))
      deallocate(p)

      return
      end function

      function mem_realloc_r3(p,l1,u1,l2,u2,l3,u3,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,nu
      real, dimension(:,:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_r3(l1,u1,l2,u2,l3,u3,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1,l2,u2,l3,u3
         real, dimension(:,:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l3 <= nu )
      if (u3 == l3-1) then
         np ASSIGN mem_alloc_r3(l1,u1,l2,u2,l3,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3 )

      assert(mem_realloc_check(name,u3,nu))
      if (u3 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:u2,l3:nu))
@#if DEBUG
      np = real_uninit
@#endif
      np(:,:,:min(u3,nu)) = p(:,:,:min(u3,nu))
      deallocate(p)

      return
      end function

      function mem_realloc_r4(p,l1,u1,l2,u2,l3,u3,l4,u4,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,nu
      real, dimension(:,:,:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_r4(l1,u1,l2,u2,l3,u3,l4,u4,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4
         real, dimension(:,:,:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l4 <= nu )
      if (u4 == l4-1) then
         np ASSIGN mem_alloc_r4(l1,u1,l2,u2,l3,u3,l4,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4 )

      assert(mem_realloc_check(name,u4,nu))
      if (u4 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:u2,l3:u3,l4:nu))
@#if DEBUG
      np = real_uninit
@#endif
      np(:,:,:,:min(u4,nu)) = p(:,:,:,:min(u4,nu))
      deallocate(p)

      return
      end function

      function mem_realloc_r5(p,l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,nu,name) result(np)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,nu
      real, dimension(:,:,:,:,:), pointer :: p,np
      character(len=*), intent(in) :: name
      logical mem_realloc_check
      external mem_realloc_check
      mem_common

      interface

         function mem_alloc_r5(l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,name) result(p)
         implicit_none_f90
         integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,l5,u5
         real, dimension(:,:,:,:,:), pointer :: p
         character(len=*), intent(in) :: name
         end function

      end interface

      assert( l5 <= nu )
      if (u5 == l5-1) then
         np ASSIGN mem_alloc_r5(l1,u1,l2,u2,l3,u3,l4,u4,l5,nu,name)
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4
     $     && lbound(p,5)==l5 && ubound(p,5)==u5 )

      assert(mem_realloc_check(name,u5,nu))
      if (u5 == nu) then
         np ASSIGN p
         return
      end if

      allocate(np(l1:u1,l2:u2,l3:u3,l4:u4,l5:nu))
@#if DEBUG
      np = real_uninit
@#endif
      np(:,:,:,:,:min(u5,nu)) = p(:,:,:,:,:min(u5,nu))
      deallocate(p)

      return
      end function

@#endif /* FORTRAN90 */

@ Memory deallocation, Fortran 90 version

@<Functions...@>=
@#if FORTRAN90
      subroutine mem_free_c1(p,size,l1,u1,name)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1
      character(len=size), dimension(:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u1 == l1-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1 )
      
      assert(mem_free_check(name,u1))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_c2(p,size,l1,u1,l2,u2,name)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,l2,u2
      character(len=size), dimension(:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u2 == l2-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2 )
      
      assert(mem_free_check(name,u2))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_c3(p,size,l1,u1,l2,u2,l3,u3,name)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,l2,u2,l3,u3
      character(len=size), dimension(:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u3 == l3-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3 )
      
      assert(mem_free_check(name,u3))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_c4(p,size,l1,u1,l2,u2,l3,u3,l4,u4,name)
      implicit_none_f90
      integer, intent(in) :: size,l1,u1,l2,u2,l3,u3,l4,u4
      character(len=size), dimension(:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u4 == l4-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4 )
      
      assert(mem_free_check(name,u4))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_i1(p,l1,u1,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1
      integer, dimension(:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u1 == l1-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1 )
      
      assert(mem_free_check(name,u1))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_i2(p,l1,u1,l2,u2,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2
      integer, dimension(:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u2 == l2-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2 )
      
      assert(mem_free_check(name,u2))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_i3(p,l1,u1,l2,u2,l3,u3,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3
      integer, dimension(:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u3 == l3-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3 )
      
      assert(mem_free_check(name,u3))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_i4(p,l1,u1,l2,u2,l3,u3,l4,u4,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4
      integer, dimension(:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u4 == l4-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4 )
      
      assert(mem_free_check(name,u4))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_i5(p,l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,l5,u5
      integer, dimension(:,:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u5 == l5-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4
     $     && lbound(p,5)==l5 && ubound(p,5)==u5 )
      
      assert(mem_free_check(name,u5))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_r1(p,l1,u1,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1
      real, dimension(:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u1 == l1-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1 )
      
      assert(mem_free_check(name,u1))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_r2(p,l1,u1,l2,u2,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2
      real, dimension(:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u2 == l2-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2 )
      
      assert(mem_free_check(name,u2))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_r3(p,l1,u1,l2,u2,l3,u3,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3
      real, dimension(:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u3 == l3-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3 )
      
      assert(mem_free_check(name,u3))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_r4(p,l1,u1,l2,u2,l3,u3,l4,u4,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4
      real, dimension(:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u4 == l4-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4 )
      
      assert(mem_free_check(name,u4))

      deallocate(p)
      return
      end subroutine

      subroutine mem_free_r5(p,l1,u1,l2,u2,l3,u3,l4,u4,l5,u5,name)
      implicit_none_f90
      integer, intent(in) :: l1,u1,l2,u2,l3,u3,l4,u4,l5,u5
      real, dimension(:,:,:,:,:), pointer :: p
      character(len=*), intent(in) :: name
      logical mem_free_check
      external mem_free_check
      mem_common

      if (u5 == l5-1) then
         return
      end if
      assert( lbound(p,1)==l1 && ubound(p,1)==u1
     $     && lbound(p,2)==l2 && ubound(p,2)==u2
     $     && lbound(p,3)==l3 && ubound(p,3)==u3
     $     && lbound(p,4)==l4 && ubound(p,4)==u4
     $     && lbound(p,5)==l5 && ubound(p,5)==u5 )
      
      assert(mem_free_check(name,u5))

      deallocate(p)
      return
      end subroutine
@#endif /* FORTRAN90 */

@* Routines for registering memory allocation requests.  This is a
pretty idiotic implementation, whose chief purpose is merely to catch
memory leaks.

@<Functions...@>=
@#if FORTRAN90
      function mem_alloc_check(name,bound)
      implicit_none_f90
      logical mem_alloc_check
      integer, intent(in) :: bound
      character(len=*), intent(in) :: name
      character(len=mem_name_size) :: namex
      mem_common
      integer :: i,empty

      namex=name
      if (namex==' ') then
         mem_alloc_check=.true.
         return
      end if

      empty=0
      mem_alloc_check=.false.

      do i=1,array_num
         if (mem_array_name[i]==' ') then
            if (empty==0) empty=i
         else if (namex==mem_array_name[i]) then
            return
         end if
      end do

      if (empty==0) return

      mem_array_name[empty]=namex
      mem_array_bound[empty]=bound
      mem_alloc_check=.true.

      return
      end

      function mem_realloc_check(name,bound,nbound)
      implicit_none_f90
      logical mem_realloc_check
      integer, intent(in) :: bound,nbound
      character(len=*), intent(in) :: name
      character(len=mem_name_size) :: namex
      mem_common
      integer :: i

      namex=name
      if (namex==' ') then
         mem_realloc_check=.true.
         return
      end if

      mem_realloc_check=.false.

      do i=1,array_num
         if (namex==mem_array_name[i]) then
            if (bound==mem_array_bound[i]) then
               mem_array_bound[i]=nbound
               mem_realloc_check=.true.
               return
            end if
            return
         end if
      end do

      return
      end

      function mem_free_check(name,bound)
      implicit_none_f90
      logical mem_free_check
      integer, intent(in) :: bound
      character(len=*), intent(in) :: name
      character(len=mem_name_size) :: namex
      mem_common
      integer :: i

      namex=name
      if (namex==' ') then
         mem_free_check=.true.
         return
      end if

      mem_free_check=.false.

      do i=1,array_num
         if (namex==mem_array_name[i]) then
            if (bound==mem_array_bound[i]) then
               mem_array_name[i]=' '
               mem_free_check=.true.
               return
            end if
            return
         end if
      end do

      return
      end

      subroutine mem_check
      implicit_none_f90
      mem_common
      integer :: i,count
      
      write(stdout,*) 'Arrays allocated:'
      count=0
      do i=1,array_num
         if (mem_array_name[i]!=' ') then
            write(stdout,*) mem_array_name[i],mem_array_bound[i]
            count++
         end if
      end do
      write(stdout,*) 'Total number: ',count
      return
      end
@#else
      subroutine mem_check
      implicit_none_f77
      return
      end
@#endif

@* Error handling.

@<Functions...@>=
      subroutine error_exit(message)
      implicit_none_f77
      implicit_none_f90
      character*(*) message
      character*LINELEN response

      st_decls

      write(stderr,*) message
/*
   The following is intended to mimic the Sun implementation of the
   |pause| command that has been declared obsolescent under F90.
*/
      write(stderr,*) 'To resume execution, type:   go'
      write(stderr,*) 'Any other input will terminate the program.'
      read(stdin,'(a)') response
      if (trim(response) != 'go') stop

      return
      end

@* INDEX.
