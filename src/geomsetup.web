% $Id: 0bc41d1726999b94cda0cbaebe656ddbbb697783 $

\Title{geometry setup}


@* Introduction.

\ID{$Id: 0bc41d1726999b94cda0cbaebe656ddbbb697783 $}

Geometry setup routines for degas.

@m FILE 'geomsetup.web'

@I macros.hweb

@I geomint.hweb
@I readfilenames.hweb
@I zone.hweb
@I sysdep.hweb
@I netcdf.hweb
@I sector.hweb
@I detector.hweb
@I allocate.hweb
@I location.hweb

@ The unnamed module.

@a
      @<Functions and Subroutines@>

@* Initialize data structures for geometry.  |nboundaries|,
|ptr_boundaries|, |nneighbors|, and |ptr_neighbors| are left
uninitialized; these are set in |boundaries_neighbors|.

@m mem_delta 10
@m mem_frag(x) ((((x)+mem_delta-1)/mem_delta)*mem_delta)
@m surf_list(x) memory[ptr_surf_list+(x)-1]
@m cell_list(x) memory[ptr_cell_list+(x)-1]
@m sector_list(x) memory[ptr_sector_list+(x)-1]

@<Functions...@>=
      subroutine init_geometry
      implicit_none_f77
      gi_common                 // Output
      zn_common
      sc_common
      de_common
      al_common
      implicit_none_f90
      @<Memory allocation interface@>
      al_decls
      integer i,j

      ncells=0
      var_realloca(cells)
      cells[c_start,0]=0
      cells[c_faces,0]=0
      cells[c_surfaces,0]=0
      cells[c_zone,0]=0

      nsurfaces=0
      nsectors=0
      ntransforms=0

      var_realloca(surface_sectors)
      var_realloca(surfaces_tx_mx)
      
      do j=1,4
         do i=1,3
            surfaces_tx_mx[ntransforms][i,j]=real_unused
         end do
      end do

      var_realloca(strata)
      var_realloca(sector_strata_segment)
      var_realloca(sector_zone)
      var_realloca(sector_surface)
      var_realloca(sector_points)
      var_realloca(sector_type_pointer)

      strata[nsectors]=int_unused
      sector_strata_segment[nsectors]=int_unused
// |sectors| hasn't been allocated yet and isn't used until |end_sectors|
@#if 0
      sectors[nsectors]=int_unused   
@#endif
      sector_zone[nsectors]=int_unused
      sector_surface[nsectors]=int_unused
      vc_set(sector_points[nsectors][sc_neg],real_unused,real_unused,real_unused)
      vc_set(sector_points[nsectors][sc_pos],real_unused,real_unused,real_unused)
      do i=1,sc_type_max
         sector_type_pointer[nsectors][i]=int_undef
      end do

      sc_vacuum_num=0
      var_realloca(vacuum_sector)
      vacuum_sector[sc_vacuum_num]=int_unused
      
      sc_plasma_num=0
      var_realloca(plasma_sector)
      plasma_sector[sc_plasma_num]=int_unused

      sc_target_num=0
      var_realloca(target_sector)
      target_sector[sc_target_num]=int_unused
      var_realloca(target_material)
      target_material[sc_target_num]=int_unused
      var_realloca(target_temperature)
      target_temperature[sc_target_num]=real_unused
      var_realloca(target_recyc_coef)
      target_recyc_coef[sc_target_num]=real_unused

      sc_wall_num=0
      var_realloca(wall_sector)
      wall_sector[sc_wall_num]=int_unused
      var_realloca(wall_material)
      wall_material[sc_wall_num]=int_unused
      var_realloca(wall_temperature)
      wall_temperature[sc_wall_num]=real_unused
      var_realloca(wall_recyc_coef)
      wall_recyc_coef[sc_wall_num]=real_unused

      sc_exit_num=0
      var_realloca(exit_sector)
      exit_sector[sc_exit_num]=int_unused
@#if 0
      var_realloca(exit_albedo)
      exit_albedo[sc_exit_num]=real_unused
@#endif

      sc_diagnostic_grps=0
      var_realloca(diagnostic_grp_name)
      diagnostic_grp_name[sc_diagnostic_grps]=char_unused
      var_realloca(diagnostic_num_sectors)
      diagnostic_num_sectors[sc_diagnostic_grps]=int_unused
      var_realloca(diagnostic_var)
      diagnostic_var[sc_diagnostic_grps]=int_unused
      var_realloca(diagnostic_tab_index)
      diagnostic_tab_index[sc_diagnostic_grps]=int_unused
      var_realloca(diagnostic_min)
      diagnostic_min[sc_diagnostic_grps]=real_unused
      var_realloca(diagnostic_delta)
      diagnostic_delta[sc_diagnostic_grps]=real_unused
      var_realloca(diagnostic_spacing)
      diagnostic_spacing[sc_diagnostic_grps]=int_unused
      var_realloca(diagnostic_grp_base)
      diagnostic_grp_base[sc_diagnostic_grps]=int_unused

      de_grps=0
      var_realloca(detector_name)
      detector_name[de_grps]=char_unused
      var_realloca(detector_num_views)
      detector_num_views[de_grps]=int_unused
      var_realloca(detector_var)
      detector_var[de_grps]=int_unused
      var_realloca(detector_tab_index)
      detector_tab_index[de_grps]=int_unused
      var_realloca(detector_min)
      detector_min[de_grps]=real_unused
      var_realloca(detector_delta)
      detector_delta[de_grps]=real_unused
      var_realloca(detector_spacing)
      detector_spacing[de_grps]=int_unused
      var_realloca(de_view_base)
      de_view_base[de_grps]=int_unused
      
      zn_num=0
      $DO(I,1,zn_type_max) {
          zone_type_num[I]=0;
      }
      
      call init_mem

      return
      end

@ Define universal cell.

@<Functions...@>=
      subroutine universal_cell(symmetry,min_corner,max_corner,vol)
      implicit_none_f77
      gi_common
      implicit_none_f90
      integer symmetry          // Input
      real min_corner[3],max_corner[3]
      real vol                  // Output
      integer face,face1,face2,surf_type,i // Local
      real y,cos_y,sin_y
      real x[3,0:4],apex[3],a[3],b[3],x0[3],x1[3],x2[3],x3[3],
     $     coeff[NCOEFFS],tx[3,4]
      gi_ext
      external vector_compare
      integer vector_compare

      geometry_symmetry=symmetry
      if (symmetry==geometry_symmetry_none) return

      assert(symmetry==geometry_symmetry_plane ||
     $     symmetry==geometry_symmetry_oned ||
     $     symmetry==geometry_symmetry_cylindrical ||
     $     symmetry==geometry_symmetry_plane_hw ||
     $     symmetry==geometry_symmetry_cyl_hw ||
     $     symmetry==geometry_symmetry_cyl_section)
      
      $DO(I,1,3) {
         assert(min_corner[I] < max_corner[I]);
      }
      vc_copy(min_corner,universal_cell_min)
      vc_copy(max_corner,universal_cell_max)

      i=0
      x[1,i]=min_corner[1]; x[2,i]=zero; x[3,i]=min_corner[3]; i++
      x[1,i]=min_corner[1]; x[2,i]=zero; x[3,i]=max_corner[3]; i++
      x[1,i]=max_corner[1]; x[2,i]=zero; x[3,i]=max_corner[3]; i++
      x[1,i]=max_corner[1]; x[2,i]=zero; x[3,i]=min_corner[3]; i++
      vc_copy(x[0],x[i])

      if (symmetry==geometry_symmetry_cylindrical || 
     $     symmetry==geometry_symmetry_cyl_hw || 
     $     symmetry==geometry_symmetry_cyl_section) then
         if (symmetry==geometry_symmetry_cylindrical || 
     $        symmetry==geometry_symmetry_cyl_hw) then
            assert(min_corner[2]==zero 
     $           && (abs(max_corner[2]-two*PI) < geom_epsilon))
         else
            do i=1,2
               if (i == 1) then
                  y=min_corner[2]
               else 
                  y=max_corner[2]
               end if
               cos_y=cos(y)
               sin_y=sin(y)
               vc_set(a,-sin_y,cos_y,zero)
               vc_set(b,max_corner[1]*cos_y,max_corner[1]*sin_y,max_corner[3])
               call plane(b,a,coeff)
               face=define_surface(coeff,.true.)
               call add_surface(face,0,.true.)     // Right sign?
            end do
         end if

         do i=0,3
            call conea(x[i][1],x[i+1][1],coeff,surf_type,apex)
            face=define_surface(coeff,.true.)
            if (face>0) then
               vc_copy(x[i],surface_points[0,face])
               vc_copy(x[i+1],surface_points[1,face])
            end if
            call add_surface(face,0,.true.)
         end do

@#if 0
         vol=PI*(max_corner[1]^2-min_corner[1]^2)*(max_corner[3]-min_corner[3])
@#else
         vol=half*(max_corner[2]-min_corner[2])
     $         *(max_corner[1]^2-min_corner[1]^2)*(max_corner[3]-min_corner[3])
@#endif

      else if (symmetry==geometry_symmetry_plane || symmetry==geometry_symmetry_oned || symmetry==geometry_symmetry_plane_hw) then
         vc_set(a,zero,one,zero)
         call plane(min_corner,a,coeff)
         face1=define_surface(coeff,.true.)
         call add_surface(face1,0,.true.)
         call plane(max_corner,a,coeff)
         face2=define_surface(coeff,.true.)
         call add_surface(-face2,0,.true.)
         if (symmetry != geometry_symmetry_plane_hw) then
            call init_identity(tx)
            vc_set(x0,zero,-(max_corner[2]-min_corner[2]),zero)
            call geom_translate(x0,tx)
            call add_transform(face1,face2,tx)
            call invert(tx,tx)
            call add_transform(-face2,-face1,tx)
         end if

         do i=0,3
            vc_copy(x[i],x1)
            vc_copy(x[i+1],x2)
            if (vector_compare(x1,x2)>0) then
               vc_set(x3,x1[1],one,x1[3])
            else
               vc_set(x3,x2[1],one,x2[3])
            end if
            call planea(x1,x3,x2,coeff)
            face=define_surface_a(coeff,x1,x2)
            if (i==3) face1=face
            if (i==1) face2=-face
            if (face>0) then
               vc_copy(x1,surface_points[0,face])
               vc_copy(x2,surface_points[1,face])
            end if
            call add_surface(face,0,.true.)
         end do

         if (symmetry==geometry_symmetry_oned ) then
            call init_identity(tx)
            vc_set(x0,zero,zero,-(max_corner[3]-min_corner[3]))
            call geom_translate(x0,tx)
            call add_transform(face1,face2,tx)
            call invert(tx,tx)
            call add_transform(-face2,-face1,tx)
         end if
            
         vol=(max_corner[1]-min_corner[1])*(max_corner[2]-min_corner[2])*
     $        (max_corner[3]-min_corner[3])
      end if

      geometry_symmetry=symmetry
      universal_cell_vol=vol

      return
      end

@ Set up arrays describing cell boundaries and surface neighbors.

@<Functions...@>=
      subroutine boundaries_neighbors
      implicit_none_f77
      gi_common                 // Input/Output
      zn_common
      al_common
      implicit_none_f90
      integer j,k,i,base,sigma,init  // Local
      integer ptr_surf_list,ptr_cell_list  // Pointers
      @<Memory allocation interface@>
      al_decls

      /* Pack |cells| and |surfaces| */

      var_reallocb(cells)
      var_reallocb(surfaces)
      var_reallocb(surface_sectors)
      var_reallocb(surface_coeffs)
      var_reallocb(surface_points)

      var_reallocb(zone_type)
      var_reallocb(zone_index)
      var_reallocb(zone_center)
      var_reallocb(zone_pointer)
      var_reallocb(zone_volume)
      var_reallocb(zone_min)
      var_reallocb(zone_max)

      var_reallocb(surfaces_tx_ind)
      var_reallocb(surfaces_tx_mx)

      init=TRUE
      do i=1,zn_num
         if (zone_type[i] == zn_plasma) then
            if (init == TRUE) then
               zone_index_min[zi_ix]=zone_index[i][zi_ix]
               zone_index_max[zi_ix]=zone_index[i][zi_ix]
               zone_index_min[zi_iz]=zone_index[i][zi_iz]
               zone_index_max[zi_iz]=zone_index[i][zi_iz]
               zone_index_min[zi_iy]=0
               zone_index_max[zi_iy]=0
               zone_index_min[zi_ptr]=0
               zone_index_max[zi_ptr]=0
               init=FALSE
            else
               zone_index_min[zi_ix]=min(zone_index_min[zi_ix],zone_index[i][zi_ix])
               zone_index_max[zi_ix]=max(zone_index_max[zi_ix],zone_index[i][zi_ix])
               zone_index_min[zi_iz]=min(zone_index_min[zi_iz],zone_index[i][zi_iz])
               zone_index_max[zi_iz]=max(zone_index_max[zi_iz],zone_index[i][zi_iz])
               zone_index_min[zi_iy]=min(zone_index_min[zi_iy],zone_index[i][zi_iy])
               zone_index_max[zi_iy]=max(zone_index_max[zi_iy],zone_index[i][zi_iy])
            end if
         end if
      end do

      nboundaries=0
      do j=0,ncells
         nboundaries=nboundaries+cells[c_surfaces,j]
      end do
      var_alloc(boundaries)


      base=0
      do j=0,ncells
         ptr_surf_list=cells[c_start,j]
         do i=1,cells[c_surfaces,j]
            boundaries[base+i]=surf_list(i)
         end do
         assert(check_mem())
         call free_mem(ptr_surf_list,mem_frag(cells[c_surfaces,j]))
         cells[c_start,j]=base+1
         base=base+cells[c_surfaces,j]
      end do

      check(base == nboundaries)

      nneighbors=ncells
      do k=1,nsurfaces
         do sigma=s_neg,s_pos
            if (surfaces[sigma,s_count,k]>1)
     $           nneighbors=nneighbors+surfaces[sigma,s_count,k]
         end do
      end do
      var_alloc(neighbors)

      do i=0,ncells
         neighbors[i]=i
      end do

      base=ncells
      do k=1,nsurfaces
         do sigma=s_neg,s_pos
            ptr_cell_list=surfaces[sigma,s_start,k]
            if (surfaces[sigma,s_count,k]==1) then
               surfaces[sigma,s_start,k]=cell_list(1)
            else
               do i=1,surfaces[sigma,s_count,k]
                  neighbors[base+i]=cell_list(i)
               end do
               surfaces[sigma,s_start,k]=base+1
               base=base+surfaces[sigma,s_count,k]
            end if
            assert(check_mem())
            call free_mem(ptr_cell_list,mem_frag(surfaces[sigma,s_count,k]))
         end do
      end do

      check(base == nneighbors)
      assert(check_mem())
      return
      end

@* Set up arrays mapping surfaces into sectors.

@<Functions...@>=
      subroutine end_sectors
      implicit_none_f77
      gi_common                 // Input/Output
      sc_common
      al_common
      implicit_none_f90
      integer k,i,base,sigma    // Local
      integer ptr_sector_list    // Pointer
      @<Memory allocation interface@>
      al_decls

/* 
   Pack |strata| and sector-related arrays. |surface_sectors| allocated 
   with |surfaces|; |srufaces_tx_mx| done in |boundaries_neighbors|. 
   See below for |sectors|.
*/

      var_reallocb(strata)
      var_reallocb(sector_strata_segment)  
      var_reallocb(sector_zone)
      var_reallocb(sector_surface)
      var_reallocb(sector_points)
      var_reallocb(sector_type_pointer)

      var_reallocb(vacuum_sector)

      var_reallocb(plasma_sector)

      var_reallocb(target_sector)
      var_reallocb(target_material)
      var_reallocb(target_temperature)
      var_reallocb(target_recyc_coef)

      var_reallocb(wall_sector)
      var_reallocb(wall_material)
      var_reallocb(wall_temperature)
      var_reallocb(wall_recyc_coef)

      var_reallocb(exit_sector)
@#if 0
      var_reallocb(exit_albedo)
@#endif

      var_reallocb(diagnostic_grp_name)
      var_reallocb(diagnostic_num_sectors)
      var_reallocb(diagnostic_var)
      var_reallocb(diagnostic_tab_index)
      var_reallocb(diagnostic_min)
      var_reallocb(diagnostic_delta)
      var_reallocb(diagnostic_spacing)
      var_reallocb(diagnostic_grp_base)

      var_alloc(sectors)
      sectors[0]=int_unused

      base=0
      do k=1,nsurfaces
         do sigma=s_neg,s_pos
            ptr_sector_list=surface_sectors[sigma,s_start,k]
            do i=1,surface_sectors[sigma,s_count,k]
               sectors[base+i]=sector_list(i)
            end do
            surface_sectors[sigma,s_start,k]=base+1
            base=base+surface_sectors[sigma,s_count,k]
            assert(check_mem())
            call free_mem(ptr_sector_list,mem_frag(surface_sectors[sigma,s_count,k]))
         end do
      end do
      
      check(base == nsectors)
      assert(check_mem())
      return
      end

@* Defining surfaces and volumes.  Register a new surface.  If |duplicate|,
then search for duplicates and return the duplicate index if it exists.

@<Functions...@>=
      function define_surface(coeff,duplicate)
      implicit_none_f77
      gi_common                 // Input/Output
      implicit_none_f90
      integer define_surface    // Function
      real coeff[NCOEFFS]       // Input
      logical duplicate
      integer i,k,orientation   // Local
      @<Memory allocation interface@>
      external surface_normalize,surface_equal // External
      logical surface_equal

      call surface_normalize(coeff)
      if (duplicate) then
         do k=1,nsurfaces
            if (surface_equal(coeff,slice1(surface_coeffs,[k]),orientation)) then
               define_surface=orientation*k
               return
            end if
         end do
      end if

      nsurfaces++
      var_realloca(surfaces)
      var_realloca(surface_sectors)
      var_realloca(surface_coeffs)
      var_realloca(surface_points)
      var_realloca(surfaces_tx_ind)

      do i=1,NCOEFFS
         surface_coeffs[i,nsurfaces]=coeff[i]
      end do
      surfaces[s_neg,s_start,nsurfaces] = 0
      surfaces[s_neg,s_count,nsurfaces] = 0
      surfaces[s_pos,s_start,nsurfaces] = 0
      surfaces[s_pos,s_count,nsurfaces] = 0

      surface_sectors[s_neg,s_start,nsurfaces] = 0
      surface_sectors[s_neg,s_count,nsurfaces] = 0
      surface_sectors[s_pos,s_start,nsurfaces] = 0
      surface_sectors[s_pos,s_count,nsurfaces] = 0

      surfaces_tx_ind[s_neg,t_surf,nsurfaces] = 0
      surfaces_tx_ind[s_neg,t_mx,nsurfaces] = 0
      surfaces_tx_ind[s_pos,t_surf,nsurfaces] = 0
      surfaces_tx_ind[s_pos,t_mx,nsurfaces] = 0
      
      vc_set(surface_points[0,nsurfaces],real_undef,real_undef,real_undef)
      vc_set(surface_points[1,nsurfaces],real_undef,real_undef,real_undef)

      define_surface=nsurfaces

      return
      end

@ Register a new surface.  If |x1| and |x2| are possible values of
|surface_points| and this routine only returns an existing surface if
these values match.

@<Functions...@>=
      function define_surface_a(coeff,x1,x2)
      implicit_none_f77
      gi_common                 // Input/Output
      implicit_none_f90
      integer define_surface_a    // Function
      real coeff[NCOEFFS],x1[3],x2[3]       // Input
      external define_surface,lookup_surface // External
      integer define_surface,lookup_surface

      define_surface_a=lookup_surface(x1,x2)
      
      if (define_surface_a == 0) then
         define_surface_a=define_surface(coeff,.false.)
      end if
         
      return
      end

@ Lookup a surface based on |surface_points|.  Returns 0 if none found.

@<Functions...@>=
      function lookup_surface(x1,x2)
      implicit_none_f77
      gi_common                 // Input/Output
      implicit_none_f90
      integer lookup_surface    // Function
      real x1[3],x2[3]          // Input
      integer k                 // Local

      do k=1,nsurfaces
         if (vc_equal(x1,surface_points[0,k]) &&
     $        vc_equal(x2,surface_points[1,k])) then
            lookup_surface = k
            return
         else if (vc_equal(x1,surface_points[1,k]) &&
     $           vc_equal(x2,surface_points[0,k])) then
            lookup_surface = -k
            return
         end if
      end do
      
      lookup_surface=0
         
      return
      end

@ Lookup a sector based on |sector_points|.  Returns 0 if none found.

@<Functions...@>=
      function lookup_sector(x1,x2)
      implicit_none_f77
      gi_common                 // Input/Output
      sc_common
      implicit_none_f90
      integer lookup_sector    // Function
      real x1[3],x2[3]          // Input
      integer k                 // Local


      do k=1,nsectors
         if (vc_equal(x1,sector_points[0,k]) &&
     $        vc_equal(x2,sector_points[1,k])) then
            lookup_sector = k
            return
         end if
      end do
      
      lookup_sector=0
         
      return
      end

@ Sloppy version of |lookup_sector|.  Returns 0 if none found.  Allow the
permitted error, |slop| (in meters), to be input since the initial need 
for this routine is the result of limited precision in an external code.

@m sloppy_vc_equal(x,y)
      ((abs(x[1]-y[1]) < slop) && (abs(x[2]-y[2]) < slop) && (abs(x[3]-y[3]) < slop))

@<Functions...@>=
      function sloppy_lookup_sector(x1,x2,slop)
      implicit_none_f77
      gi_common                       // Input/Output
      sc_common
      implicit_none_f90
      integer sloppy_lookup_sector    // Function
      real x1[3],x2[3]                // Input
      real slop
      integer k                       // Local


      do k=1,nsectors
         if (sloppy_vc_equal(x1,sector_points[0,k]) &&
     $        sloppy_vc_equal(x2,sector_points[1,k])) then
            sloppy_lookup_sector = k
            return
         end if
      end do
      
      sloppy_lookup_sector=0
         
      return
      end

@ Start definition of a cell.

@<Functions...@>=
      function start_cell(zone)
      implicit_none_f77
      gi_common                 // Input/Output
      zn_common
      implicit_none_f90
      integer start_cell        // Function
      integer zone            // Input
      integer z
      @<Memory allocation interface@>
      

      ncells++
      var_realloca(cells)

      assert(zone>0)
      cells[c_zone,ncells]=zone
      cells[c_start,ncells]=0
      cells[c_faces,ncells]=0
      cells[c_surfaces,ncells]=0

      start_cell=ncells
      
      var_reallocc(zone_type,zn_num,max(zn_num,zone))
      var_reallocc(zone_index,zn_num,max(zn_num,zone))
      var_reallocc(zone_center,zn_num,max(zn_num,zone))
      var_reallocc(zone_pointer,zn_num,max(zn_num,zone))
      var_reallocc(zone_volume,zn_num,max(zn_num,zone))
      var_reallocc(zone_min,zn_num,max(zn_num,zone))
      var_reallocc(zone_max,zn_num,max(zn_num,zone))
      
      do z=zn_num+1,max(zn_num,zone)
         zone_type[z]=int_undef
         zone_index[z][zi_ix]=int_undef
         zone_index[z][zi_iz]=int_undef
         zone_index[z][zi_iy]=int_undef
         zone_index[z][zi_ptr]=int_undef
         vc_set(zone_center[z],real_undef,real_undef,real_undef)
         zone_volume[z]=real_undef
         vc_set(zone_min[z],real_undef,real_undef,real_undef)
         vc_set(zone_max[z],real_undef,real_undef,real_undef)
      end do

      zn_num=max(zn_num,zone)

      return
      end
      
@ Add a surface $k$ to a cell $j$.  If |face|, then this surface is a face.

@<Functions...@>=
      subroutine add_surface(surface,cell,face)
      implicit_none_f77
      gi_common                 // Input/Output
      al_common
      implicit_none_f90
      integer surface,cell // Input
      logical face
      integer i,surface_count,cell_count // Local
      integer ptr_surf_list,ptr_cell_list // Pointers
      @<Memory allocation interface@>
      al_decls

      ptr_surf_list=cells[c_start,cell]
      surface_count=cells[c_surfaces,cell]
      if (mod(surface_count,mem_delta) == 0) then
         assert(check_mem())
         ptr_surf_list=realloc_mem(ptr_surf_list,
     $        surface_count,surface_count+mem_delta)
         cells[c_start,cell]=ptr_surf_list
      end if
      cells[c_surfaces,cell]=surface_count+1

      if (face) then            // We have to move the cut surfaces up one
         cells[c_faces,cell]=cells[c_faces,cell]+1
         do i=cells[c_surfaces,cell],cells[c_faces,cell]+1,-1
            surf_list(i)=surf_list(i-1)
         end do
         surf_list(cells[c_faces,cell])=surface
      else                      // |! face| --- it's a cut surface
         surf_list(cells[c_surfaces,cell])=surface
      end if

      if (face) then            // Register the cell for this face
         ptr_cell_list=surfaces[s_sign(surface),s_start,abs(surface)]
         cell_count=surfaces[s_sign(surface),s_count,abs(surface)]

         if (mod(cell_count,mem_delta) == 0) then
            assert(check_mem())
            ptr_cell_list=realloc_mem(ptr_cell_list,
     $           cell_count,cell_count+mem_delta)
         end if
         cell_count++
         cell_list(cell_count)=cell

         surfaces[s_sign(surface),s_start,abs(surface)]=ptr_cell_list
         surfaces[s_sign(surface),s_count,abs(surface)]=cell_count
      end if
            
      return
      end

@* Define a new sector belonging to a particular stratum. The arguments
|surface| and |zone1| completely define the sector. However, present
usage has many properties of the adjoining second zone, |zone2|, assigned 
to the sector. As an extra check, |zone2| may be specified when calling
this routine. The code will verify that |zone2| and |zone1| are indeed
adjacent with |surface| separating them. This check can be bypassed
by setting |zone2| = 0.

@<Functions...@>=
      function define_sector(stratum,seg,surface,zone1,zone2)
      implicit_none_f77
      gi_common                                      // Input/Output
      sc_common
      zn_common
      al_common
      implicit_none_f90
      integer define_sector                          // Function
      integer stratum,seg,surface,zone1,zone2        // Input
      integer i,sector_count,base,zone_sign,         // Local
     $        icell,num_faces,iface
      integer ptr_sector_list                        // Pointer
      logical match_plus,match_minus
      @<Memory allocation interface@>
      al_decls
      zn_decls

      assert(stratum > 0)
      assert(surface != 0)
      assert(zn_check(zone1))

/*
   Check orientation of |surface|, |zone1|, and |zone2| (if specified).
*/
      match_plus=.false.
      match_minus=.false.
      zone_sign=0
      do icell=0,ncells
         if (cells[c_zone,icell] == zone1) then
            zone_sign=1
         else if (zn_check(zone2) && cells[c_zone,icell] == zone2) then
            zone_sign=-1
         end if
         if (zone_sign != 0) then
            num_faces=cells[c_faces,icell]
            assert(num_faces > 0)
            do iface=cells[c_start,icell],cells[c_start,icell]+num_faces-1
               if (boundaries[iface] == zone_sign*surface) then
                  if (zone_sign > 0) then
                     match_plus=.true.
                  else
                     match_minus=.true.
                  end if
               end if
            end do
            zone_sign=0
         end if
      end do
      assert(match_plus && (!zn_check(zone2) || match_minus))
      
      nsectors++

      var_realloca(strata)
      var_realloca(sector_strata_segment)
      var_realloca(sector_zone)
      var_realloca(sector_surface)
      var_realloca(sector_points)
      var_realloca(sector_type_pointer)

      strata[nsectors]=stratum
      sector_strata_segment[nsectors]=seg
      sector_zone[nsectors]=zone1
      sector_surface[nsectors]=surface

      if (surface>0) then
         vc_copy(surface_points[0,surface],sector_points[0,nsectors])
         vc_copy(surface_points[1,surface],sector_points[1,nsectors])
      else
         vc_copy(surface_points[0,-surface],sector_points[1,nsectors])
         vc_copy(surface_points[1,-surface],sector_points[0,nsectors])
      end if

      do i=1,sc_type_max
         sector_type_pointer[nsectors][i]=int_unused
      end do

      ptr_sector_list=surface_sectors[s_sign(surface),s_start,abs(surface)]
      sector_count=surface_sectors[s_sign(surface),s_count,abs(surface)]

      if (mod(sector_count,mem_delta) == 0) then
         assert(check_mem())
         ptr_sector_list=realloc_mem(ptr_sector_list,
     $        sector_count,sector_count+mem_delta)
      end if
      sector_count++
      sector_list(sector_count)=nsectors

      surface_sectors[s_sign(surface),s_start,abs(surface)]=ptr_sector_list
      surface_sectors[s_sign(surface),s_count,abs(surface)]=sector_count

      base=surfaces[s_sign(surface),s_start,abs(surface)]-1
      do i=1,surfaces[s_sign(surface),s_count,abs(surface)]
         if (cells[c_zone,neighbors[base+i]]==zone1) goto break
      end do
      assert(.false.)
break: continue

      define_sector=nsectors
      
      return
      end

@* Define a transform for surface.

@<Functions...@>=
      subroutine add_transform(surface,newsurface,tx)
      implicit_none_f77
      gi_common                 // Input/Output
      implicit_none_f90
      integer surface,newsurface // Input
      real tx[3,4]
      integer i                 // Local
@#if 0
      real coeff[NCOEFFS]
@#endif
      @<Memory allocation interface@>

      ntransforms++
      var_realloca(surfaces_tx_mx)
      
      surfaces_tx_ind[s_sign(surface),t_surf,abs(surface)]=newsurface
      surfaces_tx_ind[s_sign(surface),t_mx,abs(surface)]=ntransforms
      do i=1,4
         vc_copy(tx[i],surfaces_tx_mx[ntransforms][i])
      end do


@#if 0      
      write(stdout,*) 'original coeff:', (surface_coeffs[i,abs(surface)],i=1,NCOEFFS)
      call transform_face(surface_coeffs[1,abs(newsurface)],tx,coeff)
      write(stdout,*) 'trans    coeff:', (coeff[i],i=1,NCOEFFS)
@#endif
      
      return
      end

@* Simple check of geometry.

@m breakb #:0
@m breakc #:0

@<Functions...@>=
      subroutine check_geometry

      define_dimen(outer_surf_ind,num_outer_surfaces)
      define_varp(outer_surfaces,INT,outer_surf_ind)

      implicit_none_f77
      gi_common                                                    // Input
      sc_common
      implicit_none_f90
      @<Memory allocation interface@>
      integer n,j,k,sigma,type,real_sector,type_ptr,opp_side,      // Local
     $        jb,jc,count,start,same_zone,first_zone
      logical outer,opp_outer
      declare_varp(outer_surfaces)
      integer num_outer_surfaces,orientation
      external surface_equal
      logical surface_equal
      

      assert(ncells>0)
      assert(nboundaries>0)
      assert(nsurfaces>0)
      assert(nneighbors>0)

      do j=0,ncells
         assert(cells[c_faces,j]>0) // Each cell needs a faces
         assert(cells[c_surfaces,j]>=cells[c_faces,j]) // and as many surfaces as faces
         assert(cells[c_start,j]>0) // Pointers to |boundaries| need to be reasonable
         assert(cells[c_start,j]+cells[c_surfaces,j]-1<=nboundaries)
      end do

      do k=1,nboundaries
         assert(boundaries[k]!=0 && abs(boundaries[k])<=nsurfaces) // Check |boundaries| is in bounds
      end do

      do j=0,nneighbors
         assert(neighbors[j]>=0 && neighbors[j]<=ncells) // Also check |neighbors|
      end do

      num_outer_surfaces=0
      do k=1,nsurfaces
         outer=.false.
         do sigma=s_neg,s_pos
            assert(surfaces[sigma,s_count,k]>=0)
            assert(surfaces[sigma,s_start,k]>=0) // Check pointers to |neighbors| are in bounds
            assert(surfaces[sigma,s_start,k]+surfaces[sigma,s_count,k]-1<=nneighbors)
            if (surfaces[sigma,s_count,k] > 0) then
               do j=surfaces[sigma,s_start,k],surfaces[sigma,s_start,k]+surfaces[sigma,s_count,k]-1
                  if (neighbors[j]==0) then 
                     outer=.true.
                     goto break
                  end if
               end do
break:         continue
            else
/*
   The only reasons for there to be no cells on this side of a surface is that this is an outer
   surface or it's a cut surface. 
*/
               if (sigma == s_neg) then
                  opp_side=s_pos
               else
                  opp_side=s_neg
               end if
               if (surfaces[opp_side,s_count,k] > 0) then
/*
   If the other side has neighbors, the universal cell will actually be listed there as a neighbor, so
   we can check it to verify that we do indeed have an outer surface here.
*/
                  opp_outer=.false.
                  do j=surfaces[opp_side,s_start,k],surfaces[opp_side,s_start,k]+surfaces[opp_side,s_count,k]-1
                     if (neighbors[j]==0) then 
                        opp_outer=.true.
                        goto break2
                     end if
                  end do
break2:           continue
                  if (!opp_outer) then
                     write(stderr,*) 'This surface isn''t an outer surface, but there''s something on one side and not on the other (first instance)'
                     write(stderr,*) k
                     write(stderr,*) vc_expand(surface_points[0,k])
                     write(stderr,*) vc_expand(surface_points[1,k])
                     assert(.false.)
                  end if
/*
   Alternatively, if both sides of |k| have 0 |s_count|, we must then have a cut surface. This check verifies that.
   It's a little circuitous, but should work.
*/
               else  
/*
   First, find the entry in |boundaries| corresponding to this surface. Note that 
   only one side of a cut surface usually enters the problem. Hence, we can
   just compare with the absolute value.
*/
                  do j=1,nboundaries
                     if (abs(boundaries[j]) == k) then
                        jb=j
                        goto breakb
                     end if
                  end do
                  assert(' No boundary found matching this surface' == ' ')
breakb:           continue
/*
   Then, check the list of |boundaries| entries in the |cells| array, finding the
   one just below |jb| (i.e., this assumes that the |boundaries| and |cells|
   arrays are both built in ascending order).
*/
                  do j=1,ncells
                     if (cells[c_start,j] > jb) then
                        jc=j-1
                        goto breakc
                     end if
                  end do
/*
   Assume that the cell must be the last one. The subsequent assert
   will check this assumption.
*/
                  jc=ncells
breakc:           continue
/*
   Finally, check that this |jb| is in the range of cut surfaces for
   this cell.
*/
                  assert((jb >= cells[c_start,jc]+cells[c_faces,jc])
     $                 && (jb <= cells[c_start,jc]+cells[c_surfaces,jc]-1))
               end if
            end if
/*
   In the case of multiple sectors at a surface, verify that the first
   one is of non-diagnostic type, i.e., that PMIs can be processed using
   it. First, need to determine whether or not the sectors in
   question are all associated with the same zone.  The subsequent test 
   was copied from |score_sector|.
*/
            if (surface_sectors[sigma,s_count,k] > 1) then
               count=surface_sectors[sigma,s_count,k]
               start=surface_sectors[sigma,s_start,k]
               same_zone=FALSE
               first_zone=sector_zone[sectors[start]]
               do j=1,count-1
                  if (sector_zone[sectors[start+j]] == first_zone) 
     $                 same_zone=TRUE
               end do
               if (same_zone == TRUE) then
                  real_sector=FALSE
                  do type=1,sc_diagnostic(0)
                     type_ptr=sector_type_pointer[sectors[start]][type]
                     if ((type_ptr != int_unused) 
     $                    && (type_ptr != int_undef)) then
                        real_sector=TRUE
                     end if
                  end do
                  assert(real_sector == TRUE)
               end if
            end if
         end do
         if (outer) then
 /* If the surface is face of the universal cell, then there's nothing on
    the other side and some other cell must be on the same side.
    Keep track of these original outer surfaces.
 */
            assert(surfaces[s_neg,s_count,k]==0 || surfaces[s_pos,s_count,k]==0)
            assert(surfaces[s_neg,s_count,k]>0 || surfaces[s_pos,s_count,k]>0)
            if (mod(num_outer_surfaces,mem_delta) == 0)
     $           var_realloc(outer_surfaces,num_outer_surfaces,num_outer_surfaces+mem_delta)
            num_outer_surfaces++
            outer_surfaces[num_outer_surfaces]=k

         else                   /* |!outer| */

 /* Either the surface is a cut surface with nothing on either side or else
    there is at least one cell on each side */
            if (surfaces[s_neg,s_count,k]==0) then
                     
               if (surfaces[s_pos,s_count,k]!=0) then
/*
   The surface may be degenerate with one of the original outer surfaces, but
   does not have the universal cell explicitly listed as a neighbor (because
   |k| is {\em not} one of the originals0. If so, break out of here.
*/
                  do j=1,num_outer_surfaces
                     if (surface_equal(slice1(surface_coeffs,[k]),   // Not original, but still outer
     $                    slice1(surface_coeffs,[outer_surfaces[j]]),orientation)) goto break1
                  end do
                  write(stderr,*) 'This surface isn''t an outer surface, but there''s something on one side and not on the other (2nd instance)'
                  write(stderr,*) k
                  write(stderr,*) vc_expand(surface_points[0,k])
                  write(stderr,*) vc_expand(surface_points[1,k])
                  assert(.false.)
               end if
               do j=0,ncells
                  do n=cells[c_faces,j]+1,cells[c_surfaces,j]
                     if (abs(boundaries[cells[c_start,j]-1+n])==k) goto break1
                  end do
               end do
               assert(.false.)  // An orphan face
break1:        continue
            else
               assert(surfaces[s_pos,s_count,k]>0)
            end if
         end if
      end do

      return
      end
      
@ Print out geometry.

@<Functions...@>=
      subroutine print_geometry(unit)
      implicit_none_f77
      gi_common
      implicit_none_f90
      integer unit              // Input
      integer i,j,k             // Local

      write(unit,*) ncells
      do i=0,ncells
         write(unit,*) i,(cells[j,i],j=1,4)
      end do
      write(unit,*) nboundaries
      do i=1,nboundaries
         write(unit,*) i,boundaries[i]
      end do
      write(unit,*) nsurfaces
      do i=1,nsurfaces
         write(unit,*) i,((surfaces[j,k,i],j=0,1),k=0,1)
      end do
      do i=1,nsurfaces
         write(unit,'(i4,10f7.4)') i,(surface_coeffs[j,i],j=1,NCOEFFS)
      end do
      write(unit,*) nneighbors
      do i=0,nneighbors
         write(unit,*) i,neighbors[i]
      end do

      return
      end

@ Erase geometry.

@<Functions...@>=
      subroutine erase_geometry
      implicit_none_f77
      gi_common                 // Input/Output
      sc_common
      de_common
      implicit_none_f90
      @<Memory allocation interface@>

      var_free(cells)
      var_free(surfaces)
      var_free(surface_coeffs)
      var_free(surface_points)
      var_free(boundaries)
      var_free(neighbors)
      var_free(surface_sectors)
      var_free(surfaces_tx_ind)
      var_free(surfaces_tx_mx)
      var_free(strata)
      var_free(sector_strata_segment)
      var_free(sectors)
      var_free(sector_zone)
      var_free(sector_surface)
      var_free(sector_points)
      var_free(sector_type_pointer)
      var_free(vacuum_sector)
      var_free(plasma_sector)
      var_free(target_sector)
      var_free(target_material)
      var_free(target_temperature)
      var_free(target_recyc_coef)
      var_free(wall_sector)
      var_free(wall_material)
      var_free(wall_temperature)
      var_free(wall_recyc_coef)
      var_free(exit_sector)
@#if 0
      var_free(exit_albedo)
@#endif
      var_free(diagnostic_grp_name)
      var_free(diagnostic_num_sectors)
      var_free(diagnostic_var)
      var_free(diagnostic_tab_index)
      var_free(diagnostic_min)
      var_free(diagnostic_delta)
      var_free(diagnostic_spacing)
      var_free(diagnostic_grp_base)
      var_free(diagnostic_sector_tab)
      var_free(detector_name)
      var_free(detector_num_views)
      var_free(detector_var)
      var_free(detector_tab_index)
      var_free(detector_min)
      var_free(detector_delta)
      var_free(detector_spacing)
      var_free(de_view_base)
      var_free(de_view_tab)

      var_free(de_zone_frags)
      var_free(de_zone_frags_start)
      var_free(de_zone_frags_num)
      var_free(de_zone_frags_zones)
      var_free(de_zone_frags_min_zn)
      var_free(de_zone_frags_max_zn)

      ncells=-1
      nsurfaces=0
      nboundaries=0
      nneighbors=-1
      ntransforms=0
      nsectors=0

      return
      end

@ Write the geometry to a netcdf file.

@<Functions...@>=
      subroutine write_geometry
      implicit_none_f77
      gi_common
      zn_common
      rf_common
      sc_common
      de_common
      implicit_none_f90
      nc_decls
      gi_ncdecl
      zn_ncdecl
      cm_ncdecl
      sc_ncdecl
      de_ncdecl
      integer fileid
      character*FILELEN tempfile

      tempfile = filenames_array[geometryfile]
      assert(tempfile != char_undef)
      fileid = nccreate(tempfile,NC_CLOBBER,nc_stat)
      cm_ncdef(fileid)
      gi_ncdef(fileid)
      zn_ncdef(fileid)
      sc_ncdef(fileid)
      de_ncdef(fileid)
      call ncendef(fileid,nc_stat);
      cm_ncwrite(fileid)
      gi_ncwrite(fileid)
      zn_ncwrite(fileid)
      sc_ncwrite(fileid)
      de_ncwrite(fileid)
      call ncclose(fileid,nc_stat)

      return
      end
      
@* INDEX.
